var cy=Object.defineProperty;var gd=Object.getOwnPropertySymbols;var hy=Object.prototype.hasOwnProperty,uy=Object.prototype.propertyIsEnumerable;var xd=(n,t,e)=>t in n?cy(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e,_d=(n,t)=>{for(var e in t||(t={}))hy.call(t,e)&&xd(n,e,t[e]);if(gd)for(var e of gd(t))uy.call(t,e)&&xd(n,e,t[e]);return n};function ic(n,t){const e=Object.create(null),i=n.split(",");for(let s=0;s<i.length;s++)e[i[s]]=!0;return t?s=>!!e[s.toLowerCase()]:s=>!!e[s]}const dy="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",fy=ic(dy);function yd(n){return!!n||n===""}function sc(n){if(Lt(n)){const t={};for(let e=0;e<n.length;e++){const i=n[e],s=Ee(i)?gy(i):sc(i);if(s)for(const r in s)t[r]=s[r]}return t}else{if(Ee(n))return n;if(de(n))return n}}const py=/;(?![^(]*\))/g,my=/:(.+)/;function gy(n){const t={};return n.split(py).forEach(e=>{if(e){const i=e.split(my);i.length>1&&(t[i[0].trim()]=i[1].trim())}}),t}function rc(n){let t="";if(Ee(n))t=n;else if(Lt(n))for(let e=0;e<n.length;e++){const i=rc(n[e]);i&&(t+=i+" ")}else if(de(n))for(const e in n)n[e]&&(t+=e+" ");return t.trim()}function xy(n,t){if(n.length!==t.length)return!1;let e=!0;for(let i=0;e&&i<n.length;i++)e=gs(n[i],t[i]);return e}function gs(n,t){if(n===t)return!0;let e=bd(n),i=bd(t);if(e||i)return e&&i?n.getTime()===t.getTime():!1;if(e=Lt(n),i=Lt(t),e||i)return e&&i?xy(n,t):!1;if(e=de(n),i=de(t),e||i){if(!e||!i)return!1;const s=Object.keys(n).length,r=Object.keys(t).length;if(s!==r)return!1;for(const o in n){const a=n.hasOwnProperty(o),l=t.hasOwnProperty(o);if(a&&!l||!a&&l||!gs(n[o],t[o]))return!1}}return String(n)===String(t)}function _y(n,t){return n.findIndex(e=>gs(e,t))}const v3=n=>n==null?"":Lt(n)||de(n)&&(n.toString===wd||!Ft(n.toString))?JSON.stringify(n,vd,2):String(n),vd=(n,t)=>t&&t.__v_isRef?vd(n,t.value):_s(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((e,[i,s])=>(e[`${i} =>`]=s,e),{})}:$o(t)?{[`Set(${t.size})`]:[...t.values()]}:de(t)&&!Lt(t)&&!Sd(t)?String(t):t,te={},xs=[],un=()=>{},yy=()=>!1,vy=/^on[^a-z]/,Xo=n=>vy.test(n),oc=n=>n.startsWith("onUpdate:"),ke=Object.assign,ac=(n,t)=>{const e=n.indexOf(t);e>-1&&n.splice(e,1)},by=Object.prototype.hasOwnProperty,Vt=(n,t)=>by.call(n,t),Lt=Array.isArray,_s=n=>Yo(n)==="[object Map]",$o=n=>Yo(n)==="[object Set]",bd=n=>n instanceof Date,Ft=n=>typeof n=="function",Ee=n=>typeof n=="string",lc=n=>typeof n=="symbol",de=n=>n!==null&&typeof n=="object",Md=n=>de(n)&&Ft(n.then)&&Ft(n.catch),wd=Object.prototype.toString,Yo=n=>wd.call(n),My=n=>Yo(n).slice(8,-1),Sd=n=>Yo(n)==="[object Object]",cc=n=>Ee(n)&&n!=="NaN"&&n[0]!=="-"&&""+parseInt(n,10)===n,Zo=ic(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Jo=n=>{const t=Object.create(null);return e=>t[e]||(t[e]=n(e))},wy=/-(\w)/g,An=Jo(n=>n.replace(wy,(t,e)=>e?e.toUpperCase():"")),Sy=/\B([A-Z])/g,ys=Jo(n=>n.replace(Sy,"-$1").toLowerCase()),Ko=Jo(n=>n.charAt(0).toUpperCase()+n.slice(1)),hc=Jo(n=>n?`on${Ko(n)}`:""),Cr=(n,t)=>!Object.is(n,t),Qo=(n,t)=>{for(let e=0;e<n.length;e++)n[e](t)},ta=(n,t,e)=>{Object.defineProperty(n,t,{configurable:!0,enumerable:!1,value:e})},ea=n=>{const t=parseFloat(n);return isNaN(t)?n:t};let Ed;const Ey=()=>Ed||(Ed=typeof globalThis!="undefined"?globalThis:typeof self!="undefined"?self:typeof window!="undefined"?window:typeof global!="undefined"?global:{});let Oi;const na=[];class Ty{constructor(t=!1){this.active=!0,this.effects=[],this.cleanups=[],!t&&Oi&&(this.parent=Oi,this.index=(Oi.scopes||(Oi.scopes=[])).push(this)-1)}run(t){if(this.active)try{return this.on(),t()}finally{this.off()}}on(){this.active&&(na.push(this),Oi=this)}off(){this.active&&(na.pop(),Oi=na[na.length-1])}stop(t){if(this.active){if(this.effects.forEach(e=>e.stop()),this.cleanups.forEach(e=>e()),this.scopes&&this.scopes.forEach(e=>e.stop(!0)),this.parent&&!t){const e=this.parent.scopes.pop();e&&e!==this&&(this.parent.scopes[this.index]=e,e.index=this.index)}this.active=!1}}}function Ay(n,t){t=t||Oi,t&&t.active&&t.effects.push(n)}const uc=n=>{const t=new Set(n);return t.w=0,t.n=0,t},Td=n=>(n.w&ni)>0,Ad=n=>(n.n&ni)>0,Cy=({deps:n})=>{if(n.length)for(let t=0;t<n.length;t++)n[t].w|=ni},Ly=n=>{const{deps:t}=n;if(t.length){let e=0;for(let i=0;i<t.length;i++){const s=t[i];Td(s)&&!Ad(s)?s.delete(n):t[e++]=s,s.w&=~ni,s.n&=~ni}t.length=e}},dc=new WeakMap;let Lr=0,ni=1;const fc=30,Rr=[];let ki;const Ni=Symbol(""),pc=Symbol("");class mc{constructor(t,e=null,i){this.fn=t,this.scheduler=e,this.active=!0,this.deps=[],Ay(this,i)}run(){if(!this.active)return this.fn();if(!Rr.includes(this))try{return Rr.push(ki=this),Ry(),ni=1<<++Lr,Lr<=fc?Cy(this):Cd(this),this.fn()}finally{Lr<=fc&&Ly(this),ni=1<<--Lr,zi(),Rr.pop();const t=Rr.length;ki=t>0?Rr[t-1]:void 0}}stop(){this.active&&(Cd(this),this.onStop&&this.onStop(),this.active=!1)}}function Cd(n){const{deps:t}=n;if(t.length){for(let e=0;e<t.length;e++)t[e].delete(n);t.length=0}}let vs=!0;const gc=[];function bs(){gc.push(vs),vs=!1}function Ry(){gc.push(vs),vs=!0}function zi(){const n=gc.pop();vs=n===void 0?!0:n}function Xe(n,t,e){if(!Ld())return;let i=dc.get(n);i||dc.set(n,i=new Map);let s=i.get(e);s||i.set(e,s=uc()),Rd(s)}function Ld(){return vs&&ki!==void 0}function Rd(n,t){let e=!1;Lr<=fc?Ad(n)||(n.n|=ni,e=!Td(n)):e=!n.has(ki),e&&(n.add(ki),ki.deps.push(n))}function Hn(n,t,e,i,s,r){const o=dc.get(n);if(!o)return;let a=[];if(t==="clear")a=[...o.values()];else if(e==="length"&&Lt(n))o.forEach((l,c)=>{(c==="length"||c>=i)&&a.push(l)});else switch(e!==void 0&&a.push(o.get(e)),t){case"add":Lt(n)?cc(e)&&a.push(o.get("length")):(a.push(o.get(Ni)),_s(n)&&a.push(o.get(pc)));break;case"delete":Lt(n)||(a.push(o.get(Ni)),_s(n)&&a.push(o.get(pc)));break;case"set":_s(n)&&a.push(o.get(Ni));break}if(a.length===1)a[0]&&xc(a[0]);else{const l=[];for(const c of a)c&&l.push(...c);xc(uc(l))}}function xc(n,t){for(const e of Lt(n)?n:[...n])(e!==ki||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const Py=ic("__proto__,__v_isRef,__isVue"),Pd=new Set(Object.getOwnPropertyNames(Symbol).map(n=>Symbol[n]).filter(lc)),Dy=_c(),Iy=_c(!1,!0),Fy=_c(!0),Dd=Oy();function Oy(){const n={};return["includes","indexOf","lastIndexOf"].forEach(t=>{n[t]=function(...e){const i=jt(this);for(let r=0,o=this.length;r<o;r++)Xe(i,"get",r+"");const s=i[t](...e);return s===-1||s===!1?i[t](...e.map(jt)):s}}),["push","pop","shift","unshift","splice"].forEach(t=>{n[t]=function(...e){bs();const i=jt(this)[t].apply(this,e);return zi(),i}}),n}function _c(n=!1,t=!1){return function(i,s,r){if(s==="__v_isReactive")return!n;if(s==="__v_isReadonly")return n;if(s==="__v_raw"&&r===(n?t?Jy:Ud:t?Hd:Bd).get(i))return i;const o=Lt(i);if(!n&&o&&Vt(Dd,s))return Reflect.get(Dd,s,r);const a=Reflect.get(i,s,r);return(lc(s)?Pd.has(s):Py(s))||(n||Xe(i,"get",s),t)?a:Ne(a)?!o||!cc(s)?a.value:a:de(a)?n?Vd(a):Ms(a):a}}const ky=Id(),Ny=Id(!0);function Id(n=!1){return function(e,i,s,r){let o=e[i];if(!n&&!Mc(s)&&(s=jt(s),o=jt(o),!Lt(e)&&Ne(o)&&!Ne(s)))return o.value=s,!0;const a=Lt(e)&&cc(i)?Number(i)<e.length:Vt(e,i),l=Reflect.set(e,i,s,r);return e===jt(r)&&(a?Cr(s,o)&&Hn(e,"set",i,s):Hn(e,"add",i,s)),l}}function zy(n,t){const e=Vt(n,t);n[t];const i=Reflect.deleteProperty(n,t);return i&&e&&Hn(n,"delete",t,void 0),i}function By(n,t){const e=Reflect.has(n,t);return(!lc(t)||!Pd.has(t))&&Xe(n,"has",t),e}function Hy(n){return Xe(n,"iterate",Lt(n)?"length":Ni),Reflect.ownKeys(n)}const Fd={get:Dy,set:ky,deleteProperty:zy,has:By,ownKeys:Hy},Uy={get:Fy,set(n,t){return!0},deleteProperty(n,t){return!0}},Vy=ke({},Fd,{get:Iy,set:Ny}),yc=n=>n,ia=n=>Reflect.getPrototypeOf(n);function sa(n,t,e=!1,i=!1){n=n.__v_raw;const s=jt(n),r=jt(t);t!==r&&!e&&Xe(s,"get",t),!e&&Xe(s,"get",r);const{has:o}=ia(s),a=i?yc:e?wc:Pr;if(o.call(s,t))return a(n.get(t));if(o.call(s,r))return a(n.get(r));n!==s&&n.get(t)}function ra(n,t=!1){const e=this.__v_raw,i=jt(e),s=jt(n);return n!==s&&!t&&Xe(i,"has",n),!t&&Xe(i,"has",s),n===s?e.has(n):e.has(n)||e.has(s)}function oa(n,t=!1){return n=n.__v_raw,!t&&Xe(jt(n),"iterate",Ni),Reflect.get(n,"size",n)}function Od(n){n=jt(n);const t=jt(this);return ia(t).has.call(t,n)||(t.add(n),Hn(t,"add",n,n)),this}function kd(n,t){t=jt(t);const e=jt(this),{has:i,get:s}=ia(e);let r=i.call(e,n);r||(n=jt(n),r=i.call(e,n));const o=s.call(e,n);return e.set(n,t),r?Cr(t,o)&&Hn(e,"set",n,t):Hn(e,"add",n,t),this}function Nd(n){const t=jt(this),{has:e,get:i}=ia(t);let s=e.call(t,n);s||(n=jt(n),s=e.call(t,n)),i&&i.call(t,n);const r=t.delete(n);return s&&Hn(t,"delete",n,void 0),r}function zd(){const n=jt(this),t=n.size!==0,e=n.clear();return t&&Hn(n,"clear",void 0,void 0),e}function aa(n,t){return function(i,s){const r=this,o=r.__v_raw,a=jt(o),l=t?yc:n?wc:Pr;return!n&&Xe(a,"iterate",Ni),o.forEach((c,h)=>i.call(s,l(c),l(h),r))}}function la(n,t,e){return function(...i){const s=this.__v_raw,r=jt(s),o=_s(r),a=n==="entries"||n===Symbol.iterator&&o,l=n==="keys"&&o,c=s[n](...i),h=e?yc:t?wc:Pr;return!t&&Xe(r,"iterate",l?pc:Ni),{next(){const{value:u,done:d}=c.next();return d?{value:u,done:d}:{value:a?[h(u[0]),h(u[1])]:h(u),done:d}},[Symbol.iterator](){return this}}}}function ii(n){return function(...t){return n==="delete"?!1:this}}function Wy(){const n={get(r){return sa(this,r)},get size(){return oa(this)},has:ra,add:Od,set:kd,delete:Nd,clear:zd,forEach:aa(!1,!1)},t={get(r){return sa(this,r,!1,!0)},get size(){return oa(this)},has:ra,add:Od,set:kd,delete:Nd,clear:zd,forEach:aa(!1,!0)},e={get(r){return sa(this,r,!0)},get size(){return oa(this,!0)},has(r){return ra.call(this,r,!0)},add:ii("add"),set:ii("set"),delete:ii("delete"),clear:ii("clear"),forEach:aa(!0,!1)},i={get(r){return sa(this,r,!0,!0)},get size(){return oa(this,!0)},has(r){return ra.call(this,r,!0)},add:ii("add"),set:ii("set"),delete:ii("delete"),clear:ii("clear"),forEach:aa(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=la(r,!1,!1),e[r]=la(r,!0,!1),t[r]=la(r,!1,!0),i[r]=la(r,!0,!0)}),[n,e,t,i]}const[Gy,jy,qy,Xy]=Wy();function vc(n,t){const e=t?n?Xy:qy:n?jy:Gy;return(i,s,r)=>s==="__v_isReactive"?!n:s==="__v_isReadonly"?n:s==="__v_raw"?i:Reflect.get(Vt(e,s)&&s in i?e:i,s,r)}const $y={get:vc(!1,!1)},Yy={get:vc(!1,!0)},Zy={get:vc(!0,!1)},Bd=new WeakMap,Hd=new WeakMap,Ud=new WeakMap,Jy=new WeakMap;function Ky(n){switch(n){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Qy(n){return n.__v_skip||!Object.isExtensible(n)?0:Ky(My(n))}function Ms(n){return n&&n.__v_isReadonly?n:bc(n,!1,Fd,$y,Bd)}function t0(n){return bc(n,!1,Vy,Yy,Hd)}function Vd(n){return bc(n,!0,Uy,Zy,Ud)}function bc(n,t,e,i,s){if(!de(n)||n.__v_raw&&!(t&&n.__v_isReactive))return n;const r=s.get(n);if(r)return r;const o=Qy(n);if(o===0)return n;const a=new Proxy(n,o===2?i:e);return s.set(n,a),a}function ws(n){return Mc(n)?ws(n.__v_raw):!!(n&&n.__v_isReactive)}function Mc(n){return!!(n&&n.__v_isReadonly)}function Wd(n){return ws(n)||Mc(n)}function jt(n){const t=n&&n.__v_raw;return t?jt(t):n}function Gd(n){return ta(n,"__v_skip",!0),n}const Pr=n=>de(n)?Ms(n):n,wc=n=>de(n)?Vd(n):n;function jd(n){Ld()&&(n=jt(n),n.dep||(n.dep=uc()),Rd(n.dep))}function qd(n,t){n=jt(n),n.dep&&xc(n.dep)}function Ne(n){return Boolean(n&&n.__v_isRef===!0)}function e0(n){return Xd(n,!1)}function n0(n){return Xd(n,!0)}function Xd(n,t){return Ne(n)?n:new i0(n,t)}class i0{constructor(t,e){this._shallow=e,this.dep=void 0,this.__v_isRef=!0,this._rawValue=e?t:jt(t),this._value=e?t:Pr(t)}get value(){return jd(this),this._value}set value(t){t=this._shallow?t:jt(t),Cr(t,this._rawValue)&&(this._rawValue=t,this._value=this._shallow?t:Pr(t),qd(this))}}function Dr(n){return Ne(n)?n.value:n}const s0={get:(n,t,e)=>Dr(Reflect.get(n,t,e)),set:(n,t,e,i)=>{const s=n[t];return Ne(s)&&!Ne(e)?(s.value=e,!0):Reflect.set(n,t,e,i)}};function $d(n){return ws(n)?n:new Proxy(n,s0)}class r0{constructor(t,e,i){this._setter=e,this.dep=void 0,this._dirty=!0,this.__v_isRef=!0,this.effect=new mc(t,()=>{this._dirty||(this._dirty=!0,qd(this))}),this.__v_isReadonly=i}get value(){const t=jt(this);return jd(t),t._dirty&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}function Cn(n,t){let e,i;const s=Ft(n);return s?(e=n,i=un):(e=n.get,i=n.set),new r0(e,i,s||!i)}Promise.resolve();function o0(n,t,...e){const i=n.vnode.props||te;let s=e;const r=t.startsWith("update:"),o=r&&t.slice(7);if(o&&o in i){const h=`${o==="modelValue"?"model":o}Modifiers`,{number:u,trim:d}=i[h]||te;d?s=e.map(f=>f.trim()):u&&(s=e.map(ea))}let a,l=i[a=hc(t)]||i[a=hc(An(t))];!l&&r&&(l=i[a=hc(ys(t))]),l&&fn(l,n,6,s);const c=i[a+"Once"];if(c){if(!n.emitted)n.emitted={};else if(n.emitted[a])return;n.emitted[a]=!0,fn(c,n,6,s)}}function Yd(n,t,e=!1){const i=t.emitsCache,s=i.get(n);if(s!==void 0)return s;const r=n.emits;let o={},a=!1;if(!Ft(n)){const l=c=>{const h=Yd(c,t,!0);h&&(a=!0,ke(o,h))};!e&&t.mixins.length&&t.mixins.forEach(l),n.extends&&l(n.extends),n.mixins&&n.mixins.forEach(l)}return!r&&!a?(i.set(n,null),null):(Lt(r)?r.forEach(l=>o[l]=null):ke(o,r),i.set(n,o),o)}function Sc(n,t){return!n||!Xo(t)?!1:(t=t.slice(2).replace(/Once$/,""),Vt(n,t[0].toLowerCase()+t.slice(1))||Vt(n,ys(t))||Vt(n,t))}let dn=null,ca=null;function ha(n){const t=dn;return dn=n,ca=n&&n.type.__scopeId||null,t}function b3(n){ca=n}function M3(){ca=null}function a0(n,t=dn,e){if(!t||n._n)return n;const i=(...s)=>{i._d&&yf(-1);const r=ha(t),o=n(...s);return ha(r),i._d&&yf(1),o};return i._n=!0,i._c=!0,i._d=!0,i}function Ec(n){const{type:t,vnode:e,proxy:i,withProxy:s,props:r,propsOptions:[o],slots:a,attrs:l,emit:c,render:h,renderCache:u,data:d,setupState:f,ctx:p,inheritAttrs:x}=n;let _,m;const g=ha(n);try{if(e.shapeFlag&4){const v=s||i;_=Ln(h.call(v,v,u,r,f,d,p)),m=l}else{const v=t;_=Ln(v.length>1?v(r,{attrs:l,slots:a,emit:c}):v(r,null)),m=t.props?l:l0(l)}}catch(v){Ir.length=0,ya(v,n,1),_=$e(Vi)}let S=_;if(m&&x!==!1){const v=Object.keys(m),{shapeFlag:E}=S;v.length&&E&(1|6)&&(o&&v.some(oc)&&(m=c0(m,o)),S=Or(S,m))}return e.dirs&&(S.dirs=S.dirs?S.dirs.concat(e.dirs):e.dirs),e.transition&&(S.transition=e.transition),_=S,ha(g),_}const l0=n=>{let t;for(const e in n)(e==="class"||e==="style"||Xo(e))&&((t||(t={}))[e]=n[e]);return t},c0=(n,t)=>{const e={};for(const i in n)(!oc(i)||!(i.slice(9)in t))&&(e[i]=n[i]);return e};function h0(n,t,e){const{props:i,children:s,component:r}=n,{props:o,children:a,patchFlag:l}=t,c=r.emitsOptions;if(t.dirs||t.transition)return!0;if(e&&l>=0){if(l&1024)return!0;if(l&16)return i?Zd(i,o,c):!!o;if(l&8){const h=t.dynamicProps;for(let u=0;u<h.length;u++){const d=h[u];if(o[d]!==i[d]&&!Sc(c,d))return!0}}}else return(s||a)&&(!a||!a.$stable)?!0:i===o?!1:i?o?Zd(i,o,c):!0:!!o;return!1}function Zd(n,t,e){const i=Object.keys(t);if(i.length!==Object.keys(n).length)return!0;for(let s=0;s<i.length;s++){const r=i[s];if(t[r]!==n[r]&&!Sc(e,r))return!0}return!1}function u0({vnode:n,parent:t},e){for(;t&&t.subTree===n;)(n=t.vnode).el=e,t=t.parent}const d0=n=>n.__isSuspense;function f0(n,t){t&&t.pendingBranch?Lt(n)?t.effects.push(...n):t.effects.push(n):uv(n)}function ua(n,t){if(Te){let e=Te.provides;const i=Te.parent&&Te.parent.provides;i===e&&(e=Te.provides=Object.create(i)),e[n]=t}}function si(n,t,e=!1){const i=Te||dn;if(i){const s=i.parent==null?i.vnode.appContext&&i.vnode.appContext.provides:i.parent.provides;if(s&&n in s)return s[n];if(arguments.length>1)return e&&Ft(t)?t.call(i.proxy):t}}function Jd(n){return Ft(n)?{setup:n,name:n.name}:n}const Tc=n=>!!n.type.__asyncLoader,Kd=n=>n.type.__isKeepAlive;function p0(n,t){Qd(n,"a",t)}function m0(n,t){Qd(n,"da",t)}function Qd(n,t,e=Te){const i=n.__wdc||(n.__wdc=()=>{let s=e;for(;s;){if(s.isDeactivated)return;s=s.parent}return n()});if(da(t,i,e),e){let s=e.parent;for(;s&&s.parent;)Kd(s.parent.vnode)&&g0(i,t,e,s),s=s.parent}}function g0(n,t,e,i){const s=da(t,n,i,!0);tf(()=>{ac(i[t],s)},e)}function da(n,t,e=Te,i=!1){if(e){const s=e[n]||(e[n]=[]),r=t.__weh||(t.__weh=(...o)=>{if(e.isUnmounted)return;bs(),Ss(e);const a=fn(t,e,n,o);return Gi(),zi(),a});return i?s.unshift(r):s.push(r),r}}const Un=n=>(t,e=Te)=>(!_a||n==="sp")&&da(n,t,e),x0=Un("bm"),_0=Un("m"),y0=Un("bu"),v0=Un("u"),b0=Un("bum"),tf=Un("um"),M0=Un("sp"),w0=Un("rtg"),S0=Un("rtc");function E0(n,t=Te){da("ec",n,t)}let Ac=!0;function T0(n){const t=sf(n),e=n.proxy,i=n.ctx;Ac=!1,t.beforeCreate&&ef(t.beforeCreate,n,"bc");const{data:s,computed:r,methods:o,watch:a,provide:l,inject:c,created:h,beforeMount:u,mounted:d,beforeUpdate:f,updated:p,activated:x,deactivated:_,beforeDestroy:m,beforeUnmount:g,destroyed:S,unmounted:v,render:E,renderTracked:R,renderTriggered:D,errorCaptured:$,serverPrefetch:it,expose:tt,inheritAttrs:N,components:T,directives:A,filters:W}=t;if(c&&A0(c,i,null,n.appContext.config.unwrapInjectedRef),o)for(const U in o){const ct=o[U];Ft(ct)&&(i[U]=ct.bind(e))}if(s){const U=s.call(e,e);de(U)&&(n.data=Ms(U))}if(Ac=!0,r)for(const U in r){const ct=r[U],xt=Ft(ct)?ct.bind(e,e):Ft(ct.get)?ct.get.bind(e,e):un,et=!Ft(ct)&&Ft(ct.set)?ct.set.bind(e):un,ot=Cn({get:xt,set:et});Object.defineProperty(i,U,{enumerable:!0,configurable:!0,get:()=>ot.value,set:yt=>ot.value=yt})}if(a)for(const U in a)nf(a[U],i,e,U);if(l){const U=Ft(l)?l.call(e):l;Reflect.ownKeys(U).forEach(ct=>{ua(ct,U[ct])})}h&&ef(h,n,"c");function k(U,ct){Lt(ct)?ct.forEach(xt=>U(xt.bind(e))):ct&&U(ct.bind(e))}if(k(x0,u),k(_0,d),k(y0,f),k(v0,p),k(p0,x),k(m0,_),k(E0,$),k(S0,R),k(w0,D),k(b0,g),k(tf,v),k(M0,it),Lt(tt))if(tt.length){const U=n.exposed||(n.exposed={});tt.forEach(ct=>{Object.defineProperty(U,ct,{get:()=>e[ct],set:xt=>e[ct]=xt})})}else n.exposed||(n.exposed={});E&&n.render===un&&(n.render=E),N!=null&&(n.inheritAttrs=N),T&&(n.components=T),A&&(n.directives=A)}function A0(n,t,e=un,i=!1){Lt(n)&&(n=Cc(n));for(const s in n){const r=n[s];let o;de(r)?"default"in r?o=si(r.from||s,r.default,!0):o=si(r.from||s):o=si(r),Ne(o)&&i?Object.defineProperty(t,s,{enumerable:!0,configurable:!0,get:()=>o.value,set:a=>o.value=a}):t[s]=o}}function ef(n,t,e){fn(Lt(n)?n.map(i=>i.bind(t.proxy)):n.bind(t.proxy),t,e)}function nf(n,t,e,i){const s=i.includes(".")?kf(e,i):()=>e[i];if(Ee(n)){const r=t[n];Ft(r)&&As(s,r)}else if(Ft(n))As(s,n.bind(e));else if(de(n))if(Lt(n))n.forEach(r=>nf(r,t,e,i));else{const r=Ft(n.handler)?n.handler.bind(e):t[n.handler];Ft(r)&&As(s,r,n)}}function sf(n){const t=n.type,{mixins:e,extends:i}=t,{mixins:s,optionsCache:r,config:{optionMergeStrategies:o}}=n.appContext,a=r.get(t);let l;return a?l=a:!s.length&&!e&&!i?l=t:(l={},s.length&&s.forEach(c=>fa(l,c,o,!0)),fa(l,t,o)),r.set(t,l),l}function fa(n,t,e,i=!1){const{mixins:s,extends:r}=t;r&&fa(n,r,e,!0),s&&s.forEach(o=>fa(n,o,e,!0));for(const o in t)if(!(i&&o==="expose")){const a=C0[o]||e&&e[o];n[o]=a?a(n[o],t[o]):t[o]}return n}const C0={data:rf,props:Bi,emits:Bi,methods:Bi,computed:Bi,beforeCreate:ze,created:ze,beforeMount:ze,mounted:ze,beforeUpdate:ze,updated:ze,beforeDestroy:ze,beforeUnmount:ze,destroyed:ze,unmounted:ze,activated:ze,deactivated:ze,errorCaptured:ze,serverPrefetch:ze,components:Bi,directives:Bi,watch:R0,provide:rf,inject:L0};function rf(n,t){return t?n?function(){return ke(Ft(n)?n.call(this,this):n,Ft(t)?t.call(this,this):t)}:t:n}function L0(n,t){return Bi(Cc(n),Cc(t))}function Cc(n){if(Lt(n)){const t={};for(let e=0;e<n.length;e++)t[n[e]]=n[e];return t}return n}function ze(n,t){return n?[...new Set([].concat(n,t))]:t}function Bi(n,t){return n?ke(ke(Object.create(null),n),t):t}function R0(n,t){if(!n)return t;if(!t)return n;const e=ke(Object.create(null),n);for(const i in t)e[i]=ze(n[i],t[i]);return e}function P0(n,t,e,i=!1){const s={},r={};ta(r,ma,1),n.propsDefaults=Object.create(null),of(n,t,s,r);for(const o in n.propsOptions[0])o in s||(s[o]=void 0);e?n.props=i?s:t0(s):n.type.props?n.props=s:n.props=r,n.attrs=r}function D0(n,t,e,i){const{props:s,attrs:r,vnode:{patchFlag:o}}=n,a=jt(s),[l]=n.propsOptions;let c=!1;if((i||o>0)&&!(o&16)){if(o&8){const h=n.vnode.dynamicProps;for(let u=0;u<h.length;u++){let d=h[u];const f=t[d];if(l)if(Vt(r,d))f!==r[d]&&(r[d]=f,c=!0);else{const p=An(d);s[p]=Lc(l,a,p,f,n,!1)}else f!==r[d]&&(r[d]=f,c=!0)}}}else{of(n,t,s,r)&&(c=!0);let h;for(const u in a)(!t||!Vt(t,u)&&((h=ys(u))===u||!Vt(t,h)))&&(l?e&&(e[u]!==void 0||e[h]!==void 0)&&(s[u]=Lc(l,a,u,void 0,n,!0)):delete s[u]);if(r!==a)for(const u in r)(!t||!Vt(t,u))&&(delete r[u],c=!0)}c&&Hn(n,"set","$attrs")}function of(n,t,e,i){const[s,r]=n.propsOptions;let o=!1,a;if(t)for(let l in t){if(Zo(l))continue;const c=t[l];let h;s&&Vt(s,h=An(l))?!r||!r.includes(h)?e[h]=c:(a||(a={}))[h]=c:Sc(n.emitsOptions,l)||(!(l in i)||c!==i[l])&&(i[l]=c,o=!0)}if(r){const l=jt(e),c=a||te;for(let h=0;h<r.length;h++){const u=r[h];e[u]=Lc(s,l,u,c[u],n,!Vt(c,u))}}return o}function Lc(n,t,e,i,s,r){const o=n[e];if(o!=null){const a=Vt(o,"default");if(a&&i===void 0){const l=o.default;if(o.type!==Function&&Ft(l)){const{propsDefaults:c}=s;e in c?i=c[e]:(Ss(s),i=c[e]=l.call(null,t),Gi())}else i=l}o[0]&&(r&&!a?i=!1:o[1]&&(i===""||i===ys(e))&&(i=!0))}return i}function af(n,t,e=!1){const i=t.propsCache,s=i.get(n);if(s)return s;const r=n.props,o={},a=[];let l=!1;if(!Ft(n)){const h=u=>{l=!0;const[d,f]=af(u,t,!0);ke(o,d),f&&a.push(...f)};!e&&t.mixins.length&&t.mixins.forEach(h),n.extends&&h(n.extends),n.mixins&&n.mixins.forEach(h)}if(!r&&!l)return i.set(n,xs),xs;if(Lt(r))for(let h=0;h<r.length;h++){const u=An(r[h]);lf(u)&&(o[u]=te)}else if(r)for(const h in r){const u=An(h);if(lf(u)){const d=r[h],f=o[u]=Lt(d)||Ft(d)?{type:d}:d;if(f){const p=uf(Boolean,f.type),x=uf(String,f.type);f[0]=p>-1,f[1]=x<0||p<x,(p>-1||Vt(f,"default"))&&a.push(u)}}}const c=[o,a];return i.set(n,c),c}function lf(n){return n[0]!=="$"}function cf(n){const t=n&&n.toString().match(/^\s*function (\w+)/);return t?t[1]:n===null?"null":""}function hf(n,t){return cf(n)===cf(t)}function uf(n,t){return Lt(t)?t.findIndex(e=>hf(e,n)):Ft(t)&&hf(t,n)?0:-1}const df=n=>n[0]==="_"||n==="$stable",Rc=n=>Lt(n)?n.map(Ln):[Ln(n)],I0=(n,t,e)=>{const i=a0((...s)=>Rc(t(...s)),e);return i._c=!1,i},ff=(n,t,e)=>{const i=n._ctx;for(const s in n){if(df(s))continue;const r=n[s];if(Ft(r))t[s]=I0(s,r,i);else if(r!=null){const o=Rc(r);t[s]=()=>o}}},pf=(n,t)=>{const e=Rc(t);n.slots.default=()=>e},F0=(n,t)=>{if(n.vnode.shapeFlag&32){const e=t._;e?(n.slots=jt(t),ta(t,"_",e)):ff(t,n.slots={})}else n.slots={},t&&pf(n,t);ta(n.slots,ma,1)},O0=(n,t,e)=>{const{vnode:i,slots:s}=n;let r=!0,o=te;if(i.shapeFlag&32){const a=t._;a?e&&a===1?r=!1:(ke(s,t),!e&&a===1&&delete s._):(r=!t.$stable,ff(t,s)),o=t}else t&&(pf(n,t),o={default:1});if(r)for(const a in s)!df(a)&&!(a in o)&&delete s[a]};function w3(n,t){const e=dn;if(e===null)return n;const i=e.proxy,s=n.dirs||(n.dirs=[]);for(let r=0;r<t.length;r++){let[o,a,l,c=te]=t[r];Ft(o)&&(o={mounted:o,updated:o}),o.deep&&ji(a),s.push({dir:o,instance:i,value:a,oldValue:void 0,arg:l,modifiers:c})}return n}function Hi(n,t,e,i){const s=n.dirs,r=t&&t.dirs;for(let o=0;o<s.length;o++){const a=s[o];r&&(a.oldValue=r[o].value);let l=a.dir[i];l&&(bs(),fn(l,e,8,[n.el,a,n,t]),zi())}}function mf(){return{app:null,config:{isNativeTag:yy,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let k0=0;function N0(n,t){return function(i,s=null){s!=null&&!de(s)&&(s=null);const r=mf(),o=new Set;let a=!1;const l=r.app={_uid:k0++,_component:i,_props:s,_container:null,_context:r,_instance:null,version:fv,get config(){return r.config},set config(c){},use(c,...h){return o.has(c)||(c&&Ft(c.install)?(o.add(c),c.install(l,...h)):Ft(c)&&(o.add(c),c(l,...h))),l},mixin(c){return r.mixins.includes(c)||r.mixins.push(c),l},component(c,h){return h?(r.components[c]=h,l):r.components[c]},directive(c,h){return h?(r.directives[c]=h,l):r.directives[c]},mount(c,h,u){if(!a){const d=$e(i,s);return d.appContext=r,h&&t?t(d,c):n(d,c,u),a=!0,l._container=c,c.__vue_app__=l,Nc(d.component)||d.component.proxy}},unmount(){a&&(n(null,l._container),delete l._container.__vue_app__)},provide(c,h){return r.provides[c]=h,l}};return l}}function Pc(n,t,e,i,s=!1){if(Lt(n)){n.forEach((d,f)=>Pc(d,t&&(Lt(t)?t[f]:t),e,i,s));return}if(Tc(i)&&!s)return;const r=i.shapeFlag&4?Nc(i.component)||i.component.proxy:i.el,o=s?null:r,{i:a,r:l}=n,c=t&&t.r,h=a.refs===te?a.refs={}:a.refs,u=a.setupState;if(c!=null&&c!==l&&(Ee(c)?(h[c]=null,Vt(u,c)&&(u[c]=null)):Ne(c)&&(c.value=null)),Ft(l))oi(l,a,12,[o,h]);else{const d=Ee(l),f=Ne(l);if(d||f){const p=()=>{if(n.f){const x=d?h[l]:l.value;s?Lt(x)&&ac(x,r):Lt(x)?x.includes(r)||x.push(r):d?h[l]=[r]:(l.value=[r],n.k&&(h[n.k]=l.value))}else d?(h[l]=o,Vt(u,l)&&(u[l]=o)):Ne(l)&&(l.value=o,n.k&&(h[n.k]=o))};o?(p.id=-1,Ve(p,e)):p()}}}const Ve=f0;function z0(n){return B0(n)}function B0(n,t){const e=Ey();e.__VUE__=!0;const{insert:i,remove:s,patchProp:r,createElement:o,createText:a,createComment:l,setText:c,setElementText:h,parentNode:u,nextSibling:d,setScopeId:f=un,cloneNode:p,insertStaticContent:x}=n,_=(b,w,L,F=null,G=null,Q=null,Y=!1,nt=null,M=!!w.dynamicChildren)=>{if(b===w)return;b&&!Fr(b,w)&&(F=H(b),gt(b,G,Q,!0),b=null),w.patchFlag===-2&&(M=!1,w.dynamicChildren=null);const{type:y,ref:O,shapeFlag:B}=w;switch(y){case Dc:m(b,w,L,F);break;case Vi:g(b,w,L,F);break;case Ic:b==null&&S(w,L,F,Y);break;case Vn:A(b,w,L,F,G,Q,Y,nt,M);break;default:B&1?R(b,w,L,F,G,Q,Y,nt,M):B&6?W(b,w,L,F,G,Q,Y,nt,M):(B&64||B&128)&&y.process(b,w,L,F,G,Q,Y,nt,M,K)}O!=null&&G&&Pc(O,b&&b.ref,Q,w||b,!w)},m=(b,w,L,F)=>{if(b==null)i(w.el=a(w.children),L,F);else{const G=w.el=b.el;w.children!==b.children&&c(G,w.children)}},g=(b,w,L,F)=>{b==null?i(w.el=l(w.children||""),L,F):w.el=b.el},S=(b,w,L,F)=>{[b.el,b.anchor]=x(b.children,w,L,F)},v=({el:b,anchor:w},L,F)=>{let G;for(;b&&b!==w;)G=d(b),i(b,L,F),b=G;i(w,L,F)},E=({el:b,anchor:w})=>{let L;for(;b&&b!==w;)L=d(b),s(b),b=L;s(w)},R=(b,w,L,F,G,Q,Y,nt,M)=>{Y=Y||w.type==="svg",b==null?D(w,L,F,G,Q,Y,nt,M):tt(b,w,G,Q,Y,nt,M)},D=(b,w,L,F,G,Q,Y,nt)=>{let M,y;const{type:O,props:B,shapeFlag:X,transition:q,patchFlag:_t,dirs:bt}=b;if(b.el&&p!==void 0&&_t===-1)M=b.el=p(b.el);else{if(M=b.el=o(b.type,Q,B&&B.is,B),X&8?h(M,b.children):X&16&&it(b.children,M,null,F,G,Q&&O!=="foreignObject",Y,nt),bt&&Hi(b,null,F,"created"),B){for(const P in B)P!=="value"&&!Zo(P)&&r(M,P,null,B[P],Q,b.children,F,G,ht);"value"in B&&r(M,"value",null,B.value),(y=B.onVnodeBeforeMount)&&Rn(y,F,b)}$(M,b,b.scopeId,Y,F)}bt&&Hi(b,null,F,"beforeMount");const ut=(!G||G&&!G.pendingBranch)&&q&&!q.persisted;ut&&q.beforeEnter(M),i(M,w,L),((y=B&&B.onVnodeMounted)||ut||bt)&&Ve(()=>{y&&Rn(y,F,b),ut&&q.enter(M),bt&&Hi(b,null,F,"mounted")},G)},$=(b,w,L,F,G)=>{if(L&&f(b,L),F)for(let Q=0;Q<F.length;Q++)f(b,F[Q]);if(G){let Q=G.subTree;if(w===Q){const Y=G.vnode;$(b,Y,Y.scopeId,Y.slotScopeIds,G.parent)}}},it=(b,w,L,F,G,Q,Y,nt,M=0)=>{for(let y=M;y<b.length;y++){const O=b[y]=nt?ri(b[y]):Ln(b[y]);_(null,O,w,L,F,G,Q,Y,nt)}},tt=(b,w,L,F,G,Q,Y)=>{const nt=w.el=b.el;let{patchFlag:M,dynamicChildren:y,dirs:O}=w;M|=b.patchFlag&16;const B=b.props||te,X=w.props||te;let q;L&&Ui(L,!1),(q=X.onVnodeBeforeUpdate)&&Rn(q,L,w,b),O&&Hi(w,b,L,"beforeUpdate"),L&&Ui(L,!0);const _t=G&&w.type!=="foreignObject";if(y?N(b.dynamicChildren,y,nt,L,F,_t,Q):Y||xt(b,w,nt,null,L,F,_t,Q,!1),M>0){if(M&16)T(nt,w,B,X,L,F,G);else if(M&2&&B.class!==X.class&&r(nt,"class",null,X.class,G),M&4&&r(nt,"style",B.style,X.style,G),M&8){const bt=w.dynamicProps;for(let ut=0;ut<bt.length;ut++){const P=bt[ut],pt=B[P],ft=X[P];(ft!==pt||P==="value")&&r(nt,P,pt,ft,G,b.children,L,F,ht)}}M&1&&b.children!==w.children&&h(nt,w.children)}else!Y&&y==null&&T(nt,w,B,X,L,F,G);((q=X.onVnodeUpdated)||O)&&Ve(()=>{q&&Rn(q,L,w,b),O&&Hi(w,b,L,"updated")},F)},N=(b,w,L,F,G,Q,Y)=>{for(let nt=0;nt<w.length;nt++){const M=b[nt],y=w[nt],O=M.el&&(M.type===Vn||!Fr(M,y)||M.shapeFlag&(6|64))?u(M.el):L;_(M,y,O,null,F,G,Q,Y,!0)}},T=(b,w,L,F,G,Q,Y)=>{if(L!==F){for(const nt in F){if(Zo(nt))continue;const M=F[nt],y=L[nt];M!==y&&nt!=="value"&&r(b,nt,y,M,Y,w.children,G,Q,ht)}if(L!==te)for(const nt in L)!Zo(nt)&&!(nt in F)&&r(b,nt,L[nt],null,Y,w.children,G,Q,ht);"value"in F&&r(b,"value",L.value,F.value)}},A=(b,w,L,F,G,Q,Y,nt,M)=>{const y=w.el=b?b.el:a(""),O=w.anchor=b?b.anchor:a("");let{patchFlag:B,dynamicChildren:X,slotScopeIds:q}=w;q&&(nt=nt?nt.concat(q):q),b==null?(i(y,L,F),i(O,L,F),it(w.children,L,O,G,Q,Y,nt,M)):B>0&&B&64&&X&&b.dynamicChildren?(N(b.dynamicChildren,X,L,G,Q,Y,nt),(w.key!=null||G&&w===G.subTree)&&gf(b,w,!0)):xt(b,w,L,O,G,Q,Y,nt,M)},W=(b,w,L,F,G,Q,Y,nt,M)=>{w.slotScopeIds=nt,b==null?w.shapeFlag&512?G.ctx.activate(w,L,F,Y,M):V(w,L,F,G,Q,Y,M):k(b,w,M)},V=(b,w,L,F,G,Q,Y)=>{const nt=b.component=tv(b,F,G);if(Kd(b)&&(nt.ctx.renderer=K),ev(nt),nt.asyncDep){if(G&&G.registerDep(nt,U),!b.el){const M=nt.subTree=$e(Vi);g(null,M,w,L)}return}U(nt,b,w,L,G,Q,Y)},k=(b,w,L)=>{const F=w.component=b.component;if(h0(b,w,L))if(F.asyncDep&&!F.asyncResolved){ct(F,w,L);return}else F.next=w,cv(F.update),F.update();else w.component=b.component,w.el=b.el,F.vnode=w},U=(b,w,L,F,G,Q,Y)=>{const nt=()=>{if(b.isMounted){let{next:O,bu:B,u:X,parent:q,vnode:_t}=b,bt=O,ut;Ui(b,!1),O?(O.el=_t.el,ct(b,O,Y)):O=_t,B&&Qo(B),(ut=O.props&&O.props.onVnodeBeforeUpdate)&&Rn(ut,q,O,_t),Ui(b,!0);const P=Ec(b),pt=b.subTree;b.subTree=P,_(pt,P,u(pt.el),H(pt),b,G,Q),O.el=P.el,bt===null&&u0(b,P.el),X&&Ve(X,G),(ut=O.props&&O.props.onVnodeUpdated)&&Ve(()=>Rn(ut,q,O,_t),G)}else{let O;const{el:B,props:X}=w,{bm:q,m:_t,parent:bt}=b,ut=Tc(w);if(Ui(b,!1),q&&Qo(q),!ut&&(O=X&&X.onVnodeBeforeMount)&&Rn(O,bt,w),Ui(b,!0),B&&z){const P=()=>{b.subTree=Ec(b),z(B,b.subTree,b,G,null)};ut?w.type.__asyncLoader().then(()=>!b.isUnmounted&&P()):P()}else{const P=b.subTree=Ec(b);_(null,P,L,F,b,G,Q),w.el=P.el}if(_t&&Ve(_t,G),!ut&&(O=X&&X.onVnodeMounted)){const P=w;Ve(()=>Rn(O,bt,P),G)}w.shapeFlag&256&&b.a&&Ve(b.a,G),b.isMounted=!0,w=L=F=null}},M=b.effect=new mc(nt,()=>Lf(b.update),b.scope),y=b.update=M.run.bind(M);y.id=b.uid,Ui(b,!0),y()},ct=(b,w,L)=>{w.component=b;const F=b.vnode.props;b.vnode=w,b.next=null,D0(b,w.props,F,L),O0(b,w.children,L),bs(),Uc(void 0,b.update),zi()},xt=(b,w,L,F,G,Q,Y,nt,M=!1)=>{const y=b&&b.children,O=b?b.shapeFlag:0,B=w.children,{patchFlag:X,shapeFlag:q}=w;if(X>0){if(X&128){ot(y,B,L,F,G,Q,Y,nt,M);return}else if(X&256){et(y,B,L,F,G,Q,Y,nt,M);return}}q&8?(O&16&&ht(y,G,Q),B!==y&&h(L,B)):O&16?q&16?ot(y,B,L,F,G,Q,Y,nt,M):ht(y,G,Q,!0):(O&8&&h(L,""),q&16&&it(B,L,F,G,Q,Y,nt,M))},et=(b,w,L,F,G,Q,Y,nt,M)=>{b=b||xs,w=w||xs;const y=b.length,O=w.length,B=Math.min(y,O);let X;for(X=0;X<B;X++){const q=w[X]=M?ri(w[X]):Ln(w[X]);_(b[X],q,L,null,G,Q,Y,nt,M)}y>O?ht(b,G,Q,!0,!1,B):it(w,L,F,G,Q,Y,nt,M,B)},ot=(b,w,L,F,G,Q,Y,nt,M)=>{let y=0;const O=w.length;let B=b.length-1,X=O-1;for(;y<=B&&y<=X;){const q=b[y],_t=w[y]=M?ri(w[y]):Ln(w[y]);if(Fr(q,_t))_(q,_t,L,null,G,Q,Y,nt,M);else break;y++}for(;y<=B&&y<=X;){const q=b[B],_t=w[X]=M?ri(w[X]):Ln(w[X]);if(Fr(q,_t))_(q,_t,L,null,G,Q,Y,nt,M);else break;B--,X--}if(y>B){if(y<=X){const q=X+1,_t=q<O?w[q].el:F;for(;y<=X;)_(null,w[y]=M?ri(w[y]):Ln(w[y]),L,_t,G,Q,Y,nt,M),y++}}else if(y>X)for(;y<=B;)gt(b[y],G,Q,!0),y++;else{const q=y,_t=y,bt=new Map;for(y=_t;y<=X;y++){const vt=w[y]=M?ri(w[y]):Ln(w[y]);vt.key!=null&&bt.set(vt.key,y)}let ut,P=0;const pt=X-_t+1;let ft=!1,At=0;const St=new Array(pt);for(y=0;y<pt;y++)St[y]=0;for(y=q;y<=B;y++){const vt=b[y];if(P>=pt){gt(vt,G,Q,!0);continue}let Ct;if(vt.key!=null)Ct=bt.get(vt.key);else for(ut=_t;ut<=X;ut++)if(St[ut-_t]===0&&Fr(vt,w[ut])){Ct=ut;break}Ct===void 0?gt(vt,G,Q,!0):(St[Ct-_t]=y+1,Ct>=At?At=Ct:ft=!0,_(vt,w[Ct],L,null,G,Q,Y,nt,M),P++)}const It=ft?H0(St):xs;for(ut=It.length-1,y=pt-1;y>=0;y--){const vt=_t+y,Ct=w[vt],Xt=vt+1<O?w[vt+1].el:F;St[y]===0?_(null,Ct,L,Xt,G,Q,Y,nt,M):ft&&(ut<0||y!==It[ut]?yt(Ct,L,Xt,2):ut--)}}},yt=(b,w,L,F,G=null)=>{const{el:Q,type:Y,transition:nt,children:M,shapeFlag:y}=b;if(y&6){yt(b.component.subTree,w,L,F);return}if(y&128){b.suspense.move(w,L,F);return}if(y&64){Y.move(b,w,L,K);return}if(Y===Vn){i(Q,w,L);for(let B=0;B<M.length;B++)yt(M[B],w,L,F);i(b.anchor,w,L);return}if(Y===Ic){v(b,w,L);return}if(F!==2&&y&1&&nt)if(F===0)nt.beforeEnter(Q),i(Q,w,L),Ve(()=>nt.enter(Q),G);else{const{leave:B,delayLeave:X,afterLeave:q}=nt,_t=()=>i(Q,w,L),bt=()=>{B(Q,()=>{_t(),q&&q()})};X?X(Q,_t,bt):bt()}else i(Q,w,L)},gt=(b,w,L,F=!1,G=!1)=>{const{type:Q,props:Y,ref:nt,children:M,dynamicChildren:y,shapeFlag:O,patchFlag:B,dirs:X}=b;if(nt!=null&&Pc(nt,null,L,b,!0),O&256){w.ctx.deactivate(b);return}const q=O&1&&X,_t=!Tc(b);let bt;if(_t&&(bt=Y&&Y.onVnodeBeforeUnmount)&&Rn(bt,w,b),O&6)j(b.component,L,F);else{if(O&128){b.suspense.unmount(L,F);return}q&&Hi(b,null,w,"beforeUnmount"),O&64?b.type.remove(b,w,L,G,K,F):y&&(Q!==Vn||B>0&&B&64)?ht(y,w,L,!1,!0):(Q===Vn&&B&(128|256)||!G&&O&16)&&ht(M,w,L),F&&wt(b)}(_t&&(bt=Y&&Y.onVnodeUnmounted)||q)&&Ve(()=>{bt&&Rn(bt,w,b),q&&Hi(b,null,w,"unmounted")},L)},wt=b=>{const{type:w,el:L,anchor:F,transition:G}=b;if(w===Vn){J(L,F);return}if(w===Ic){E(b);return}const Q=()=>{s(L),G&&!G.persisted&&G.afterLeave&&G.afterLeave()};if(b.shapeFlag&1&&G&&!G.persisted){const{leave:Y,delayLeave:nt}=G,M=()=>Y(L,Q);nt?nt(b.el,Q,M):M()}else Q()},J=(b,w)=>{let L;for(;b!==w;)L=d(b),s(b),b=L;s(w)},j=(b,w,L)=>{const{bum:F,scope:G,update:Q,subTree:Y,um:nt}=b;F&&Qo(F),G.stop(),Q&&(Q.active=!1,gt(Y,b,w,L)),nt&&Ve(nt,w),Ve(()=>{b.isUnmounted=!0},w),w&&w.pendingBranch&&!w.isUnmounted&&b.asyncDep&&!b.asyncResolved&&b.suspenseId===w.pendingId&&(w.deps--,w.deps===0&&w.resolve())},ht=(b,w,L,F=!1,G=!1,Q=0)=>{for(let Y=Q;Y<b.length;Y++)gt(b[Y],w,L,F,G)},H=b=>b.shapeFlag&6?H(b.component.subTree):b.shapeFlag&128?b.suspense.next():d(b.anchor||b.el),rt=(b,w,L)=>{b==null?w._vnode&&gt(w._vnode,null,null,!0):_(w._vnode||null,b,w,null,null,null,L),Df(),w._vnode=b},K={p:_,um:gt,m:yt,r:wt,mt:V,mc:it,pc:xt,pbc:N,n:H,o:n};let at,z;return t&&([at,z]=t(K)),{render:rt,hydrate:at,createApp:N0(rt,at)}}function Ui({effect:n,update:t},e){n.allowRecurse=t.allowRecurse=e}function gf(n,t,e=!1){const i=n.children,s=t.children;if(Lt(i)&&Lt(s))for(let r=0;r<i.length;r++){const o=i[r];let a=s[r];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=s[r]=ri(s[r]),a.el=o.el),e||gf(o,a))}}function H0(n){const t=n.slice(),e=[0];let i,s,r,o,a;const l=n.length;for(i=0;i<l;i++){const c=n[i];if(c!==0){if(s=e[e.length-1],n[s]<c){t[i]=s,e.push(i);continue}for(r=0,o=e.length-1;r<o;)a=r+o>>1,n[e[a]]<c?r=a+1:o=a;c<n[e[r]]&&(r>0&&(t[i]=e[r-1]),e[r]=i)}}for(r=e.length,o=e[r-1];r-- >0;)e[r]=o,o=t[o];return e}const U0=n=>n.__isTeleport,xf="components";function S3(n,t){return W0(xf,n,!0,t)||n}const V0=Symbol();function W0(n,t,e=!0,i=!1){const s=dn||Te;if(s){const r=s.type;if(n===xf){const a=rv(r);if(a&&(a===t||a===An(t)||a===Ko(An(t))))return r}const o=_f(s[n]||r[n],t)||_f(s.appContext[n],t);return!o&&i?r:o}}function _f(n,t){return n&&(n[t]||n[An(t)]||n[Ko(An(t))])}const Vn=Symbol(void 0),Dc=Symbol(void 0),Vi=Symbol(void 0),Ic=Symbol(void 0),Ir=[];let Wi=null;function G0(n=!1){Ir.push(Wi=n?null:[])}function j0(){Ir.pop(),Wi=Ir[Ir.length-1]||null}let pa=1;function yf(n){pa+=n}function vf(n){return n.dynamicChildren=pa>0?Wi||xs:null,j0(),pa>0&&Wi&&Wi.push(n),n}function E3(n,t,e,i,s,r){return vf(Mf(n,t,e,i,s,r,!0))}function q0(n,t,e,i,s){return vf($e(n,t,e,i,s,!0))}function Fc(n){return n?n.__v_isVNode===!0:!1}function Fr(n,t){return n.type===t.type&&n.key===t.key}const ma="__vInternal",bf=({key:n})=>n!=null?n:null,ga=({ref:n,ref_key:t,ref_for:e})=>n!=null?Ee(n)||Ne(n)||Ft(n)?{i:dn,r:n,k:t,f:!!e}:n:null;function Mf(n,t=null,e=null,i=0,s=null,r=n===Vn?0:1,o=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:n,props:t,key:t&&bf(t),ref:t&&ga(t),scopeId:ca,slotScopeIds:null,children:e,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:r,patchFlag:i,dynamicProps:s,dynamicChildren:null,appContext:null};return a?(Oc(l,e),r&128&&n.normalize(l)):e&&(l.shapeFlag|=Ee(e)?8:16),pa>0&&!o&&Wi&&(l.patchFlag>0||r&6)&&l.patchFlag!==32&&Wi.push(l),l}const $e=X0;function X0(n,t=null,e=null,i=0,s=null,r=!1){if((!n||n===V0)&&(n=Vi),Fc(n)){const a=Or(n,t,!0);return e&&Oc(a,e),a}if(ov(n)&&(n=n.__vccOpts),t){t=$0(t);let{class:a,style:l}=t;a&&!Ee(a)&&(t.class=rc(a)),de(l)&&(Wd(l)&&!Lt(l)&&(l=ke({},l)),t.style=sc(l))}const o=Ee(n)?1:d0(n)?128:U0(n)?64:de(n)?4:Ft(n)?2:0;return Mf(n,t,e,i,s,o,r,!0)}function $0(n){return n?Wd(n)||ma in n?ke({},n):n:null}function Or(n,t,e=!1){const{props:i,ref:s,patchFlag:r,children:o}=n,a=t?Z0(i||{},t):i;return{__v_isVNode:!0,__v_skip:!0,type:n.type,props:a,key:a&&bf(a),ref:t&&t.ref?e&&s?Lt(s)?s.concat(ga(t)):[s,ga(t)]:ga(t):s,scopeId:n.scopeId,slotScopeIds:n.slotScopeIds,children:o,target:n.target,targetAnchor:n.targetAnchor,staticCount:n.staticCount,shapeFlag:n.shapeFlag,patchFlag:t&&n.type!==Vn?r===-1?16:r|16:r,dynamicProps:n.dynamicProps,dynamicChildren:n.dynamicChildren,appContext:n.appContext,dirs:n.dirs,transition:n.transition,component:n.component,suspense:n.suspense,ssContent:n.ssContent&&Or(n.ssContent),ssFallback:n.ssFallback&&Or(n.ssFallback),el:n.el,anchor:n.anchor}}function Y0(n=" ",t=0){return $e(Dc,null,n,t)}function T3(n="",t=!1){return t?(G0(),q0(Vi,null,n)):$e(Vi,null,n)}function Ln(n){return n==null||typeof n=="boolean"?$e(Vi):Lt(n)?$e(Vn,null,n.slice()):typeof n=="object"?ri(n):$e(Dc,null,String(n))}function ri(n){return n.el===null||n.memo?n:Or(n)}function Oc(n,t){let e=0;const{shapeFlag:i}=n;if(t==null)t=null;else if(Lt(t))e=16;else if(typeof t=="object")if(i&(1|64)){const s=t.default;s&&(s._c&&(s._d=!1),Oc(n,s()),s._c&&(s._d=!0));return}else{e=32;const s=t._;!s&&!(ma in t)?t._ctx=dn:s===3&&dn&&(dn.slots._===1?t._=1:(t._=2,n.patchFlag|=1024))}else Ft(t)?(t={default:t,_ctx:dn},e=32):(t=String(t),i&64?(e=16,t=[Y0(t)]):e=8);n.children=t,n.shapeFlag|=e}function Z0(...n){const t={};for(let e=0;e<n.length;e++){const i=n[e];for(const s in i)if(s==="class")t.class!==i.class&&(t.class=rc([t.class,i.class]));else if(s==="style")t.style=sc([t.style,i.style]);else if(Xo(s)){const r=t[s],o=i[s];r!==o&&!(Lt(r)&&r.includes(o))&&(t[s]=r?[].concat(r,o):o)}else s!==""&&(t[s]=i[s])}return t}function Rn(n,t,e,i=null){fn(n,t,7,[e,i])}function A3(n,t,e,i){let s;const r=e&&e[i];if(Lt(n)||Ee(n)){s=new Array(n.length);for(let o=0,a=n.length;o<a;o++)s[o]=t(n[o],o,void 0,r&&r[o])}else if(typeof n=="number"){s=new Array(n);for(let o=0;o<n;o++)s[o]=t(o+1,o,void 0,r&&r[o])}else if(de(n))if(n[Symbol.iterator])s=Array.from(n,(o,a)=>t(o,a,void 0,r&&r[a]));else{const o=Object.keys(n);s=new Array(o.length);for(let a=0,l=o.length;a<l;a++){const c=o[a];s[a]=t(n[c],c,a,r&&r[a])}}else s=[];return e&&(e[i]=s),s}const kc=n=>n?wf(n)?Nc(n)||n.proxy:kc(n.parent):null,xa=ke(Object.create(null),{$:n=>n,$el:n=>n.vnode.el,$data:n=>n.data,$props:n=>n.props,$attrs:n=>n.attrs,$slots:n=>n.slots,$refs:n=>n.refs,$parent:n=>kc(n.parent),$root:n=>kc(n.root),$emit:n=>n.emit,$options:n=>sf(n),$forceUpdate:n=>()=>Lf(n.update),$nextTick:n=>Cf.bind(n.proxy),$watch:n=>dv.bind(n)}),J0={get({_:n},t){const{ctx:e,setupState:i,data:s,props:r,accessCache:o,type:a,appContext:l}=n;let c;if(t[0]!=="$"){const f=o[t];if(f!==void 0)switch(f){case 1:return i[t];case 2:return s[t];case 4:return e[t];case 3:return r[t]}else{if(i!==te&&Vt(i,t))return o[t]=1,i[t];if(s!==te&&Vt(s,t))return o[t]=2,s[t];if((c=n.propsOptions[0])&&Vt(c,t))return o[t]=3,r[t];if(e!==te&&Vt(e,t))return o[t]=4,e[t];Ac&&(o[t]=0)}}const h=xa[t];let u,d;if(h)return t==="$attrs"&&Xe(n,"get",t),h(n);if((u=a.__cssModules)&&(u=u[t]))return u;if(e!==te&&Vt(e,t))return o[t]=4,e[t];if(d=l.config.globalProperties,Vt(d,t))return d[t]},set({_:n},t,e){const{data:i,setupState:s,ctx:r}=n;if(s!==te&&Vt(s,t))s[t]=e;else if(i!==te&&Vt(i,t))i[t]=e;else if(Vt(n.props,t))return!1;return t[0]==="$"&&t.slice(1)in n?!1:(r[t]=e,!0)},has({_:{data:n,setupState:t,accessCache:e,ctx:i,appContext:s,propsOptions:r}},o){let a;return!!e[o]||n!==te&&Vt(n,o)||t!==te&&Vt(t,o)||(a=r[0])&&Vt(a,o)||Vt(i,o)||Vt(xa,o)||Vt(s.config.globalProperties,o)}},K0=mf();let Q0=0;function tv(n,t,e){const i=n.type,s=(t?t.appContext:n.appContext)||K0,r={uid:Q0++,vnode:n,type:i,parent:t,appContext:s,root:null,next:null,subTree:null,effect:null,update:null,scope:new Ty(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(s.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:af(i,s),emitsOptions:Yd(i,s),emit:null,emitted:null,propsDefaults:te,inheritAttrs:i.inheritAttrs,ctx:te,data:te,props:te,attrs:te,slots:te,refs:te,setupState:te,setupContext:null,suspense:e,suspenseId:e?e.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return r.ctx={_:r},r.root=t?t.root:r,r.emit=o0.bind(null,r),n.ce&&n.ce(r),r}let Te=null;const Ss=n=>{Te=n,n.scope.on()},Gi=()=>{Te&&Te.scope.off(),Te=null};function wf(n){return n.vnode.shapeFlag&4}let _a=!1;function ev(n,t=!1){_a=t;const{props:e,children:i}=n.vnode,s=wf(n);P0(n,e,s,t),F0(n,i);const r=s?nv(n,t):void 0;return _a=!1,r}function nv(n,t){const e=n.type;n.accessCache=Object.create(null),n.proxy=Gd(new Proxy(n.ctx,J0));const{setup:i}=e;if(i){const s=n.setupContext=i.length>1?sv(n):null;Ss(n),bs();const r=oi(i,n,0,[n.props,s]);if(zi(),Gi(),Md(r)){if(r.then(Gi,Gi),t)return r.then(o=>{Sf(n,o,t)}).catch(o=>{ya(o,n,0)});n.asyncDep=r}else Sf(n,r,t)}else Tf(n,t)}function Sf(n,t,e){Ft(t)?n.type.__ssrInlineRender?n.ssrRender=t:n.render=t:de(t)&&(n.setupState=$d(t)),Tf(n,e)}let Ef;function Tf(n,t,e){const i=n.type;if(!n.render){if(!t&&Ef&&!i.render){const s=i.template;if(s){const{isCustomElement:r,compilerOptions:o}=n.appContext.config,{delimiters:a,compilerOptions:l}=i,c=ke(ke({isCustomElement:r,delimiters:a},o),l);i.render=Ef(s,c)}}n.render=i.render||un}Ss(n),bs(),T0(n),zi(),Gi()}function iv(n){return new Proxy(n.attrs,{get(t,e){return Xe(n,"get","$attrs"),t[e]}})}function sv(n){const t=i=>{n.exposed=i||{}};let e;return{get attrs(){return e||(e=iv(n))},slots:n.slots,emit:n.emit,expose:t}}function Nc(n){if(n.exposed)return n.exposeProxy||(n.exposeProxy=new Proxy($d(Gd(n.exposed)),{get(t,e){if(e in t)return t[e];if(e in xa)return xa[e](n)}}))}function rv(n){return Ft(n)&&n.displayName||n.name}function ov(n){return Ft(n)&&"__vccOpts"in n}function oi(n,t,e,i){let s;try{s=i?n(...i):n()}catch(r){ya(r,t,e)}return s}function fn(n,t,e,i){if(Ft(n)){const r=oi(n,t,e,i);return r&&Md(r)&&r.catch(o=>{ya(o,t,e)}),r}const s=[];for(let r=0;r<n.length;r++)s.push(fn(n[r],t,e,i));return s}function ya(n,t,e,i=!0){const s=t?t.vnode:null;if(t){let r=t.parent;const o=t.proxy,a=e;for(;r;){const c=r.ec;if(c){for(let h=0;h<c.length;h++)if(c[h](n,o,a)===!1)return}r=r.parent}const l=t.appContext.config.errorHandler;if(l){oi(l,null,10,[n,o,a]);return}}av(n,e,s,i)}function av(n,t,e,i=!0){console.error(n)}let va=!1,zc=!1;const Ye=[];let Wn=0;const kr=[];let Nr=null,Es=0;const zr=[];let ai=null,Ts=0;const Af=Promise.resolve();let Bc=null,Hc=null;function Cf(n){const t=Bc||Af;return n?t.then(this?n.bind(this):n):t}function lv(n){let t=Wn+1,e=Ye.length;for(;t<e;){const i=t+e>>>1;Br(Ye[i])<n?t=i+1:e=i}return t}function Lf(n){(!Ye.length||!Ye.includes(n,va&&n.allowRecurse?Wn+1:Wn))&&n!==Hc&&(n.id==null?Ye.push(n):Ye.splice(lv(n.id),0,n),Rf())}function Rf(){!va&&!zc&&(zc=!0,Bc=Af.then(If))}function cv(n){const t=Ye.indexOf(n);t>Wn&&Ye.splice(t,1)}function Pf(n,t,e,i){Lt(n)?e.push(...n):(!t||!t.includes(n,n.allowRecurse?i+1:i))&&e.push(n),Rf()}function hv(n){Pf(n,Nr,kr,Es)}function uv(n){Pf(n,ai,zr,Ts)}function Uc(n,t=null){if(kr.length){for(Hc=t,Nr=[...new Set(kr)],kr.length=0,Es=0;Es<Nr.length;Es++)Nr[Es]();Nr=null,Es=0,Hc=null,Uc(n,t)}}function Df(n){if(zr.length){const t=[...new Set(zr)];if(zr.length=0,ai){ai.push(...t);return}for(ai=t,ai.sort((e,i)=>Br(e)-Br(i)),Ts=0;Ts<ai.length;Ts++)ai[Ts]();ai=null,Ts=0}}const Br=n=>n.id==null?1/0:n.id;function If(n){zc=!1,va=!0,Uc(n),Ye.sort((e,i)=>Br(e)-Br(i));const t=un;try{for(Wn=0;Wn<Ye.length;Wn++){const e=Ye[Wn];e&&e.active!==!1&&oi(e,null,14)}}finally{Wn=0,Ye.length=0,Df(),va=!1,Bc=null,(Ye.length||kr.length||zr.length)&&If(n)}}const Ff={};function As(n,t,e){return Of(n,t,e)}function Of(n,t,{immediate:e,deep:i,flush:s,onTrack:r,onTrigger:o}=te){const a=Te;let l,c=!1,h=!1;if(Ne(n)?(l=()=>n.value,c=!!n._shallow):ws(n)?(l=()=>n,i=!0):Lt(n)?(h=!0,c=n.some(ws),l=()=>n.map(m=>{if(Ne(m))return m.value;if(ws(m))return ji(m);if(Ft(m))return oi(m,a,2)})):Ft(n)?t?l=()=>oi(n,a,2):l=()=>{if(!(a&&a.isUnmounted))return u&&u(),fn(n,a,3,[d])}:l=un,t&&i){const m=l;l=()=>ji(m())}let u,d=m=>{u=_.onStop=()=>{oi(m,a,4)}};if(_a)return d=un,t?e&&fn(t,a,3,[l(),h?[]:void 0,d]):l(),un;let f=h?[]:Ff;const p=()=>{if(!!_.active)if(t){const m=_.run();(i||c||(h?m.some((g,S)=>Cr(g,f[S])):Cr(m,f)))&&(u&&u(),fn(t,a,3,[m,f===Ff?void 0:f,d]),f=m)}else _.run()};p.allowRecurse=!!t;let x;s==="sync"?x=p:s==="post"?x=()=>Ve(p,a&&a.suspense):x=()=>{!a||a.isMounted?hv(p):p()};const _=new mc(l,x);return t?e?p():f=_.run():s==="post"?Ve(_.run.bind(_),a&&a.suspense):_.run(),()=>{_.stop(),a&&a.scope&&ac(a.scope.effects,_)}}function dv(n,t,e){const i=this.proxy,s=Ee(n)?n.includes(".")?kf(i,n):()=>i[n]:n.bind(i,i);let r;Ft(t)?r=t:(r=t.handler,e=t);const o=Te;Ss(this);const a=Of(s,r.bind(i),e);return o?Ss(o):Gi(),a}function kf(n,t){const e=t.split(".");return()=>{let i=n;for(let s=0;s<e.length&&i;s++)i=i[e[s]];return i}}function ji(n,t){if(!de(n)||n.__v_skip||(t=t||new Set,t.has(n)))return n;if(t.add(n),Ne(n))ji(n.value,t);else if(Lt(n))for(let e=0;e<n.length;e++)ji(n[e],t);else if($o(n)||_s(n))n.forEach(e=>{ji(e,t)});else if(Sd(n))for(const e in n)ji(n[e],t);return n}function Nf(n,t,e){const i=arguments.length;return i===2?de(t)&&!Lt(t)?Fc(t)?$e(n,null,[t]):$e(n,t):$e(n,null,t):(i>3?e=Array.prototype.slice.call(arguments,2):i===3&&Fc(e)&&(e=[e]),$e(n,t,e))}const fv="3.2.26",pv="http://www.w3.org/2000/svg",Cs=typeof document!="undefined"?document:null,zf=new Map,mv={insert:(n,t,e)=>{t.insertBefore(n,e||null)},remove:n=>{const t=n.parentNode;t&&t.removeChild(n)},createElement:(n,t,e,i)=>{const s=t?Cs.createElementNS(pv,n):Cs.createElement(n,e?{is:e}:void 0);return n==="select"&&i&&i.multiple!=null&&s.setAttribute("multiple",i.multiple),s},createText:n=>Cs.createTextNode(n),createComment:n=>Cs.createComment(n),setText:(n,t)=>{n.nodeValue=t},setElementText:(n,t)=>{n.textContent=t},parentNode:n=>n.parentNode,nextSibling:n=>n.nextSibling,querySelector:n=>Cs.querySelector(n),setScopeId(n,t){n.setAttribute(t,"")},cloneNode(n){const t=n.cloneNode(!0);return"_value"in n&&(t._value=n._value),t},insertStaticContent(n,t,e,i){const s=e?e.previousSibling:t.lastChild;let r=zf.get(n);if(!r){const o=Cs.createElement("template");if(o.innerHTML=i?`<svg>${n}</svg>`:n,r=o.content,i){const a=r.firstChild;for(;a.firstChild;)r.appendChild(a.firstChild);r.removeChild(a)}zf.set(n,r)}return t.insertBefore(r.cloneNode(!0),e),[s?s.nextSibling:t.firstChild,e?e.previousSibling:t.lastChild]}};function gv(n,t,e){const i=n._vtc;i&&(t=(t?[t,...i]:[...i]).join(" ")),t==null?n.removeAttribute("class"):e?n.setAttribute("class",t):n.className=t}function xv(n,t,e){const i=n.style,s=Ee(e);if(e&&!s){for(const r in e)Vc(i,r,e[r]);if(t&&!Ee(t))for(const r in t)e[r]==null&&Vc(i,r,"")}else{const r=i.display;s?t!==e&&(i.cssText=e):t&&n.removeAttribute("style"),"_vod"in n&&(i.display=r)}}const Bf=/\s*!important$/;function Vc(n,t,e){if(Lt(e))e.forEach(i=>Vc(n,t,i));else if(t.startsWith("--"))n.setProperty(t,e);else{const i=_v(n,t);Bf.test(e)?n.setProperty(ys(i),e.replace(Bf,""),"important"):n[i]=e}}const Hf=["Webkit","Moz","ms"],Wc={};function _v(n,t){const e=Wc[t];if(e)return e;let i=An(t);if(i!=="filter"&&i in n)return Wc[t]=i;i=Ko(i);for(let s=0;s<Hf.length;s++){const r=Hf[s]+i;if(r in n)return Wc[t]=r}return t}const Uf="http://www.w3.org/1999/xlink";function yv(n,t,e,i,s){if(i&&t.startsWith("xlink:"))e==null?n.removeAttributeNS(Uf,t.slice(6,t.length)):n.setAttributeNS(Uf,t,e);else{const r=fy(t);e==null||r&&!yd(e)?n.removeAttribute(t):n.setAttribute(t,r?"":e)}}function vv(n,t,e,i,s,r,o){if(t==="innerHTML"||t==="textContent"){i&&o(i,s,r),n[t]=e==null?"":e;return}if(t==="value"&&n.tagName!=="PROGRESS"&&!n.tagName.includes("-")){n._value=e;const a=e==null?"":e;(n.value!==a||n.tagName==="OPTION")&&(n.value=a),e==null&&n.removeAttribute(t);return}if(e===""||e==null){const a=typeof n[t];if(a==="boolean"){n[t]=yd(e);return}else if(e==null&&a==="string"){n[t]="",n.removeAttribute(t);return}else if(a==="number"){try{n[t]=0}catch{}n.removeAttribute(t);return}}try{n[t]=e}catch{}}let ba=Date.now,Vf=!1;if(typeof window!="undefined"){ba()>document.createEvent("Event").timeStamp&&(ba=()=>performance.now());const n=navigator.userAgent.match(/firefox\/(\d+)/i);Vf=!!(n&&Number(n[1])<=53)}let Gc=0;const bv=Promise.resolve(),Mv=()=>{Gc=0},wv=()=>Gc||(bv.then(Mv),Gc=ba());function li(n,t,e,i){n.addEventListener(t,e,i)}function Sv(n,t,e,i){n.removeEventListener(t,e,i)}function Ev(n,t,e,i,s=null){const r=n._vei||(n._vei={}),o=r[t];if(i&&o)o.value=i;else{const[a,l]=Tv(t);if(i){const c=r[t]=Av(i,s);li(n,a,c,l)}else o&&(Sv(n,a,o,l),r[t]=void 0)}}const Wf=/(?:Once|Passive|Capture)$/;function Tv(n){let t;if(Wf.test(n)){t={};let e;for(;e=n.match(Wf);)n=n.slice(0,n.length-e[0].length),t[e[0].toLowerCase()]=!0}return[ys(n.slice(2)),t]}function Av(n,t){const e=i=>{const s=i.timeStamp||ba();(Vf||s>=e.attached-1)&&fn(Cv(i,e.value),t,5,[i])};return e.value=n,e.attached=wv(),e}function Cv(n,t){if(Lt(t)){const e=n.stopImmediatePropagation;return n.stopImmediatePropagation=()=>{e.call(n),n._stopped=!0},t.map(i=>s=>!s._stopped&&i(s))}else return t}const Gf=/^on[a-z]/,Lv=(n,t,e,i,s=!1,r,o,a,l)=>{t==="class"?gv(n,i,s):t==="style"?xv(n,e,i):Xo(t)?oc(t)||Ev(n,t,e,i,o):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):Rv(n,t,i,s))?vv(n,t,i,r,o,a,l):(t==="true-value"?n._trueValue=i:t==="false-value"&&(n._falseValue=i),yv(n,t,i,s))};function Rv(n,t,e,i){return i?!!(t==="innerHTML"||t==="textContent"||t in n&&Gf.test(t)&&Ft(e)):t==="spellcheck"||t==="draggable"||t==="form"||t==="list"&&n.tagName==="INPUT"||t==="type"&&n.tagName==="TEXTAREA"||Gf.test(t)&&Ee(e)?!1:t in n}const Ls=n=>{const t=n.props["onUpdate:modelValue"];return Lt(t)?e=>Qo(t,e):t};function Pv(n){n.target.composing=!0}function jf(n){const t=n.target;t.composing&&(t.composing=!1,Dv(t,"input"))}function Dv(n,t){const e=document.createEvent("HTMLEvents");e.initEvent(t,!0,!0),n.dispatchEvent(e)}const C3={created(n,{modifiers:{lazy:t,trim:e,number:i}},s){n._assign=Ls(s);const r=i||s.props&&s.props.type==="number";li(n,t?"change":"input",o=>{if(o.target.composing)return;let a=n.value;e?a=a.trim():r&&(a=ea(a)),n._assign(a)}),e&&li(n,"change",()=>{n.value=n.value.trim()}),t||(li(n,"compositionstart",Pv),li(n,"compositionend",jf),li(n,"change",jf))},mounted(n,{value:t}){n.value=t==null?"":t},beforeUpdate(n,{value:t,modifiers:{lazy:e,trim:i,number:s}},r){if(n._assign=Ls(r),n.composing||document.activeElement===n&&(e||i&&n.value.trim()===t||(s||n.type==="number")&&ea(n.value)===t))return;const o=t==null?"":t;n.value!==o&&(n.value=o)}},L3={created(n,{value:t},e){n.checked=gs(t,e.props.value),n._assign=Ls(e),li(n,"change",()=>{n._assign(Hr(n))})},beforeUpdate(n,{value:t,oldValue:e},i){n._assign=Ls(i),t!==e&&(n.checked=gs(t,i.props.value))}},R3={deep:!0,created(n,{value:t,modifiers:{number:e}},i){const s=$o(t);li(n,"change",()=>{const r=Array.prototype.filter.call(n.options,o=>o.selected).map(o=>e?ea(Hr(o)):Hr(o));n._assign(n.multiple?s?new Set(r):r:r[0])}),n._assign=Ls(i)},mounted(n,{value:t}){qf(n,t)},beforeUpdate(n,t,e){n._assign=Ls(e)},updated(n,{value:t}){qf(n,t)}};function qf(n,t){const e=n.multiple;if(!(e&&!Lt(t)&&!$o(t))){for(let i=0,s=n.options.length;i<s;i++){const r=n.options[i],o=Hr(r);if(e)Lt(t)?r.selected=_y(t,o)>-1:r.selected=t.has(o);else if(gs(Hr(r),t)){n.selectedIndex!==i&&(n.selectedIndex=i);return}}!e&&n.selectedIndex!==-1&&(n.selectedIndex=-1)}}function Hr(n){return"_value"in n?n._value:n.value}const Iv=["ctrl","shift","alt","meta"],Fv={stop:n=>n.stopPropagation(),prevent:n=>n.preventDefault(),self:n=>n.target!==n.currentTarget,ctrl:n=>!n.ctrlKey,shift:n=>!n.shiftKey,alt:n=>!n.altKey,meta:n=>!n.metaKey,left:n=>"button"in n&&n.button!==0,middle:n=>"button"in n&&n.button!==1,right:n=>"button"in n&&n.button!==2,exact:(n,t)=>Iv.some(e=>n[`${e}Key`]&&!t.includes(e))},P3=(n,t)=>(e,...i)=>{for(let s=0;s<t.length;s++){const r=Fv[t[s]];if(r&&r(e,t))return}return n(e,...i)},Ov=ke({patchProp:Lv},mv);let Xf;function kv(){return Xf||(Xf=z0(Ov))}const D3=(...n)=>{const t=kv().createApp(...n),{mount:e}=t;return t.mount=i=>{const s=Nv(i);if(!s)return;const r=t._component;!Ft(r)&&!r.render&&!r.template&&(r.template=s.innerHTML),s.innerHTML="";const o=e(s,!1,s instanceof SVGElement);return s instanceof Element&&(s.removeAttribute("v-cloak"),s.setAttribute("data-v-app","")),o},t};function Nv(n){return Ee(n)?document.querySelector(n):n}function zv(){return $f().__VUE_DEVTOOLS_GLOBAL_HOOK__}function $f(){return typeof navigator!="undefined"&&typeof window!="undefined"?window:typeof global!="undefined"?global:{}}const Bv=typeof Proxy=="function",Hv="devtools-plugin:setup",Uv="plugin:settings:set";class Vv{constructor(t,e){this.target=null,this.targetQueue=[],this.onQueue=[],this.plugin=t,this.hook=e;const i={};if(t.settings)for(const o in t.settings){const a=t.settings[o];i[o]=a.defaultValue}const s=`__vue-devtools-plugin-settings__${t.id}`;let r=Object.assign({},i);try{const o=localStorage.getItem(s),a=JSON.parse(o);Object.assign(r,a)}catch{}this.fallbacks={getSettings(){return r},setSettings(o){try{localStorage.setItem(s,JSON.stringify(o))}catch{}r=o}},e&&e.on(Uv,(o,a)=>{o===this.plugin.id&&this.fallbacks.setSettings(a)}),this.proxiedOn=new Proxy({},{get:(o,a)=>this.target?this.target.on[a]:(...l)=>{this.onQueue.push({method:a,args:l})}}),this.proxiedTarget=new Proxy({},{get:(o,a)=>this.target?this.target[a]:a==="on"?this.proxiedOn:Object.keys(this.fallbacks).includes(a)?(...l)=>(this.targetQueue.push({method:a,args:l,resolve:()=>{}}),this.fallbacks[a](...l)):(...l)=>new Promise(c=>{this.targetQueue.push({method:a,args:l,resolve:c})})})}async setRealTarget(t){this.target=t;for(const e of this.onQueue)this.target.on[e.method](...e.args);for(const e of this.targetQueue)e.resolve(await this.target[e.method](...e.args))}}function Wv(n,t){const e=$f(),i=zv(),s=Bv&&n.enableEarlyProxy;if(i&&(e.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__||!s))i.emit(Hv,n,t);else{const r=s?new Vv(n,i):null;(e.__VUE_DEVTOOLS_PLUGINS__=e.__VUE_DEVTOOLS_PLUGINS__||[]).push({pluginDescriptor:n,setupFn:t,proxy:r}),r&&t(r.proxiedTarget)}}/*!
  * vue-router v4.0.12
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */const Yf=typeof Symbol=="function"&&typeof Symbol.toStringTag=="symbol",Rs=n=>Yf?Symbol(n):"_vr_"+n,Gv=Rs("rvlm"),Zf=Rs("rvd"),jc=Rs("r"),Jf=Rs("rl"),qc=Rs("rvl"),Ps=typeof window!="undefined";function jv(n){return n.__esModule||Yf&&n[Symbol.toStringTag]==="Module"}const ee=Object.assign;function Xc(n,t){const e={};for(const i in t){const s=t[i];e[i]=Array.isArray(s)?s.map(n):n(s)}return e}const Ur=()=>{},qv=/\/$/,Xv=n=>n.replace(qv,"");function $c(n,t,e="/"){let i,s={},r="",o="";const a=t.indexOf("?"),l=t.indexOf("#",a>-1?a:0);return a>-1&&(i=t.slice(0,a),r=t.slice(a+1,l>-1?l:t.length),s=n(r)),l>-1&&(i=i||t.slice(0,l),o=t.slice(l,t.length)),i=Jv(i!=null?i:t,e),{fullPath:i+(r&&"?")+r+o,path:i,query:s,hash:o}}function $v(n,t){const e=t.query?n(t.query):"";return t.path+(e&&"?")+e+(t.hash||"")}function Kf(n,t){return!t||!n.toLowerCase().startsWith(t.toLowerCase())?n:n.slice(t.length)||"/"}function Yv(n,t,e){const i=t.matched.length-1,s=e.matched.length-1;return i>-1&&i===s&&Ds(t.matched[i],e.matched[s])&&Qf(t.params,e.params)&&n(t.query)===n(e.query)&&t.hash===e.hash}function Ds(n,t){return(n.aliasOf||n)===(t.aliasOf||t)}function Qf(n,t){if(Object.keys(n).length!==Object.keys(t).length)return!1;for(const e in n)if(!Zv(n[e],t[e]))return!1;return!0}function Zv(n,t){return Array.isArray(n)?tp(n,t):Array.isArray(t)?tp(t,n):n===t}function tp(n,t){return Array.isArray(t)?n.length===t.length&&n.every((e,i)=>e===t[i]):n.length===1&&n[0]===t}function Jv(n,t){if(n.startsWith("/"))return n;if(!n)return t;const e=t.split("/"),i=n.split("/");let s=e.length-1,r,o;for(r=0;r<i.length;r++)if(o=i[r],!(s===1||o==="."))if(o==="..")s--;else break;return e.slice(0,s).join("/")+"/"+i.slice(r-(r===i.length?1:0)).join("/")}var Vr;(function(n){n.pop="pop",n.push="push"})(Vr||(Vr={}));var Wr;(function(n){n.back="back",n.forward="forward",n.unknown=""})(Wr||(Wr={}));function Kv(n){if(!n)if(Ps){const t=document.querySelector("base");n=t&&t.getAttribute("href")||"/",n=n.replace(/^\w+:\/\/[^\/]+/,"")}else n="/";return n[0]!=="/"&&n[0]!=="#"&&(n="/"+n),Xv(n)}const Qv=/^[^#]+#/;function tb(n,t){return n.replace(Qv,"#")+t}function eb(n,t){const e=document.documentElement.getBoundingClientRect(),i=n.getBoundingClientRect();return{behavior:t.behavior,left:i.left-e.left-(t.left||0),top:i.top-e.top-(t.top||0)}}const Ma=()=>({left:window.pageXOffset,top:window.pageYOffset});function nb(n){let t;if("el"in n){const e=n.el,i=typeof e=="string"&&e.startsWith("#"),s=typeof e=="string"?i?document.getElementById(e.slice(1)):document.querySelector(e):e;if(!s)return;t=eb(s,n)}else t=n;"scrollBehavior"in document.documentElement.style?window.scrollTo(t):window.scrollTo(t.left!=null?t.left:window.pageXOffset,t.top!=null?t.top:window.pageYOffset)}function ep(n,t){return(history.state?history.state.position-t:-1)+n}const Yc=new Map;function ib(n,t){Yc.set(n,t)}function sb(n){const t=Yc.get(n);return Yc.delete(n),t}let rb=()=>location.protocol+"//"+location.host;function np(n,t){const{pathname:e,search:i,hash:s}=t,r=n.indexOf("#");if(r>-1){let a=s.includes(n.slice(r))?n.slice(r).length:1,l=s.slice(a);return l[0]!=="/"&&(l="/"+l),Kf(l,"")}return Kf(e,n)+i+s}function ob(n,t,e,i){let s=[],r=[],o=null;const a=({state:d})=>{const f=np(n,location),p=e.value,x=t.value;let _=0;if(d){if(e.value=f,t.value=d,o&&o===p){o=null;return}_=x?d.position-x.position:0}else i(f);s.forEach(m=>{m(e.value,p,{delta:_,type:Vr.pop,direction:_?_>0?Wr.forward:Wr.back:Wr.unknown})})};function l(){o=e.value}function c(d){s.push(d);const f=()=>{const p=s.indexOf(d);p>-1&&s.splice(p,1)};return r.push(f),f}function h(){const{history:d}=window;!d.state||d.replaceState(ee({},d.state,{scroll:Ma()}),"")}function u(){for(const d of r)d();r=[],window.removeEventListener("popstate",a),window.removeEventListener("beforeunload",h)}return window.addEventListener("popstate",a),window.addEventListener("beforeunload",h),{pauseListeners:l,listen:c,destroy:u}}function ip(n,t,e,i=!1,s=!1){return{back:n,current:t,forward:e,replaced:i,position:window.history.length,scroll:s?Ma():null}}function ab(n){const{history:t,location:e}=window,i={value:np(n,e)},s={value:t.state};s.value||r(i.value,{back:null,current:i.value,forward:null,position:t.length-1,replaced:!0,scroll:null},!0);function r(l,c,h){const u=n.indexOf("#"),d=u>-1?(e.host&&document.querySelector("base")?n:n.slice(u))+l:rb()+n+l;try{t[h?"replaceState":"pushState"](c,"",d),s.value=c}catch(f){console.error(f),e[h?"replace":"assign"](d)}}function o(l,c){const h=ee({},t.state,ip(s.value.back,l,s.value.forward,!0),c,{position:s.value.position});r(l,h,!0),i.value=l}function a(l,c){const h=ee({},s.value,t.state,{forward:l,scroll:Ma()});r(h.current,h,!0);const u=ee({},ip(i.value,l,null),{position:h.position+1},c);r(l,u,!1),i.value=l}return{location:i,state:s,push:a,replace:o}}function lb(n){n=Kv(n);const t=ab(n),e=ob(n,t.state,t.location,t.replace);function i(r,o=!0){o||e.pauseListeners(),history.go(r)}const s=ee({location:"",base:n,go:i,createHref:tb.bind(null,n)},t,e);return Object.defineProperty(s,"location",{enumerable:!0,get:()=>t.location.value}),Object.defineProperty(s,"state",{enumerable:!0,get:()=>t.state.value}),s}function I3(n){return n=location.host?n||location.pathname+location.search:"",n.includes("#")||(n+="#"),lb(n)}function cb(n){return typeof n=="string"||n&&typeof n=="object"}function sp(n){return typeof n=="string"||typeof n=="symbol"}const ci={path:"/",name:void 0,params:{},query:{},hash:"",fullPath:"/",matched:[],meta:{},redirectedFrom:void 0},rp=Rs("nf");var op;(function(n){n[n.aborted=4]="aborted",n[n.cancelled=8]="cancelled",n[n.duplicated=16]="duplicated"})(op||(op={}));function Is(n,t){return ee(new Error,{type:n,[rp]:!0},t)}function qi(n,t){return n instanceof Error&&rp in n&&(t==null||!!(n.type&t))}const ap="[^/]+?",hb={sensitive:!1,strict:!1,start:!0,end:!0},ub=/[.+*?^${}()[\]/\\]/g;function db(n,t){const e=ee({},hb,t),i=[];let s=e.start?"^":"";const r=[];for(const c of n){const h=c.length?[]:[90];e.strict&&!c.length&&(s+="/");for(let u=0;u<c.length;u++){const d=c[u];let f=40+(e.sensitive?.25:0);if(d.type===0)u||(s+="/"),s+=d.value.replace(ub,"\\$&"),f+=40;else if(d.type===1){const{value:p,repeatable:x,optional:_,regexp:m}=d;r.push({name:p,repeatable:x,optional:_});const g=m||ap;if(g!==ap){f+=10;try{new RegExp(`(${g})`)}catch(v){throw new Error(`Invalid custom RegExp for param "${p}" (${g}): `+v.message)}}let S=x?`((?:${g})(?:/(?:${g}))*)`:`(${g})`;u||(S=_&&c.length<2?`(?:/${S})`:"/"+S),_&&(S+="?"),s+=S,f+=20,_&&(f+=-8),x&&(f+=-20),g===".*"&&(f+=-50)}h.push(f)}i.push(h)}if(e.strict&&e.end){const c=i.length-1;i[c][i[c].length-1]+=.7000000000000001}e.strict||(s+="/?"),e.end?s+="$":e.strict&&(s+="(?:/|$)");const o=new RegExp(s,e.sensitive?"":"i");function a(c){const h=c.match(o),u={};if(!h)return null;for(let d=1;d<h.length;d++){const f=h[d]||"",p=r[d-1];u[p.name]=f&&p.repeatable?f.split("/"):f}return u}function l(c){let h="",u=!1;for(const d of n){(!u||!h.endsWith("/"))&&(h+="/"),u=!1;for(const f of d)if(f.type===0)h+=f.value;else if(f.type===1){const{value:p,repeatable:x,optional:_}=f,m=p in c?c[p]:"";if(Array.isArray(m)&&!x)throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);const g=Array.isArray(m)?m.join("/"):m;if(!g)if(_)d.length<2&&(h.endsWith("/")?h=h.slice(0,-1):u=!0);else throw new Error(`Missing required param "${p}"`);h+=g}}return h}return{re:o,score:i,keys:r,parse:a,stringify:l}}function fb(n,t){let e=0;for(;e<n.length&&e<t.length;){const i=t[e]-n[e];if(i)return i;e++}return n.length<t.length?n.length===1&&n[0]===40+40?-1:1:n.length>t.length?t.length===1&&t[0]===40+40?1:-1:0}function pb(n,t){let e=0;const i=n.score,s=t.score;for(;e<i.length&&e<s.length;){const r=fb(i[e],s[e]);if(r)return r;e++}return s.length-i.length}const mb={type:0,value:""},gb=/[a-zA-Z0-9_]/;function xb(n){if(!n)return[[]];if(n==="/")return[[mb]];if(!n.startsWith("/"))throw new Error(`Invalid path "${n}"`);function t(f){throw new Error(`ERR (${e})/"${c}": ${f}`)}let e=0,i=e;const s=[];let r;function o(){r&&s.push(r),r=[]}let a=0,l,c="",h="";function u(){!c||(e===0?r.push({type:0,value:c}):e===1||e===2||e===3?(r.length>1&&(l==="*"||l==="+")&&t(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`),r.push({type:1,value:c,regexp:h,repeatable:l==="*"||l==="+",optional:l==="*"||l==="?"})):t("Invalid state to consume buffer"),c="")}function d(){c+=l}for(;a<n.length;){if(l=n[a++],l==="\\"&&e!==2){i=e,e=4;continue}switch(e){case 0:l==="/"?(c&&u(),o()):l===":"?(u(),e=1):d();break;case 4:d(),e=i;break;case 1:l==="("?e=2:gb.test(l)?d():(u(),e=0,l!=="*"&&l!=="?"&&l!=="+"&&a--);break;case 2:l===")"?h[h.length-1]=="\\"?h=h.slice(0,-1)+l:e=3:h+=l;break;case 3:u(),e=0,l!=="*"&&l!=="?"&&l!=="+"&&a--,h="";break;default:t("Unknown state");break}}return e===2&&t(`Unfinished custom RegExp for param "${c}"`),u(),o(),s}function _b(n,t,e){const i=db(xb(n.path),e),s=ee(i,{record:n,parent:t,children:[],alias:[]});return t&&!s.record.aliasOf==!t.record.aliasOf&&t.children.push(s),s}function yb(n,t){const e=[],i=new Map;t=cp({strict:!1,end:!0,sensitive:!1},t);function s(h){return i.get(h)}function r(h,u,d){const f=!d,p=bb(h);p.aliasOf=d&&d.record;const x=cp(t,h),_=[p];if("alias"in h){const S=typeof h.alias=="string"?[h.alias]:h.alias;for(const v of S)_.push(ee({},p,{components:d?d.record.components:p.components,path:v,aliasOf:d?d.record:p}))}let m,g;for(const S of _){const{path:v}=S;if(u&&v[0]!=="/"){const E=u.record.path,R=E[E.length-1]==="/"?"":"/";S.path=u.record.path+(v&&R+v)}if(m=_b(S,u,x),d?d.alias.push(m):(g=g||m,g!==m&&g.alias.push(m),f&&h.name&&!lp(m)&&o(h.name)),"children"in p){const E=p.children;for(let R=0;R<E.length;R++)r(E[R],m,d&&d.children[R])}d=d||m,l(m)}return g?()=>{o(g)}:Ur}function o(h){if(sp(h)){const u=i.get(h);u&&(i.delete(h),e.splice(e.indexOf(u),1),u.children.forEach(o),u.alias.forEach(o))}else{const u=e.indexOf(h);u>-1&&(e.splice(u,1),h.record.name&&i.delete(h.record.name),h.children.forEach(o),h.alias.forEach(o))}}function a(){return e}function l(h){let u=0;for(;u<e.length&&pb(h,e[u])>=0;)u++;e.splice(u,0,h),h.record.name&&!lp(h)&&i.set(h.record.name,h)}function c(h,u){let d,f={},p,x;if("name"in h&&h.name){if(d=i.get(h.name),!d)throw Is(1,{location:h});x=d.record.name,f=ee(vb(u.params,d.keys.filter(g=>!g.optional).map(g=>g.name)),h.params),p=d.stringify(f)}else if("path"in h)p=h.path,d=e.find(g=>g.re.test(p)),d&&(f=d.parse(p),x=d.record.name);else{if(d=u.name?i.get(u.name):e.find(g=>g.re.test(u.path)),!d)throw Is(1,{location:h,currentLocation:u});x=d.record.name,f=ee({},u.params,h.params),p=d.stringify(f)}const _=[];let m=d;for(;m;)_.unshift(m.record),m=m.parent;return{name:x,path:p,params:f,matched:_,meta:wb(_)}}return n.forEach(h=>r(h)),{addRoute:r,resolve:c,removeRoute:o,getRoutes:a,getRecordMatcher:s}}function vb(n,t){const e={};for(const i of t)i in n&&(e[i]=n[i]);return e}function bb(n){return{path:n.path,redirect:n.redirect,name:n.name,meta:n.meta||{},aliasOf:void 0,beforeEnter:n.beforeEnter,props:Mb(n),children:n.children||[],instances:{},leaveGuards:new Set,updateGuards:new Set,enterCallbacks:{},components:"components"in n?n.components||{}:{default:n.component}}}function Mb(n){const t={},e=n.props||!1;if("component"in n)t.default=e;else for(const i in n.components)t[i]=typeof e=="boolean"?e:e[i];return t}function lp(n){for(;n;){if(n.record.aliasOf)return!0;n=n.parent}return!1}function wb(n){return n.reduce((t,e)=>ee(t,e.meta),{})}function cp(n,t){const e={};for(const i in n)e[i]=i in t?t[i]:n[i];return e}const hp=/#/g,Sb=/&/g,Eb=/\//g,Tb=/=/g,Ab=/\?/g,up=/\+/g,Cb=/%5B/g,Lb=/%5D/g,dp=/%5E/g,Rb=/%60/g,fp=/%7B/g,Pb=/%7C/g,pp=/%7D/g,Db=/%20/g;function Zc(n){return encodeURI(""+n).replace(Pb,"|").replace(Cb,"[").replace(Lb,"]")}function Ib(n){return Zc(n).replace(fp,"{").replace(pp,"}").replace(dp,"^")}function Jc(n){return Zc(n).replace(up,"%2B").replace(Db,"+").replace(hp,"%23").replace(Sb,"%26").replace(Rb,"`").replace(fp,"{").replace(pp,"}").replace(dp,"^")}function Fb(n){return Jc(n).replace(Tb,"%3D")}function Ob(n){return Zc(n).replace(hp,"%23").replace(Ab,"%3F")}function kb(n){return n==null?"":Ob(n).replace(Eb,"%2F")}function wa(n){try{return decodeURIComponent(""+n)}catch{}return""+n}function Nb(n){const t={};if(n===""||n==="?")return t;const i=(n[0]==="?"?n.slice(1):n).split("&");for(let s=0;s<i.length;++s){const r=i[s].replace(up," "),o=r.indexOf("="),a=wa(o<0?r:r.slice(0,o)),l=o<0?null:wa(r.slice(o+1));if(a in t){let c=t[a];Array.isArray(c)||(c=t[a]=[c]),c.push(l)}else t[a]=l}return t}function mp(n){let t="";for(let e in n){const i=n[e];if(e=Fb(e),i==null){i!==void 0&&(t+=(t.length?"&":"")+e);continue}(Array.isArray(i)?i.map(r=>r&&Jc(r)):[i&&Jc(i)]).forEach(r=>{r!==void 0&&(t+=(t.length?"&":"")+e,r!=null&&(t+="="+r))})}return t}function zb(n){const t={};for(const e in n){const i=n[e];i!==void 0&&(t[e]=Array.isArray(i)?i.map(s=>s==null?null:""+s):i==null?i:""+i)}return t}function Gr(){let n=[];function t(i){return n.push(i),()=>{const s=n.indexOf(i);s>-1&&n.splice(s,1)}}function e(){n=[]}return{add:t,list:()=>n,reset:e}}function hi(n,t,e,i,s){const r=i&&(i.enterCallbacks[s]=i.enterCallbacks[s]||[]);return()=>new Promise((o,a)=>{const l=u=>{u===!1?a(Is(4,{from:e,to:t})):u instanceof Error?a(u):cb(u)?a(Is(2,{from:t,to:u})):(r&&i.enterCallbacks[s]===r&&typeof u=="function"&&r.push(u),o())},c=n.call(i&&i.instances[s],t,e,l);let h=Promise.resolve(c);n.length<3&&(h=h.then(l)),h.catch(u=>a(u))})}function Kc(n,t,e,i){const s=[];for(const r of n)for(const o in r.components){let a=r.components[o];if(!(t!=="beforeRouteEnter"&&!r.instances[o]))if(Bb(a)){const c=(a.__vccOpts||a)[t];c&&s.push(hi(c,e,i,r,o))}else{let l=a();s.push(()=>l.then(c=>{if(!c)return Promise.reject(new Error(`Couldn't resolve component "${o}" at "${r.path}"`));const h=jv(c)?c.default:c;r.components[o]=h;const d=(h.__vccOpts||h)[t];return d&&hi(d,e,i,r,o)()}))}}return s}function Bb(n){return typeof n=="object"||"displayName"in n||"props"in n||"__vccOpts"in n}function gp(n){const t=si(jc),e=si(Jf),i=Cn(()=>t.resolve(Dr(n.to))),s=Cn(()=>{const{matched:l}=i.value,{length:c}=l,h=l[c-1],u=e.matched;if(!h||!u.length)return-1;const d=u.findIndex(Ds.bind(null,h));if(d>-1)return d;const f=xp(l[c-2]);return c>1&&xp(h)===f&&u[u.length-1].path!==f?u.findIndex(Ds.bind(null,l[c-2])):d}),r=Cn(()=>s.value>-1&&Wb(e.params,i.value.params)),o=Cn(()=>s.value>-1&&s.value===e.matched.length-1&&Qf(e.params,i.value.params));function a(l={}){return Vb(l)?t[Dr(n.replace)?"replace":"push"](Dr(n.to)).catch(Ur):Promise.resolve()}return{route:i,href:Cn(()=>i.value.href),isActive:r,isExactActive:o,navigate:a}}const Hb=Jd({name:"RouterLink",props:{to:{type:[String,Object],required:!0},replace:Boolean,activeClass:String,exactActiveClass:String,custom:Boolean,ariaCurrentValue:{type:String,default:"page"}},useLink:gp,setup(n,{slots:t}){const e=Ms(gp(n)),{options:i}=si(jc),s=Cn(()=>({[_p(n.activeClass,i.linkActiveClass,"router-link-active")]:e.isActive,[_p(n.exactActiveClass,i.linkExactActiveClass,"router-link-exact-active")]:e.isExactActive}));return()=>{const r=t.default&&t.default(e);return n.custom?r:Nf("a",{"aria-current":e.isExactActive?n.ariaCurrentValue:null,href:e.href,onClick:e.navigate,class:s.value},r)}}}),Ub=Hb;function Vb(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey)&&!n.defaultPrevented&&!(n.button!==void 0&&n.button!==0)){if(n.currentTarget&&n.currentTarget.getAttribute){const t=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return n.preventDefault&&n.preventDefault(),!0}}function Wb(n,t){for(const e in t){const i=t[e],s=n[e];if(typeof i=="string"){if(i!==s)return!1}else if(!Array.isArray(s)||s.length!==i.length||i.some((r,o)=>r!==s[o]))return!1}return!0}function xp(n){return n?n.aliasOf?n.aliasOf.path:n.path:""}const _p=(n,t,e)=>n!=null?n:t!=null?t:e,Gb=Jd({name:"RouterView",inheritAttrs:!1,props:{name:{type:String,default:"default"},route:Object},setup(n,{attrs:t,slots:e}){const i=si(qc),s=Cn(()=>n.route||i.value),r=si(Zf,0),o=Cn(()=>s.value.matched[r]);ua(Zf,r+1),ua(Gv,o),ua(qc,s);const a=e0();return As(()=>[a.value,o.value,n.name],([l,c,h],[u,d,f])=>{c&&(c.instances[h]=l,d&&d!==c&&l&&l===u&&(c.leaveGuards.size||(c.leaveGuards=d.leaveGuards),c.updateGuards.size||(c.updateGuards=d.updateGuards))),l&&c&&(!d||!Ds(c,d)||!u)&&(c.enterCallbacks[h]||[]).forEach(p=>p(l))},{flush:"post"}),()=>{const l=s.value,c=o.value,h=c&&c.components[n.name],u=n.name;if(!h)return yp(e.default,{Component:h,route:l});const d=c.props[n.name],f=d?d===!0?l.params:typeof d=="function"?d(l):d:null,x=Nf(h,ee({},f,t,{onVnodeUnmounted:_=>{_.component.isUnmounted&&(c.instances[u]=null)},ref:a}));return yp(e.default,{Component:x,route:l})||x}}});function yp(n,t){if(!n)return null;const e=n(t);return e.length===1?e[0]:e}const jb=Gb;function F3(n){const t=yb(n.routes,n),e=n.parseQuery||Nb,i=n.stringifyQuery||mp,s=n.history,r=Gr(),o=Gr(),a=Gr(),l=n0(ci);let c=ci;Ps&&n.scrollBehavior&&"scrollRestoration"in history&&(history.scrollRestoration="manual");const h=Xc.bind(null,J=>""+J),u=Xc.bind(null,kb),d=Xc.bind(null,wa);function f(J,j){let ht,H;return sp(J)?(ht=t.getRecordMatcher(J),H=j):H=J,t.addRoute(H,ht)}function p(J){const j=t.getRecordMatcher(J);j&&t.removeRoute(j)}function x(){return t.getRoutes().map(J=>J.record)}function _(J){return!!t.getRecordMatcher(J)}function m(J,j){if(j=ee({},j||l.value),typeof J=="string"){const z=$c(e,J,j.path),b=t.resolve({path:z.path},j),w=s.createHref(z.fullPath);return ee(z,b,{params:d(b.params),hash:wa(z.hash),redirectedFrom:void 0,href:w})}let ht;if("path"in J)ht=ee({},J,{path:$c(e,J.path,j.path).path});else{const z=ee({},J.params);for(const b in z)z[b]==null&&delete z[b];ht=ee({},J,{params:u(J.params)}),j.params=u(j.params)}const H=t.resolve(ht,j),rt=J.hash||"";H.params=h(d(H.params));const K=$v(i,ee({},J,{hash:Ib(rt),path:H.path})),at=s.createHref(K);return ee({fullPath:K,hash:rt,query:i===mp?zb(J.query):J.query||{}},H,{redirectedFrom:void 0,href:at})}function g(J){return typeof J=="string"?$c(e,J,l.value.path):ee({},J)}function S(J,j){if(c!==J)return Is(8,{from:j,to:J})}function v(J){return D(J)}function E(J){return v(ee(g(J),{replace:!0}))}function R(J){const j=J.matched[J.matched.length-1];if(j&&j.redirect){const{redirect:ht}=j;let H=typeof ht=="function"?ht(J):ht;return typeof H=="string"&&(H=H.includes("?")||H.includes("#")?H=g(H):{path:H},H.params={}),ee({query:J.query,hash:J.hash,params:J.params},H)}}function D(J,j){const ht=c=m(J),H=l.value,rt=J.state,K=J.force,at=J.replace===!0,z=R(ht);if(z)return D(ee(g(z),{state:rt,force:K,replace:at}),j||ht);const b=ht;b.redirectedFrom=j;let w;return!K&&Yv(i,H,ht)&&(w=Is(16,{to:b,from:H}),et(H,H,!0,!1)),(w?Promise.resolve(w):it(b,H)).catch(L=>qi(L)?L:U(L,b,H)).then(L=>{if(L){if(qi(L,2))return D(ee(g(L.to),{state:rt,force:K,replace:at}),j||b)}else L=N(b,H,!0,at,rt);return tt(b,H,L),L})}function $(J,j){const ht=S(J,j);return ht?Promise.reject(ht):Promise.resolve()}function it(J,j){let ht;const[H,rt,K]=qb(J,j);ht=Kc(H.reverse(),"beforeRouteLeave",J,j);for(const z of H)z.leaveGuards.forEach(b=>{ht.push(hi(b,J,j))});const at=$.bind(null,J,j);return ht.push(at),Fs(ht).then(()=>{ht=[];for(const z of r.list())ht.push(hi(z,J,j));return ht.push(at),Fs(ht)}).then(()=>{ht=Kc(rt,"beforeRouteUpdate",J,j);for(const z of rt)z.updateGuards.forEach(b=>{ht.push(hi(b,J,j))});return ht.push(at),Fs(ht)}).then(()=>{ht=[];for(const z of J.matched)if(z.beforeEnter&&!j.matched.includes(z))if(Array.isArray(z.beforeEnter))for(const b of z.beforeEnter)ht.push(hi(b,J,j));else ht.push(hi(z.beforeEnter,J,j));return ht.push(at),Fs(ht)}).then(()=>(J.matched.forEach(z=>z.enterCallbacks={}),ht=Kc(K,"beforeRouteEnter",J,j),ht.push(at),Fs(ht))).then(()=>{ht=[];for(const z of o.list())ht.push(hi(z,J,j));return ht.push(at),Fs(ht)}).catch(z=>qi(z,8)?z:Promise.reject(z))}function tt(J,j,ht){for(const H of a.list())H(J,j,ht)}function N(J,j,ht,H,rt){const K=S(J,j);if(K)return K;const at=j===ci,z=Ps?history.state:{};ht&&(H||at?s.replace(J.fullPath,ee({scroll:at&&z&&z.scroll},rt)):s.push(J.fullPath,rt)),l.value=J,et(J,j,ht,at),xt()}let T;function A(){T=s.listen((J,j,ht)=>{const H=m(J),rt=R(H);if(rt){D(ee(rt,{replace:!0}),H).catch(Ur);return}c=H;const K=l.value;Ps&&ib(ep(K.fullPath,ht.delta),Ma()),it(H,K).catch(at=>qi(at,4|8)?at:qi(at,2)?(D(at.to,H).then(z=>{qi(z,4|16)&&!ht.delta&&ht.type===Vr.pop&&s.go(-1,!1)}).catch(Ur),Promise.reject()):(ht.delta&&s.go(-ht.delta,!1),U(at,H,K))).then(at=>{at=at||N(H,K,!1),at&&(ht.delta?s.go(-ht.delta,!1):ht.type===Vr.pop&&qi(at,4|16)&&s.go(-1,!1)),tt(H,K,at)}).catch(Ur)})}let W=Gr(),V=Gr(),k;function U(J,j,ht){xt(J);const H=V.list();return H.length?H.forEach(rt=>rt(J,j,ht)):console.error(J),Promise.reject(J)}function ct(){return k&&l.value!==ci?Promise.resolve():new Promise((J,j)=>{W.add([J,j])})}function xt(J){k||(k=!0,A(),W.list().forEach(([j,ht])=>J?ht(J):j()),W.reset())}function et(J,j,ht,H){const{scrollBehavior:rt}=n;if(!Ps||!rt)return Promise.resolve();const K=!ht&&sb(ep(J.fullPath,0))||(H||!ht)&&history.state&&history.state.scroll||null;return Cf().then(()=>rt(J,j,K)).then(at=>at&&nb(at)).catch(at=>U(at,J,j))}const ot=J=>s.go(J);let yt;const gt=new Set;return{currentRoute:l,addRoute:f,removeRoute:p,hasRoute:_,getRoutes:x,resolve:m,options:n,push:v,replace:E,go:ot,back:()=>ot(-1),forward:()=>ot(1),beforeEach:r.add,beforeResolve:o.add,afterEach:a.add,onError:V.add,isReady:ct,install(J){const j=this;J.component("RouterLink",Ub),J.component("RouterView",jb),J.config.globalProperties.$router=j,Object.defineProperty(J.config.globalProperties,"$route",{enumerable:!0,get:()=>Dr(l)}),Ps&&!yt&&l.value===ci&&(yt=!0,v(s.location).catch(rt=>{}));const ht={};for(const rt in ci)ht[rt]=Cn(()=>l.value[rt]);J.provide(jc,j),J.provide(Jf,Ms(ht)),J.provide(qc,l);const H=J.unmount;gt.add(J),J.unmount=function(){gt.delete(J),gt.size<1&&(c=ci,T&&T(),l.value=ci,yt=!1,k=!1),H()}}}}function Fs(n){return n.reduce((t,e)=>t.then(()=>e()),Promise.resolve())}function qb(n,t){const e=[],i=[],s=[],r=Math.max(t.matched.length,n.matched.length);for(let o=0;o<r;o++){const a=t.matched[o];a&&(n.matched.find(c=>Ds(c,a))?i.push(a):e.push(a));const l=n.matched[o];l&&(t.matched.find(c=>Ds(c,l))||s.push(l))}return[e,i,s]}/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */const vp=function(){return typeof window=="undefined"?function(n){return n()}:window.requestAnimationFrame}();function bp(n,t,e){const i=e||(o=>Array.prototype.slice.call(o));let s=!1,r=[];return function(...o){r=i(o),s||(s=!0,vp.call(window,()=>{s=!1,n.apply(t,r)}))}}function Xb(n,t){let e;return function(...i){return t?(clearTimeout(e),e=setTimeout(n,t,i)):n.apply(this,i),t}}const Qc=n=>n==="start"?"left":n==="end"?"right":"center",Re=(n,t,e)=>n==="start"?t:n==="end"?e:(t+e)/2,$b=(n,t,e,i)=>n===(i?"left":"right")?e:n==="center"?(t+e)/2:t;function Gn(){}const Yb=function(){let n=0;return function(){return n++}}();function $t(n){return n===null||typeof n=="undefined"}function re(n){if(Array.isArray&&Array.isArray(n))return!0;const t=Object.prototype.toString.call(n);return t.substr(0,7)==="[object"&&t.substr(-6)==="Array]"}function Wt(n){return n!==null&&Object.prototype.toString.call(n)==="[object Object]"}const Ae=n=>(typeof n=="number"||n instanceof Number)&&isFinite(+n);function en(n,t){return Ae(n)?n:t}function Ot(n,t){return typeof n=="undefined"?t:n}const Zb=(n,t)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100:n/t,Mp=(n,t)=>typeof n=="string"&&n.endsWith("%")?parseFloat(n)/100*t:+n;function ne(n,t,e){if(n&&typeof n.call=="function")return n.apply(e,t)}function Yt(n,t,e,i){let s,r,o;if(re(n))if(r=n.length,i)for(s=r-1;s>=0;s--)t.call(e,n[s],s);else for(s=0;s<r;s++)t.call(e,n[s],s);else if(Wt(n))for(o=Object.keys(n),r=o.length,s=0;s<r;s++)t.call(e,n[o[s]],o[s])}function Sa(n,t){let e,i,s,r;if(!n||!t||n.length!==t.length)return!1;for(e=0,i=n.length;e<i;++e)if(s=n[e],r=t[e],s.datasetIndex!==r.datasetIndex||s.index!==r.index)return!1;return!0}function Ea(n){if(re(n))return n.map(Ea);if(Wt(n)){const t=Object.create(null),e=Object.keys(n),i=e.length;let s=0;for(;s<i;++s)t[e[s]]=Ea(n[e[s]]);return t}return n}function wp(n){return["__proto__","prototype","constructor"].indexOf(n)===-1}function Jb(n,t,e,i){if(!wp(n))return;const s=t[n],r=e[n];Wt(s)&&Wt(r)?jr(s,r,i):t[n]=Ea(r)}function jr(n,t,e){const i=re(t)?t:[t],s=i.length;if(!Wt(n))return n;e=e||{};const r=e.merger||Jb;for(let o=0;o<s;++o){if(t=i[o],!Wt(t))continue;const a=Object.keys(t);for(let l=0,c=a.length;l<c;++l)r(a[l],n,t,e)}return n}function qr(n,t){return jr(n,t,{merger:Kb})}function Kb(n,t,e){if(!wp(n))return;const i=t[n],s=e[n];Wt(i)&&Wt(s)?qr(i,s):Object.prototype.hasOwnProperty.call(t,n)||(t[n]=Ea(s))}const Qb="",tM=".";function Sp(n,t){const e=n.indexOf(tM,t);return e===-1?n.length:e}function Xi(n,t){if(t===Qb)return n;let e=0,i=Sp(t,e);for(;n&&i>e;)n=n[t.substr(e,i-e)],e=i+1,i=Sp(t,e);return n}function th(n){return n.charAt(0).toUpperCase()+n.slice(1)}const nn=n=>typeof n!="undefined",ui=n=>typeof n=="function",Ep=(n,t)=>{if(n.size!==t.size)return!1;for(const e of n)if(!t.has(e))return!1;return!0};function eM(n){return n.type==="mouseup"||n.type==="click"||n.type==="contextmenu"}const oe=Math.PI,ie=2*oe,nM=ie+oe,Ta=Number.POSITIVE_INFINITY,iM=oe/180,ue=oe/2,Xr=oe/4,Tp=oe*2/3,sn=Math.log10,Pn=Math.sign;function Ap(n){const t=Math.round(n);n=Yr(n,t,n/1e3)?t:n;const e=Math.pow(10,Math.floor(sn(n))),i=n/e;return(i<=1?1:i<=2?2:i<=5?5:10)*e}function sM(n){const t=[],e=Math.sqrt(n);let i;for(i=1;i<e;i++)n%i==0&&(t.push(i),t.push(n/i));return e===(e|0)&&t.push(e),t.sort((s,r)=>s-r).pop(),t}function $r(n){return!isNaN(parseFloat(n))&&isFinite(n)}function Yr(n,t,e){return Math.abs(n-t)<e}function rM(n,t){const e=Math.round(n);return e-t<=n&&e+t>=n}function Cp(n,t,e){let i,s,r;for(i=0,s=n.length;i<s;i++)r=n[i][e],isNaN(r)||(t.min=Math.min(t.min,r),t.max=Math.max(t.max,r))}function pn(n){return n*(oe/180)}function eh(n){return n*(180/oe)}function Lp(n){if(!Ae(n))return;let t=1,e=0;for(;Math.round(n*t)/t!==n;)t*=10,e++;return e}function Rp(n,t){const e=t.x-n.x,i=t.y-n.y,s=Math.sqrt(e*e+i*i);let r=Math.atan2(i,e);return r<-.5*oe&&(r+=ie),{angle:r,distance:s}}function nh(n,t){return Math.sqrt(Math.pow(t.x-n.x,2)+Math.pow(t.y-n.y,2))}function oM(n,t){return(n-t+nM)%ie-oe}function mn(n){return(n%ie+ie)%ie}function Zr(n,t,e,i){const s=mn(n),r=mn(t),o=mn(e),a=mn(r-s),l=mn(o-s),c=mn(s-r),h=mn(s-o);return s===r||s===o||i&&r===o||a>l&&c<h}function Pe(n,t,e){return Math.max(t,Math.min(e,n))}function aM(n){return Pe(n,-32768,32767)}function di(n,t,e,i=1e-6){return n>=Math.min(t,e)-i&&n<=Math.max(t,e)+i}const Aa=n=>n===0||n===1,Pp=(n,t,e)=>-(Math.pow(2,10*(n-=1))*Math.sin((n-t)*ie/e)),Dp=(n,t,e)=>Math.pow(2,-10*n)*Math.sin((n-t)*ie/e)+1,Jr={linear:n=>n,easeInQuad:n=>n*n,easeOutQuad:n=>-n*(n-2),easeInOutQuad:n=>(n/=.5)<1?.5*n*n:-.5*(--n*(n-2)-1),easeInCubic:n=>n*n*n,easeOutCubic:n=>(n-=1)*n*n+1,easeInOutCubic:n=>(n/=.5)<1?.5*n*n*n:.5*((n-=2)*n*n+2),easeInQuart:n=>n*n*n*n,easeOutQuart:n=>-((n-=1)*n*n*n-1),easeInOutQuart:n=>(n/=.5)<1?.5*n*n*n*n:-.5*((n-=2)*n*n*n-2),easeInQuint:n=>n*n*n*n*n,easeOutQuint:n=>(n-=1)*n*n*n*n+1,easeInOutQuint:n=>(n/=.5)<1?.5*n*n*n*n*n:.5*((n-=2)*n*n*n*n+2),easeInSine:n=>-Math.cos(n*ue)+1,easeOutSine:n=>Math.sin(n*ue),easeInOutSine:n=>-.5*(Math.cos(oe*n)-1),easeInExpo:n=>n===0?0:Math.pow(2,10*(n-1)),easeOutExpo:n=>n===1?1:-Math.pow(2,-10*n)+1,easeInOutExpo:n=>Aa(n)?n:n<.5?.5*Math.pow(2,10*(n*2-1)):.5*(-Math.pow(2,-10*(n*2-1))+2),easeInCirc:n=>n>=1?n:-(Math.sqrt(1-n*n)-1),easeOutCirc:n=>Math.sqrt(1-(n-=1)*n),easeInOutCirc:n=>(n/=.5)<1?-.5*(Math.sqrt(1-n*n)-1):.5*(Math.sqrt(1-(n-=2)*n)+1),easeInElastic:n=>Aa(n)?n:Pp(n,.075,.3),easeOutElastic:n=>Aa(n)?n:Dp(n,.075,.3),easeInOutElastic(n){const t=.1125,e=.45;return Aa(n)?n:n<.5?.5*Pp(n*2,t,e):.5+.5*Dp(n*2-1,t,e)},easeInBack(n){const t=1.70158;return n*n*((t+1)*n-t)},easeOutBack(n){const t=1.70158;return(n-=1)*n*((t+1)*n+t)+1},easeInOutBack(n){let t=1.70158;return(n/=.5)<1?.5*(n*n*(((t*=1.525)+1)*n-t)):.5*((n-=2)*n*(((t*=1.525)+1)*n+t)+2)},easeInBounce:n=>1-Jr.easeOutBounce(1-n),easeOutBounce(n){const t=7.5625,e=2.75;return n<1/e?t*n*n:n<2/e?t*(n-=1.5/e)*n+.75:n<2.5/e?t*(n-=2.25/e)*n+.9375:t*(n-=2.625/e)*n+.984375},easeInOutBounce:n=>n<.5?Jr.easeInBounce(n*2)*.5:Jr.easeOutBounce(n*2-1)*.5+.5};/*!
 * @kurkle/color v0.1.9
 * https://github.com/kurkle/color#readme
 * (c) 2020 Jukka Kurkela
 * Released under the MIT License
 */const rn={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},ih="0123456789ABCDEF",lM=n=>ih[n&15],cM=n=>ih[(n&240)>>4]+ih[n&15],Ca=n=>(n&240)>>4==(n&15);function hM(n){return Ca(n.r)&&Ca(n.g)&&Ca(n.b)&&Ca(n.a)}function uM(n){var t=n.length,e;return n[0]==="#"&&(t===4||t===5?e={r:255&rn[n[1]]*17,g:255&rn[n[2]]*17,b:255&rn[n[3]]*17,a:t===5?rn[n[4]]*17:255}:(t===7||t===9)&&(e={r:rn[n[1]]<<4|rn[n[2]],g:rn[n[3]]<<4|rn[n[4]],b:rn[n[5]]<<4|rn[n[6]],a:t===9?rn[n[7]]<<4|rn[n[8]]:255})),e}function dM(n){var t=hM(n)?lM:cM;return n&&"#"+t(n.r)+t(n.g)+t(n.b)+(n.a<255?t(n.a):"")}function Kr(n){return n+.5|0}const La=(n,t,e)=>Math.max(Math.min(n,e),t);function Qr(n){return La(Kr(n*2.55),0,255)}function to(n){return La(Kr(n*255),0,255)}function sh(n){return La(Kr(n/2.55)/100,0,1)}function Ip(n){return La(Kr(n*100),0,100)}const fM=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;function pM(n){const t=fM.exec(n);let e=255,i,s,r;if(!!t){if(t[7]!==i){const o=+t[7];e=255&(t[8]?Qr(o):o*255)}return i=+t[1],s=+t[3],r=+t[5],i=255&(t[2]?Qr(i):i),s=255&(t[4]?Qr(s):s),r=255&(t[6]?Qr(r):r),{r:i,g:s,b:r,a:e}}}function mM(n){return n&&(n.a<255?`rgba(${n.r}, ${n.g}, ${n.b}, ${sh(n.a)})`:`rgb(${n.r}, ${n.g}, ${n.b})`)}const gM=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function Fp(n,t,e){const i=t*Math.min(e,1-e),s=(r,o=(r+n/30)%12)=>e-i*Math.max(Math.min(o-3,9-o,1),-1);return[s(0),s(8),s(4)]}function xM(n,t,e){const i=(s,r=(s+n/60)%6)=>e-e*t*Math.max(Math.min(r,4-r,1),0);return[i(5),i(3),i(1)]}function _M(n,t,e){const i=Fp(n,1,.5);let s;for(t+e>1&&(s=1/(t+e),t*=s,e*=s),s=0;s<3;s++)i[s]*=1-t-e,i[s]+=t;return i}function rh(n){const t=255,e=n.r/t,i=n.g/t,s=n.b/t,r=Math.max(e,i,s),o=Math.min(e,i,s),a=(r+o)/2;let l,c,h;return r!==o&&(h=r-o,c=a>.5?h/(2-r-o):h/(r+o),l=r===e?(i-s)/h+(i<s?6:0):r===i?(s-e)/h+2:(e-i)/h+4,l=l*60+.5),[l|0,c||0,a]}function oh(n,t,e,i){return(Array.isArray(t)?n(t[0],t[1],t[2]):n(t,e,i)).map(to)}function ah(n,t,e){return oh(Fp,n,t,e)}function yM(n,t,e){return oh(_M,n,t,e)}function vM(n,t,e){return oh(xM,n,t,e)}function Op(n){return(n%360+360)%360}function bM(n){const t=gM.exec(n);let e=255,i;if(!t)return;t[5]!==i&&(e=t[6]?Qr(+t[5]):to(+t[5]));const s=Op(+t[2]),r=+t[3]/100,o=+t[4]/100;return t[1]==="hwb"?i=yM(s,r,o):t[1]==="hsv"?i=vM(s,r,o):i=ah(s,r,o),{r:i[0],g:i[1],b:i[2],a:e}}function MM(n,t){var e=rh(n);e[0]=Op(e[0]+t),e=ah(e),n.r=e[0],n.g=e[1],n.b=e[2]}function wM(n){if(!n)return;const t=rh(n),e=t[0],i=Ip(t[1]),s=Ip(t[2]);return n.a<255?`hsla(${e}, ${i}%, ${s}%, ${sh(n.a)})`:`hsl(${e}, ${i}%, ${s}%)`}const kp={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},Np={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};function SM(){const n={},t=Object.keys(Np),e=Object.keys(kp);let i,s,r,o,a;for(i=0;i<t.length;i++){for(o=a=t[i],s=0;s<e.length;s++)r=e[s],a=a.replace(r,kp[r]);r=parseInt(Np[o],16),n[a]=[r>>16&255,r>>8&255,r&255]}return n}let Ra;function EM(n){Ra||(Ra=SM(),Ra.transparent=[0,0,0,0]);const t=Ra[n.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:t.length===4?t[3]:255}}function Pa(n,t,e){if(n){let i=rh(n);i[t]=Math.max(0,Math.min(i[t]+i[t]*e,t===0?360:1)),i=ah(i),n.r=i[0],n.g=i[1],n.b=i[2]}}function zp(n,t){return n&&Object.assign(t||{},n)}function Bp(n){var t={r:0,g:0,b:0,a:255};return Array.isArray(n)?n.length>=3&&(t={r:n[0],g:n[1],b:n[2],a:255},n.length>3&&(t.a=to(n[3]))):(t=zp(n,{r:0,g:0,b:0,a:1}),t.a=to(t.a)),t}function TM(n){return n.charAt(0)==="r"?pM(n):bM(n)}class Da{constructor(t){if(t instanceof Da)return t;const e=typeof t;let i;e==="object"?i=Bp(t):e==="string"&&(i=uM(t)||EM(t)||TM(t)),this._rgb=i,this._valid=!!i}get valid(){return this._valid}get rgb(){var t=zp(this._rgb);return t&&(t.a=sh(t.a)),t}set rgb(t){this._rgb=Bp(t)}rgbString(){return this._valid?mM(this._rgb):this._rgb}hexString(){return this._valid?dM(this._rgb):this._rgb}hslString(){return this._valid?wM(this._rgb):this._rgb}mix(t,e){const i=this;if(t){const s=i.rgb,r=t.rgb;let o;const a=e===o?.5:e,l=2*a-1,c=s.a-r.a,h=((l*c==-1?l:(l+c)/(1+l*c))+1)/2;o=1-h,s.r=255&h*s.r+o*r.r+.5,s.g=255&h*s.g+o*r.g+.5,s.b=255&h*s.b+o*r.b+.5,s.a=a*s.a+(1-a)*r.a,i.rgb=s}return i}clone(){return new Da(this.rgb)}alpha(t){return this._rgb.a=to(t),this}clearer(t){const e=this._rgb;return e.a*=1-t,this}greyscale(){const t=this._rgb,e=Kr(t.r*.3+t.g*.59+t.b*.11);return t.r=t.g=t.b=e,this}opaquer(t){const e=this._rgb;return e.a*=1+t,this}negate(){const t=this._rgb;return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}lighten(t){return Pa(this._rgb,2,t),this}darken(t){return Pa(this._rgb,2,-t),this}saturate(t){return Pa(this._rgb,1,t),this}desaturate(t){return Pa(this._rgb,1,-t),this}rotate(t){return MM(this._rgb,t),this}}function Hp(n){return new Da(n)}const Up=n=>n instanceof CanvasGradient||n instanceof CanvasPattern;function Vp(n){return Up(n)?n:Hp(n)}function lh(n){return Up(n)?n:Hp(n).saturate(.5).darken(.1).hexString()}const $i=Object.create(null),ch=Object.create(null);function eo(n,t){if(!t)return n;const e=t.split(".");for(let i=0,s=e.length;i<s;++i){const r=e[i];n=n[r]||(n[r]=Object.create(null))}return n}function hh(n,t,e){return typeof t=="string"?jr(eo(n,t),e):jr(eo(n,""),t)}class AM{constructor(t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,i)=>lh(i.backgroundColor),this.hoverBorderColor=(e,i)=>lh(i.borderColor),this.hoverColor=(e,i)=>lh(i.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t)}set(t,e){return hh(this,t,e)}get(t){return eo(this,t)}describe(t,e){return hh(ch,t,e)}override(t,e){return hh($i,t,e)}route(t,e,i,s){const r=eo(this,t),o=eo(this,i),a="_"+e;Object.defineProperties(r,{[a]:{value:r[e],writable:!0},[e]:{enumerable:!0,get(){const l=this[a],c=o[s];return Wt(l)?Object.assign({},c,l):Ot(l,c)},set(l){this[a]=l}}})}}var Bt=new AM({_scriptable:n=>!n.startsWith("on"),_indexable:n=>n!=="events",hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}});function CM(n){return!n||$t(n.size)||$t(n.family)?null:(n.style?n.style+" ":"")+(n.weight?n.weight+" ":"")+n.size+"px "+n.family}function Ia(n,t,e,i,s){let r=t[s];return r||(r=t[s]=n.measureText(s).width,e.push(s)),r>i&&(i=r),i}function LM(n,t,e,i){i=i||{};let s=i.data=i.data||{},r=i.garbageCollect=i.garbageCollect||[];i.font!==t&&(s=i.data={},r=i.garbageCollect=[],i.font=t),n.save(),n.font=t;let o=0;const a=e.length;let l,c,h,u,d;for(l=0;l<a;l++)if(u=e[l],u!=null&&re(u)!==!0)o=Ia(n,s,r,o,u);else if(re(u))for(c=0,h=u.length;c<h;c++)d=u[c],d!=null&&!re(d)&&(o=Ia(n,s,r,o,d));n.restore();const f=r.length/2;if(f>e.length){for(l=0;l<f;l++)delete s[r[l]];r.splice(0,f)}return o}function Yi(n,t,e){const i=n.currentDevicePixelRatio,s=e!==0?Math.max(e/2,.5):0;return Math.round((t-s)*i)/i+s}function Wp(n,t){t=t||n.getContext("2d"),t.save(),t.resetTransform(),t.clearRect(0,0,n.width,n.height),t.restore()}function Fa(n,t,e,i){let s,r,o,a,l;const c=t.pointStyle,h=t.rotation,u=t.radius;let d=(h||0)*iM;if(c&&typeof c=="object"&&(s=c.toString(),s==="[object HTMLImageElement]"||s==="[object HTMLCanvasElement]")){n.save(),n.translate(e,i),n.rotate(d),n.drawImage(c,-c.width/2,-c.height/2,c.width,c.height),n.restore();return}if(!(isNaN(u)||u<=0)){switch(n.beginPath(),c){default:n.arc(e,i,u,0,ie),n.closePath();break;case"triangle":n.moveTo(e+Math.sin(d)*u,i-Math.cos(d)*u),d+=Tp,n.lineTo(e+Math.sin(d)*u,i-Math.cos(d)*u),d+=Tp,n.lineTo(e+Math.sin(d)*u,i-Math.cos(d)*u),n.closePath();break;case"rectRounded":l=u*.516,a=u-l,r=Math.cos(d+Xr)*a,o=Math.sin(d+Xr)*a,n.arc(e-r,i-o,l,d-oe,d-ue),n.arc(e+o,i-r,l,d-ue,d),n.arc(e+r,i+o,l,d,d+ue),n.arc(e-o,i+r,l,d+ue,d+oe),n.closePath();break;case"rect":if(!h){a=Math.SQRT1_2*u,n.rect(e-a,i-a,2*a,2*a);break}d+=Xr;case"rectRot":r=Math.cos(d)*u,o=Math.sin(d)*u,n.moveTo(e-r,i-o),n.lineTo(e+o,i-r),n.lineTo(e+r,i+o),n.lineTo(e-o,i+r),n.closePath();break;case"crossRot":d+=Xr;case"cross":r=Math.cos(d)*u,o=Math.sin(d)*u,n.moveTo(e-r,i-o),n.lineTo(e+r,i+o),n.moveTo(e+o,i-r),n.lineTo(e-o,i+r);break;case"star":r=Math.cos(d)*u,o=Math.sin(d)*u,n.moveTo(e-r,i-o),n.lineTo(e+r,i+o),n.moveTo(e+o,i-r),n.lineTo(e-o,i+r),d+=Xr,r=Math.cos(d)*u,o=Math.sin(d)*u,n.moveTo(e-r,i-o),n.lineTo(e+r,i+o),n.moveTo(e+o,i-r),n.lineTo(e-o,i+r);break;case"line":r=Math.cos(d)*u,o=Math.sin(d)*u,n.moveTo(e-r,i-o),n.lineTo(e+r,i+o);break;case"dash":n.moveTo(e,i),n.lineTo(e+Math.cos(d)*u,i+Math.sin(d)*u);break}n.fill(),t.borderWidth>0&&n.stroke()}}function Zi(n,t,e){return e=e||.5,!t||n&&n.x>t.left-e&&n.x<t.right+e&&n.y>t.top-e&&n.y<t.bottom+e}function uh(n,t){n.save(),n.beginPath(),n.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),n.clip()}function dh(n){n.restore()}function RM(n,t,e,i,s){if(!t)return n.lineTo(e.x,e.y);if(s==="middle"){const r=(t.x+e.x)/2;n.lineTo(r,t.y),n.lineTo(r,e.y)}else s==="after"!=!!i?n.lineTo(t.x,e.y):n.lineTo(e.x,t.y);n.lineTo(e.x,e.y)}function PM(n,t,e,i){if(!t)return n.lineTo(e.x,e.y);n.bezierCurveTo(i?t.cp1x:t.cp2x,i?t.cp1y:t.cp2y,i?e.cp2x:e.cp1x,i?e.cp2y:e.cp1y,e.x,e.y)}function Ji(n,t,e,i,s,r={}){const o=re(t)?t:[t],a=r.strokeWidth>0&&r.strokeColor!=="";let l,c;for(n.save(),n.font=s.string,DM(n,r),l=0;l<o.length;++l)c=o[l],a&&(r.strokeColor&&(n.strokeStyle=r.strokeColor),$t(r.strokeWidth)||(n.lineWidth=r.strokeWidth),n.strokeText(c,e,i,r.maxWidth)),n.fillText(c,e,i,r.maxWidth),IM(n,e,i,c,r),i+=s.lineHeight;n.restore()}function DM(n,t){t.translation&&n.translate(t.translation[0],t.translation[1]),$t(t.rotation)||n.rotate(t.rotation),t.color&&(n.fillStyle=t.color),t.textAlign&&(n.textAlign=t.textAlign),t.textBaseline&&(n.textBaseline=t.textBaseline)}function IM(n,t,e,i,s){if(s.strikethrough||s.underline){const r=n.measureText(i),o=t-r.actualBoundingBoxLeft,a=t+r.actualBoundingBoxRight,l=e-r.actualBoundingBoxAscent,c=e+r.actualBoundingBoxDescent,h=s.strikethrough?(l+c)/2:c;n.strokeStyle=n.fillStyle,n.beginPath(),n.lineWidth=s.decorationWidth||2,n.moveTo(o,h),n.lineTo(a,h),n.stroke()}}function Oa(n,t){const{x:e,y:i,w:s,h:r,radius:o}=t;n.arc(e+o.topLeft,i+o.topLeft,o.topLeft,-ue,oe,!0),n.lineTo(e,i+r-o.bottomLeft),n.arc(e+o.bottomLeft,i+r-o.bottomLeft,o.bottomLeft,oe,ue,!0),n.lineTo(e+s-o.bottomRight,i+r),n.arc(e+s-o.bottomRight,i+r-o.bottomRight,o.bottomRight,ue,0,!0),n.lineTo(e+s,i+o.topRight),n.arc(e+s-o.topRight,i+o.topRight,o.topRight,0,-ue,!0),n.lineTo(e+o.topLeft,i)}const FM=new RegExp(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/),OM=new RegExp(/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/);function kM(n,t){const e=(""+n).match(FM);if(!e||e[1]==="normal")return t*1.2;switch(n=+e[2],e[3]){case"px":return n;case"%":n/=100;break}return t*n}const NM=n=>+n||0;function fh(n,t){const e={},i=Wt(t),s=i?Object.keys(t):t,r=Wt(n)?i?o=>Ot(n[o],n[t[o]]):o=>n[o]:()=>n;for(const o of s)e[o]=NM(r(o));return e}function Gp(n){return fh(n,{top:"y",right:"x",bottom:"y",left:"x"})}function Os(n){return fh(n,["topLeft","topRight","bottomLeft","bottomRight"])}function De(n){const t=Gp(n);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function ge(n,t){n=n||{},t=t||Bt.font;let e=Ot(n.size,t.size);typeof e=="string"&&(e=parseInt(e,10));let i=Ot(n.style,t.style);i&&!(""+i).match(OM)&&(console.warn('Invalid font style specified: "'+i+'"'),i="");const s={family:Ot(n.family,t.family),lineHeight:kM(Ot(n.lineHeight,t.lineHeight),e),size:e,style:i,weight:Ot(n.weight,t.weight),string:""};return s.string=CM(s),s}function ka(n,t,e,i){let s=!0,r,o,a;for(r=0,o=n.length;r<o;++r)if(a=n[r],a!==void 0&&(t!==void 0&&typeof a=="function"&&(a=a(t),s=!1),e!==void 0&&re(a)&&(a=a[e%a.length],s=!1),a!==void 0))return i&&!s&&(i.cacheable=!1),a}function zM(n,t,e){const{min:i,max:s}=n,r=Mp(t,(s-i)/2),o=(a,l)=>e&&a===0?0:a+l;return{min:o(i,-Math.abs(r)),max:o(s,r)}}function fi(n,t){return Object.assign(Object.create(n),t)}function ph(n,t,e){e=e||(o=>n[o]<t);let i=n.length-1,s=0,r;for(;i-s>1;)r=s+i>>1,e(r)?s=r:i=r;return{lo:s,hi:i}}const Ki=(n,t,e)=>ph(n,e,i=>n[i][t]<e),BM=(n,t,e)=>ph(n,e,i=>n[i][t]>=e);function HM(n,t,e){let i=0,s=n.length;for(;i<s&&n[i]<t;)i++;for(;s>i&&n[s-1]>e;)s--;return i>0||s<n.length?n.slice(i,s):n}const jp=["push","pop","shift","splice","unshift"];function UM(n,t){if(n._chartjs){n._chartjs.listeners.push(t);return}Object.defineProperty(n,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),jp.forEach(e=>{const i="_onData"+th(e),s=n[e];Object.defineProperty(n,e,{configurable:!0,enumerable:!1,value(...r){const o=s.apply(this,r);return n._chartjs.listeners.forEach(a=>{typeof a[i]=="function"&&a[i](...r)}),o}})})}function qp(n,t){const e=n._chartjs;if(!e)return;const i=e.listeners,s=i.indexOf(t);s!==-1&&i.splice(s,1),!(i.length>0)&&(jp.forEach(r=>{delete n[r]}),delete n._chartjs)}function Xp(n){const t=new Set;let e,i;for(e=0,i=n.length;e<i;++e)t.add(n[e]);return t.size===i?n:Array.from(t)}function mh(n,t=[""],e=n,i,s=()=>n[0]){nn(i)||(i=Kp("_fallback",n));const r={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:n,_rootScopes:e,_fallback:i,_getTarget:s,override:o=>mh([o,...n],t,e,i)};return new Proxy(r,{deleteProperty(o,a){return delete o[a],delete o._keys,delete n[0][a],!0},get(o,a){return Yp(o,a,()=>YM(a,t,n,o))},getOwnPropertyDescriptor(o,a){return Reflect.getOwnPropertyDescriptor(o._scopes[0],a)},getPrototypeOf(){return Reflect.getPrototypeOf(n[0])},has(o,a){return Qp(o).includes(a)},ownKeys(o){return Qp(o)},set(o,a,l){const c=o._storage||(o._storage=s());return o[a]=c[a]=l,delete o._keys,!0}})}function ks(n,t,e,i){const s={_cacheable:!1,_proxy:n,_context:t,_subProxy:e,_stack:new Set,_descriptors:$p(n,i),setContext:r=>ks(n,r,e,i),override:r=>ks(n.override(r),t,e,i)};return new Proxy(s,{deleteProperty(r,o){return delete r[o],delete n[o],!0},get(r,o,a){return Yp(r,o,()=>WM(r,o,a))},getOwnPropertyDescriptor(r,o){return r._descriptors.allKeys?Reflect.has(n,o)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(n,o)},getPrototypeOf(){return Reflect.getPrototypeOf(n)},has(r,o){return Reflect.has(n,o)},ownKeys(){return Reflect.ownKeys(n)},set(r,o,a){return n[o]=a,delete r[o],!0}})}function $p(n,t={scriptable:!0,indexable:!0}){const{_scriptable:e=t.scriptable,_indexable:i=t.indexable,_allKeys:s=t.allKeys}=n;return{allKeys:s,scriptable:e,indexable:i,isScriptable:ui(e)?e:()=>e,isIndexable:ui(i)?i:()=>i}}const VM=(n,t)=>n?n+th(t):t,gh=(n,t)=>Wt(t)&&n!=="adapters"&&(Object.getPrototypeOf(t)===null||t.constructor===Object);function Yp(n,t,e){if(Object.prototype.hasOwnProperty.call(n,t))return n[t];const i=e();return n[t]=i,i}function WM(n,t,e){const{_proxy:i,_context:s,_subProxy:r,_descriptors:o}=n;let a=i[t];return ui(a)&&o.isScriptable(t)&&(a=GM(t,a,n,e)),re(a)&&a.length&&(a=jM(t,a,n,o.isIndexable)),gh(t,a)&&(a=ks(a,s,r&&r[t],o)),a}function GM(n,t,e,i){const{_proxy:s,_context:r,_subProxy:o,_stack:a}=e;if(a.has(n))throw new Error("Recursion detected: "+Array.from(a).join("->")+"->"+n);return a.add(n),t=t(r,o||i),a.delete(n),gh(n,t)&&(t=xh(s._scopes,s,n,t)),t}function jM(n,t,e,i){const{_proxy:s,_context:r,_subProxy:o,_descriptors:a}=e;if(nn(r.index)&&i(n))t=t[r.index%t.length];else if(Wt(t[0])){const l=t,c=s._scopes.filter(h=>h!==l);t=[];for(const h of l){const u=xh(c,s,n,h);t.push(ks(u,r,o&&o[n],a))}}return t}function Zp(n,t,e){return ui(n)?n(t,e):n}const qM=(n,t)=>n===!0?t:typeof n=="string"?Xi(t,n):void 0;function XM(n,t,e,i,s){for(const r of t){const o=qM(e,r);if(o){n.add(o);const a=Zp(o._fallback,e,s);if(nn(a)&&a!==e&&a!==i)return a}else if(o===!1&&nn(i)&&e!==i)return null}return!1}function xh(n,t,e,i){const s=t._rootScopes,r=Zp(t._fallback,e,i),o=[...n,...s],a=new Set;a.add(i);let l=Jp(a,o,e,r||e,i);return l===null||nn(r)&&r!==e&&(l=Jp(a,o,r,l,i),l===null)?!1:mh(Array.from(a),[""],s,r,()=>$M(t,e,i))}function Jp(n,t,e,i,s){for(;e;)e=XM(n,t,e,i,s);return e}function $M(n,t,e){const i=n._getTarget();t in i||(i[t]={});const s=i[t];return re(s)&&Wt(e)?e:s}function YM(n,t,e,i){let s;for(const r of t)if(s=Kp(VM(r,n),e),nn(s))return gh(n,s)?xh(e,i,n,s):s}function Kp(n,t){for(const e of t){if(!e)continue;const i=e[n];if(nn(i))return i}}function Qp(n){let t=n._keys;return t||(t=n._keys=ZM(n._scopes)),t}function ZM(n){const t=new Set;for(const e of n)for(const i of Object.keys(e).filter(s=>!s.startsWith("_")))t.add(i);return Array.from(t)}const JM=Number.EPSILON||1e-14,Ns=(n,t)=>t<n.length&&!n[t].skip&&n[t],tm=n=>n==="x"?"y":"x";function KM(n,t,e,i){const s=n.skip?t:n,r=t,o=e.skip?t:e,a=nh(r,s),l=nh(o,r);let c=a/(a+l),h=l/(a+l);c=isNaN(c)?0:c,h=isNaN(h)?0:h;const u=i*c,d=i*h;return{previous:{x:r.x-u*(o.x-s.x),y:r.y-u*(o.y-s.y)},next:{x:r.x+d*(o.x-s.x),y:r.y+d*(o.y-s.y)}}}function QM(n,t,e){const i=n.length;let s,r,o,a,l,c=Ns(n,0);for(let h=0;h<i-1;++h)if(l=c,c=Ns(n,h+1),!(!l||!c)){if(Yr(t[h],0,JM)){e[h]=e[h+1]=0;continue}s=e[h]/t[h],r=e[h+1]/t[h],a=Math.pow(s,2)+Math.pow(r,2),!(a<=9)&&(o=3/Math.sqrt(a),e[h]=s*o*t[h],e[h+1]=r*o*t[h])}}function tw(n,t,e="x"){const i=tm(e),s=n.length;let r,o,a,l=Ns(n,0);for(let c=0;c<s;++c){if(o=a,a=l,l=Ns(n,c+1),!a)continue;const h=a[e],u=a[i];o&&(r=(h-o[e])/3,a[`cp1${e}`]=h-r,a[`cp1${i}`]=u-r*t[c]),l&&(r=(l[e]-h)/3,a[`cp2${e}`]=h+r,a[`cp2${i}`]=u+r*t[c])}}function ew(n,t="x"){const e=tm(t),i=n.length,s=Array(i).fill(0),r=Array(i);let o,a,l,c=Ns(n,0);for(o=0;o<i;++o)if(a=l,l=c,c=Ns(n,o+1),!!l){if(c){const h=c[t]-l[t];s[o]=h!==0?(c[e]-l[e])/h:0}r[o]=a?c?Pn(s[o-1])!==Pn(s[o])?0:(s[o-1]+s[o])/2:s[o-1]:s[o]}QM(n,s,r),tw(n,r,t)}function Na(n,t,e){return Math.max(Math.min(n,e),t)}function nw(n,t){let e,i,s,r,o,a=Zi(n[0],t);for(e=0,i=n.length;e<i;++e)o=r,r=a,a=e<i-1&&Zi(n[e+1],t),!!r&&(s=n[e],o&&(s.cp1x=Na(s.cp1x,t.left,t.right),s.cp1y=Na(s.cp1y,t.top,t.bottom)),a&&(s.cp2x=Na(s.cp2x,t.left,t.right),s.cp2y=Na(s.cp2y,t.top,t.bottom)))}function iw(n,t,e,i,s){let r,o,a,l;if(t.spanGaps&&(n=n.filter(c=>!c.skip)),t.cubicInterpolationMode==="monotone")ew(n,s);else{let c=i?n[n.length-1]:n[0];for(r=0,o=n.length;r<o;++r)a=n[r],l=KM(c,a,n[Math.min(r+1,o-(i?0:1))%o],t.tension),a.cp1x=l.previous.x,a.cp1y=l.previous.y,a.cp2x=l.next.x,a.cp2y=l.next.y,c=a}t.capBezierPoints&&nw(n,e)}function em(){return typeof window!="undefined"&&typeof document!="undefined"}function _h(n){let t=n.parentNode;return t&&t.toString()==="[object ShadowRoot]"&&(t=t.host),t}function za(n,t,e){let i;return typeof n=="string"?(i=parseInt(n,10),n.indexOf("%")!==-1&&(i=i/100*t.parentNode[e])):i=n,i}const Ba=n=>window.getComputedStyle(n,null);function sw(n,t){return Ba(n).getPropertyValue(t)}const rw=["top","right","bottom","left"];function Qi(n,t,e){const i={};e=e?"-"+e:"";for(let s=0;s<4;s++){const r=rw[s];i[r]=parseFloat(n[t+"-"+r+e])||0}return i.width=i.left+i.right,i.height=i.top+i.bottom,i}const ow=(n,t,e)=>(n>0||t>0)&&(!e||!e.shadowRoot);function aw(n,t){const e=n.native||n,i=e.touches,s=i&&i.length?i[0]:e,{offsetX:r,offsetY:o}=s;let a=!1,l,c;if(ow(r,o,e.target))l=r,c=o;else{const h=t.getBoundingClientRect();l=s.clientX-h.left,c=s.clientY-h.top,a=!0}return{x:l,y:c,box:a}}function nm(n,t){const{canvas:e,currentDevicePixelRatio:i}=t,s=Ba(e),r=s.boxSizing==="border-box",o=Qi(s,"padding"),a=Qi(s,"border","width"),{x:l,y:c,box:h}=aw(n,e),u=o.left+(h&&a.left),d=o.top+(h&&a.top);let{width:f,height:p}=t;return r&&(f-=o.width+a.width,p-=o.height+a.height),{x:Math.round((l-u)/f*e.width/i),y:Math.round((c-d)/p*e.height/i)}}function lw(n,t,e){let i,s;if(t===void 0||e===void 0){const r=_h(n);if(!r)t=n.clientWidth,e=n.clientHeight;else{const o=r.getBoundingClientRect(),a=Ba(r),l=Qi(a,"border","width"),c=Qi(a,"padding");t=o.width-c.width-l.width,e=o.height-c.height-l.height,i=za(a.maxWidth,r,"clientWidth"),s=za(a.maxHeight,r,"clientHeight")}}return{width:t,height:e,maxWidth:i||Ta,maxHeight:s||Ta}}const yh=n=>Math.round(n*10)/10;function cw(n,t,e,i){const s=Ba(n),r=Qi(s,"margin"),o=za(s.maxWidth,n,"clientWidth")||Ta,a=za(s.maxHeight,n,"clientHeight")||Ta,l=lw(n,t,e);let{width:c,height:h}=l;if(s.boxSizing==="content-box"){const u=Qi(s,"border","width"),d=Qi(s,"padding");c-=d.width+u.width,h-=d.height+u.height}return c=Math.max(0,c-r.width),h=Math.max(0,i?Math.floor(c/i):h-r.height),c=yh(Math.min(c,o,l.maxWidth)),h=yh(Math.min(h,a,l.maxHeight)),c&&!h&&(h=yh(c/2)),{width:c,height:h}}function im(n,t,e){const i=t||1,s=Math.floor(n.height*i),r=Math.floor(n.width*i);n.height=s/i,n.width=r/i;const o=n.canvas;return o.style&&(e||!o.style.height&&!o.style.width)&&(o.style.height=`${n.height}px`,o.style.width=`${n.width}px`),n.currentDevicePixelRatio!==i||o.height!==s||o.width!==r?(n.currentDevicePixelRatio=i,o.height=s,o.width=r,n.ctx.setTransform(i,0,0,i,0,0),!0):!1}const hw=function(){let n=!1;try{const t={get passive(){return n=!0,!1}};window.addEventListener("test",null,t),window.removeEventListener("test",null,t)}catch{}return n}();function sm(n,t){const e=sw(n,t),i=e&&e.match(/^(\d+)(\.\d+)?px$/);return i?+i[1]:void 0}function ts(n,t,e,i){return{x:n.x+e*(t.x-n.x),y:n.y+e*(t.y-n.y)}}function uw(n,t,e,i){return{x:n.x+e*(t.x-n.x),y:i==="middle"?e<.5?n.y:t.y:i==="after"?e<1?n.y:t.y:e>0?t.y:n.y}}function dw(n,t,e,i){const s={x:n.cp2x,y:n.cp2y},r={x:t.cp1x,y:t.cp1y},o=ts(n,s,e),a=ts(s,r,e),l=ts(r,t,e),c=ts(o,a,e),h=ts(a,l,e);return ts(c,h,e)}const rm=new Map;function fw(n,t){t=t||{};const e=n+JSON.stringify(t);let i=rm.get(e);return i||(i=new Intl.NumberFormat(n,t),rm.set(e,i)),i}function no(n,t,e){return fw(t,e).format(n)}const pw=function(n,t){return{x(e){return n+n+t-e},setWidth(e){t=e},textAlign(e){return e==="center"?e:e==="right"?"left":"right"},xPlus(e,i){return e-i},leftForLtr(e,i){return e-i}}},mw=function(){return{x(n){return n},setWidth(n){},textAlign(n){return n},xPlus(n,t){return n+t},leftForLtr(n,t){return n}}};function zs(n,t,e){return n?pw(t,e):mw()}function om(n,t){let e,i;(t==="ltr"||t==="rtl")&&(e=n.canvas.style,i=[e.getPropertyValue("direction"),e.getPropertyPriority("direction")],e.setProperty("direction",t,"important"),n.prevTextDirection=i)}function am(n,t){t!==void 0&&(delete n.prevTextDirection,n.canvas.style.setProperty("direction",t[0],t[1]))}function lm(n){return n==="angle"?{between:Zr,compare:oM,normalize:mn}:{between:di,compare:(t,e)=>t-e,normalize:t=>t}}function cm({start:n,end:t,count:e,loop:i,style:s}){return{start:n%e,end:t%e,loop:i&&(t-n+1)%e==0,style:s}}function gw(n,t,e){const{property:i,start:s,end:r}=e,{between:o,normalize:a}=lm(i),l=t.length;let{start:c,end:h,loop:u}=n,d,f;if(u){for(c+=l,h+=l,d=0,f=l;d<f&&o(a(t[c%l][i]),s,r);++d)c--,h--;c%=l,h%=l}return h<c&&(h+=l),{start:c,end:h,loop:u,style:n.style}}function xw(n,t,e){if(!e)return[n];const{property:i,start:s,end:r}=e,o=t.length,{compare:a,between:l,normalize:c}=lm(i),{start:h,end:u,loop:d,style:f}=gw(n,t,e),p=[];let x=!1,_=null,m,g,S;const v=()=>l(s,S,m)&&a(s,S)!==0,E=()=>a(r,m)===0||l(r,S,m),R=()=>x||v(),D=()=>!x||E();for(let $=h,it=h;$<=u;++$)g=t[$%o],!g.skip&&(m=c(g[i]),m!==S&&(x=l(m,s,r),_===null&&R()&&(_=a(m,s)===0?$:it),_!==null&&D()&&(p.push(cm({start:_,end:$,loop:d,count:o,style:f})),_=null),it=$,S=m));return _!==null&&p.push(cm({start:_,end:u,loop:d,count:o,style:f})),p}function _w(n,t){const e=[],i=n.segments;for(let s=0;s<i.length;s++){const r=xw(i[s],n.points,t);r.length&&e.push(...r)}return e}function yw(n,t,e,i){let s=0,r=t-1;if(e&&!i)for(;s<t&&!n[s].skip;)s++;for(;s<t&&n[s].skip;)s++;for(s%=t,e&&(r+=s);r>s&&n[r%t].skip;)r--;return r%=t,{start:s,end:r}}function vw(n,t,e,i){const s=n.length,r=[];let o=t,a=n[t],l;for(l=t+1;l<=e;++l){const c=n[l%s];c.skip||c.stop?a.skip||(i=!1,r.push({start:t%s,end:(l-1)%s,loop:i}),t=o=c.stop?l:null):(o=l,a.skip&&(t=l)),a=c}return o!==null&&r.push({start:t%s,end:o%s,loop:i}),r}function bw(n,t){const e=n.points,i=n.options.spanGaps,s=e.length;if(!s)return[];const r=!!n._loop,{start:o,end:a}=yw(e,s,r,i);if(i===!0)return hm(n,[{start:o,end:a,loop:r}],e,t);const l=a<o?a+s:a,c=!!n._fullLoop&&o===0&&a===s-1;return hm(n,vw(e,o,l,c),e,t)}function hm(n,t,e,i){return!i||!i.setContext||!e?t:Mw(n,t,e,i)}function Mw(n,t,e,i){const s=n._chart.getContext(),r=um(n.options),{_datasetIndex:o,options:{spanGaps:a}}=n,l=e.length,c=[];let h=r,u=t[0].start,d=u;function f(p,x,_,m){const g=a?-1:1;if(p!==x){for(p+=l;e[p%l].skip;)p-=g;for(;e[x%l].skip;)x+=g;p%l!=x%l&&(c.push({start:p%l,end:x%l,loop:_,style:m}),h=m,u=x%l)}}for(const p of t){u=a?u:p.start;let x=e[u%l],_;for(d=u+1;d<=p.end;d++){const m=e[d%l];_=um(i.setContext(fi(s,{type:"segment",p0:x,p1:m,p0DataIndex:(d-1)%l,p1DataIndex:d%l,datasetIndex:o}))),ww(_,h)&&f(u,d-1,p.loop,h),x=m,h=_}u<d-1&&f(u,d-1,p.loop,h)}return c}function um(n){return{backgroundColor:n.backgroundColor,borderCapStyle:n.borderCapStyle,borderDash:n.borderDash,borderDashOffset:n.borderDashOffset,borderJoinStyle:n.borderJoinStyle,borderWidth:n.borderWidth,borderColor:n.borderColor}}function ww(n,t){return t&&JSON.stringify(n)!==JSON.stringify(t)}/*!
 * Chart.js v3.7.0
 * https://www.chartjs.org
 * (c) 2021 Chart.js Contributors
 * Released under the MIT License
 */class Sw{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(t,e,i,s){const r=e.listeners[s],o=e.duration;r.forEach(a=>a({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))}_refresh(){this._request||(this._running=!0,this._request=vp.call(window,()=>{this._update(),this._request=null,this._running&&this._refresh()}))}_update(t=Date.now()){let e=0;this._charts.forEach((i,s)=>{if(!i.running||!i.items.length)return;const r=i.items;let o=r.length-1,a=!1,l;for(;o>=0;--o)l=r[o],l._active?(l._total>i.duration&&(i.duration=l._total),l.tick(t),a=!0):(r[o]=r[r.length-1],r.pop());a&&(s.draw(),this._notify(s,i,t,"progress")),r.length||(i.running=!1,this._notify(s,i,t,"complete"),i.initial=!1),e+=r.length}),this._lastDate=t,e===0&&(this._running=!1)}_getAnims(t){const e=this._charts;let i=e.get(t);return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}listen(t,e,i){this._getAnims(t).listeners[e].push(i)}add(t,e){!e||!e.length||this._getAnims(t).items.push(...e)}has(t){return this._getAnims(t).items.length>0}start(t){const e=this._charts.get(t);!e||(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((i,s)=>Math.max(i,s._duration),0),this._refresh())}running(t){if(!this._running)return!1;const e=this._charts.get(t);return!(!e||!e.running||!e.items.length)}stop(t){const e=this._charts.get(t);if(!e||!e.items.length)return;const i=e.items;let s=i.length-1;for(;s>=0;--s)i[s].cancel();e.items=[],this._notify(t,e,Date.now(),"complete")}remove(t){return this._charts.delete(t)}}var jn=new Sw;const dm="transparent",Ew={boolean(n,t,e){return e>.5?t:n},color(n,t,e){const i=Vp(n||dm),s=i.valid&&Vp(t||dm);return s&&s.valid?s.mix(i,e).hexString():t},number(n,t,e){return n+(t-n)*e}};class Tw{constructor(t,e,i,s){const r=e[i];s=ka([t.to,s,r,t.from]);const o=ka([t.from,r,s]);this._active=!0,this._fn=t.fn||Ew[t.type||typeof o],this._easing=Jr[t.easing]||Jr.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}active(){return this._active}update(t,e,i){if(this._active){this._notify(!1);const s=this._target[this._prop],r=i-this._start,o=this._duration-r;this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=r,this._loop=!!t.loop,this._to=ka([t.to,e,s,t.from]),this._from=ka([t.from,s,e])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(t){const e=t-this._start,i=this._duration,s=this._prop,r=this._from,o=this._loop,a=this._to;let l;if(this._active=r!==a&&(o||e<i),!this._active){this._target[s]=a,this._notify(!0);return}if(e<0){this._target[s]=r;return}l=e/i%2,l=o&&l>1?2-l:l,l=this._easing(Math.min(1,Math.max(0,l))),this._target[s]=this._fn(r,a,l)}wait(){const t=this._promises||(this._promises=[]);return new Promise((e,i)=>{t.push({res:e,rej:i})})}_notify(t){const e=t?"res":"rej",i=this._promises||[];for(let s=0;s<i.length;s++)i[s][e]()}}const Aw=["x","y","borderWidth","radius","tension"],Cw=["color","borderColor","backgroundColor"];Bt.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0});const Lw=Object.keys(Bt.animation);Bt.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:n=>n!=="onProgress"&&n!=="onComplete"&&n!=="fn"});Bt.set("animations",{colors:{type:"color",properties:Cw},numbers:{type:"number",properties:Aw}});Bt.describe("animations",{_fallback:"animation"});Bt.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:n=>n|0}}}});class fm{constructor(t,e){this._chart=t,this._properties=new Map,this.configure(e)}configure(t){if(!Wt(t))return;const e=this._properties;Object.getOwnPropertyNames(t).forEach(i=>{const s=t[i];if(!Wt(s))return;const r={};for(const o of Lw)r[o]=s[o];(re(s.properties)&&s.properties||[i]).forEach(o=>{(o===i||!e.has(o))&&e.set(o,r)})})}_animateOptions(t,e){const i=e.options,s=Pw(t,i);if(!s)return[];const r=this._createAnimations(s,i);return i.$shared&&Rw(t.options.$animations,i).then(()=>{t.options=i},()=>{}),r}_createAnimations(t,e){const i=this._properties,s=[],r=t.$animations||(t.$animations={}),o=Object.keys(e),a=Date.now();let l;for(l=o.length-1;l>=0;--l){const c=o[l];if(c.charAt(0)==="$")continue;if(c==="options"){s.push(...this._animateOptions(t,e));continue}const h=e[c];let u=r[c];const d=i.get(c);if(u)if(d&&u.active()){u.update(d,h,a);continue}else u.cancel();if(!d||!d.duration){t[c]=h;continue}r[c]=u=new Tw(d,t,c,h),s.push(u)}return s}update(t,e){if(this._properties.size===0){Object.assign(t,e);return}const i=this._createAnimations(t,e);if(i.length)return jn.add(this._chart,i),!0}}function Rw(n,t){const e=[],i=Object.keys(t);for(let s=0;s<i.length;s++){const r=n[i[s]];r&&r.active()&&e.push(r.wait())}return Promise.all(e)}function Pw(n,t){if(!t)return;let e=n.options;if(!e){n.options=t;return}return e.$shared&&(n.options=e=Object.assign({},e,{$shared:!1,$animations:{}})),e}function pm(n,t){const e=n&&n.options||{},i=e.reverse,s=e.min===void 0?t:0,r=e.max===void 0?t:0;return{start:i?r:s,end:i?s:r}}function Dw(n,t,e){if(e===!1)return!1;const i=pm(n,e),s=pm(t,e);return{top:s.end,right:i.end,bottom:s.start,left:i.start}}function Iw(n){let t,e,i,s;return Wt(n)?(t=n.top,e=n.right,i=n.bottom,s=n.left):t=e=i=s=n,{top:t,right:e,bottom:i,left:s,disabled:n===!1}}function mm(n,t){const e=[],i=n._getSortedDatasetMetas(t);let s,r;for(s=0,r=i.length;s<r;++s)e.push(i[s].index);return e}function gm(n,t,e,i={}){const s=n.keys,r=i.mode==="single";let o,a,l,c;if(t!==null){for(o=0,a=s.length;o<a;++o){if(l=+s[o],l===e){if(i.all)continue;break}c=n.values[l],Ae(c)&&(r||t===0||Pn(t)===Pn(c))&&(t+=c)}return t}}function Fw(n){const t=Object.keys(n),e=new Array(t.length);let i,s,r;for(i=0,s=t.length;i<s;++i)r=t[i],e[i]={x:r,y:n[r]};return e}function xm(n,t){const e=n&&n.options.stacked;return e||e===void 0&&t.stack!==void 0}function Ow(n,t,e){return`${n.id}.${t.id}.${e.stack||e.type}`}function kw(n){const{min:t,max:e,minDefined:i,maxDefined:s}=n.getUserBounds();return{min:i?t:Number.NEGATIVE_INFINITY,max:s?e:Number.POSITIVE_INFINITY}}function Nw(n,t,e){const i=n[t]||(n[t]={});return i[e]||(i[e]={})}function _m(n,t,e,i){for(const s of t.getMatchingVisibleMetas(i).reverse()){const r=n[s.index];if(e&&r>0||!e&&r<0)return s.index}return null}function ym(n,t){const{chart:e,_cachedMeta:i}=n,s=e._stacks||(e._stacks={}),{iScale:r,vScale:o,index:a}=i,l=r.axis,c=o.axis,h=Ow(r,o,i),u=t.length;let d;for(let f=0;f<u;++f){const p=t[f],{[l]:x,[c]:_}=p,m=p._stacks||(p._stacks={});d=m[c]=Nw(s,h,x),d[a]=_,d._top=_m(d,o,!0,i.type),d._bottom=_m(d,o,!1,i.type)}}function vh(n,t){const e=n.scales;return Object.keys(e).filter(i=>e[i].axis===t).shift()}function zw(n,t){return fi(n,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}function Bw(n,t,e){return fi(n,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:e,index:t,mode:"default",type:"data"})}function io(n,t){const e=n.controller.index,i=n.vScale&&n.vScale.axis;if(!!i){t=t||n._parsed;for(const s of t){const r=s._stacks;if(!r||r[i]===void 0||r[i][e]===void 0)return;delete r[i][e]}}}const bh=n=>n==="reset"||n==="none",vm=(n,t)=>t?n:Object.assign({},n),Hw=(n,t,e)=>n&&!t.hidden&&t._stacked&&{keys:mm(e,!0),values:null};class Dn{constructor(t,e){this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.$context=void 0,this._syncList=[],this.initialize()}initialize(){const t=this._cachedMeta;this.configure(),this.linkScales(),t._stacked=xm(t.vScale,t),this.addElements()}updateIndex(t){this.index!==t&&io(this._cachedMeta),this.index=t}linkScales(){const t=this.chart,e=this._cachedMeta,i=this.getDataset(),s=(u,d,f,p)=>u==="x"?d:u==="r"?p:f,r=e.xAxisID=Ot(i.xAxisID,vh(t,"x")),o=e.yAxisID=Ot(i.yAxisID,vh(t,"y")),a=e.rAxisID=Ot(i.rAxisID,vh(t,"r")),l=e.indexAxis,c=e.iAxisID=s(l,r,o,a),h=e.vAxisID=s(l,o,r,a);e.xScale=this.getScaleForId(r),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(a),e.iScale=this.getScaleForId(c),e.vScale=this.getScaleForId(h)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(t){return this.chart.scales[t]}_getOtherScale(t){const e=this._cachedMeta;return t===e.iScale?e.vScale:e.iScale}reset(){this._update("reset")}_destroy(){const t=this._cachedMeta;this._data&&qp(this._data,this),t._stacked&&io(t)}_dataCheck(){const t=this.getDataset(),e=t.data||(t.data=[]),i=this._data;if(Wt(e))this._data=Fw(e);else if(i!==e){if(i){qp(i,this);const s=this._cachedMeta;io(s),s._parsed=[]}e&&Object.isExtensible(e)&&UM(e,this),this._syncList=[],this._data=e}}addElements(){const t=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(t.dataset=new this.datasetElementType)}buildOrUpdateElements(t){const e=this._cachedMeta,i=this.getDataset();let s=!1;this._dataCheck();const r=e._stacked;e._stacked=xm(e.vScale,e),e.stack!==i.stack&&(s=!0,io(e),e.stack=i.stack),this._resyncElements(t),(s||r!==e._stacked)&&ym(this,e._parsed)}configure(){const t=this.chart.config,e=t.datasetScopeKeys(this._type),i=t.getOptionScopes(this.getDataset(),e,!0);this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(t,e){const{_cachedMeta:i,_data:s}=this,{iScale:r,_stacked:o}=i,a=r.axis;let l=t===0&&e===s.length?!0:i._sorted,c=t>0&&i._parsed[t-1],h,u,d;if(this._parsing===!1)i._parsed=s,i._sorted=!0,d=s;else{re(s[t])?d=this.parseArrayData(i,s,t,e):Wt(s[t])?d=this.parseObjectData(i,s,t,e):d=this.parsePrimitiveData(i,s,t,e);const f=()=>u[a]===null||c&&u[a]<c[a];for(h=0;h<e;++h)i._parsed[h+t]=u=d[h],l&&(f()&&(l=!1),c=u);i._sorted=l}o&&ym(this,d)}parsePrimitiveData(t,e,i,s){const{iScale:r,vScale:o}=t,a=r.axis,l=o.axis,c=r.getLabels(),h=r===o,u=new Array(s);let d,f,p;for(d=0,f=s;d<f;++d)p=d+i,u[d]={[a]:h||r.parse(c[p],p),[l]:o.parse(e[p],p)};return u}parseArrayData(t,e,i,s){const{xScale:r,yScale:o}=t,a=new Array(s);let l,c,h,u;for(l=0,c=s;l<c;++l)h=l+i,u=e[h],a[l]={x:r.parse(u[0],h),y:o.parse(u[1],h)};return a}parseObjectData(t,e,i,s){const{xScale:r,yScale:o}=t,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=new Array(s);let h,u,d,f;for(h=0,u=s;h<u;++h)d=h+i,f=e[d],c[h]={x:r.parse(Xi(f,a),d),y:o.parse(Xi(f,l),d)};return c}getParsed(t){return this._cachedMeta._parsed[t]}getDataElement(t){return this._cachedMeta.data[t]}applyStack(t,e,i){const s=this.chart,r=this._cachedMeta,o=e[t.axis],a={keys:mm(s,!0),values:e._stacks[t.axis]};return gm(a,o,r.index,{mode:i})}updateRangeFromParsed(t,e,i,s){const r=i[e.axis];let o=r===null?NaN:r;const a=s&&i._stacks[e.axis];s&&a&&(s.values=a,o=gm(s,r,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}getMinMax(t,e){const i=this._cachedMeta,s=i._parsed,r=i._sorted&&t===i.iScale,o=s.length,a=this._getOtherScale(t),l=Hw(e,i,this.chart),c={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:h,max:u}=kw(a);let d,f;function p(){f=s[d];const x=f[a.axis];return!Ae(f[t.axis])||h>x||u<x}for(d=0;d<o&&!(!p()&&(this.updateRangeFromParsed(c,t,f,l),r));++d);if(r){for(d=o-1;d>=0;--d)if(!p()){this.updateRangeFromParsed(c,t,f,l);break}}return c}getAllParsedValues(t){const e=this._cachedMeta._parsed,i=[];let s,r,o;for(s=0,r=e.length;s<r;++s)o=e[s][t.axis],Ae(o)&&i.push(o);return i}getMaxOverflow(){return!1}getLabelAndValue(t){const e=this._cachedMeta,i=e.iScale,s=e.vScale,r=this.getParsed(t);return{label:i?""+i.getLabelForValue(r[i.axis]):"",value:s?""+s.getLabelForValue(r[s.axis]):""}}_update(t){const e=this._cachedMeta;this.update(t||"default"),e._clip=Iw(Ot(this.options.clip,Dw(e.xScale,e.yScale,this.getMaxOverflow())))}update(t){}draw(){const t=this._ctx,e=this.chart,i=this._cachedMeta,s=i.data||[],r=e.chartArea,o=[],a=this._drawStart||0,l=this._drawCount||s.length-a,c=this.options.drawActiveElementsOnTop;let h;for(i.dataset&&i.dataset.draw(t,r,a,l),h=a;h<a+l;++h){const u=s[h];u.hidden||(u.active&&c?o.push(u):u.draw(t,r))}for(h=0;h<o.length;++h)o[h].draw(t,r)}getStyle(t,e){const i=e?"active":"default";return t===void 0&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}getContext(t,e,i){const s=this.getDataset();let r;if(t>=0&&t<this._cachedMeta.data.length){const o=this._cachedMeta.data[t];r=o.$context||(o.$context=Bw(this.getContext(),t,o)),r.parsed=this.getParsed(t),r.raw=s.data[t],r.index=r.dataIndex=t}else r=this.$context||(this.$context=zw(this.chart.getContext(),this.index)),r.dataset=s,r.index=r.datasetIndex=this.index;return r.active=!!e,r.mode=i,r}resolveDatasetElementOptions(t){return this._resolveElementOptions(this.datasetElementType.id,t)}resolveDataElementOptions(t,e){return this._resolveElementOptions(this.dataElementType.id,e,t)}_resolveElementOptions(t,e="default",i){const s=e==="active",r=this._cachedDataOpts,o=t+"-"+e,a=r[o],l=this.enableOptionSharing&&nn(i);if(a)return vm(a,l);const c=this.chart.config,h=c.datasetElementScopeKeys(this._type,t),u=s?[`${t}Hover`,"hover",t,""]:[t,""],d=c.getOptionScopes(this.getDataset(),h),f=Object.keys(Bt.elements[t]),p=()=>this.getContext(i,s),x=c.resolveNamedOptions(d,f,p,u);return x.$shared&&(x.$shared=l,r[o]=Object.freeze(vm(x,l))),x}_resolveAnimations(t,e,i){const s=this.chart,r=this._cachedDataOpts,o=`animation-${e}`,a=r[o];if(a)return a;let l;if(s.options.animation!==!1){const h=this.chart.config,u=h.datasetAnimationScopeKeys(this._type,e),d=h.getOptionScopes(this.getDataset(),u);l=h.createResolver(d,this.getContext(t,i,e))}const c=new fm(s,l&&l.animations);return l&&l._cacheable&&(r[o]=Object.freeze(c)),c}getSharedOptions(t){if(!!t.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}includeOptions(t,e){return!e||bh(t)||this.chart._animationsDisabled}updateElement(t,e,i,s){bh(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}updateSharedOptions(t,e,i){t&&!bh(e)&&this._resolveAnimations(void 0,e).update(t,i)}_setStyle(t,e,i,s){t.active=s;const r=this.getStyle(e,s);this._resolveAnimations(e,i,s).update(t,{options:!s&&this.getSharedOptions(r)||r})}removeHoverStyle(t,e,i){this._setStyle(t,i,"active",!1)}setHoverStyle(t,e,i){this._setStyle(t,i,"active",!0)}_removeDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!1)}_setDatasetHoverStyle(){const t=this._cachedMeta.dataset;t&&this._setStyle(t,void 0,"active",!0)}_resyncElements(t){const e=this._data,i=this._cachedMeta.data;for(const[a,l,c]of this._syncList)this[a](l,c);this._syncList=[];const s=i.length,r=e.length,o=Math.min(r,s);o&&this.parse(0,o),r>s?this._insertElements(s,r-s,t):r<s&&this._removeElements(r,s-r)}_insertElements(t,e,i=!0){const s=this._cachedMeta,r=s.data,o=t+e;let a;const l=c=>{for(c.length+=e,a=c.length-1;a>=o;a--)c[a]=c[a-e]};for(l(r),a=t;a<o;++a)r[a]=new this.dataElementType;this._parsing&&l(s._parsed),this.parse(t,e),i&&this.updateElements(r,t,e,"reset")}updateElements(t,e,i,s){}_removeElements(t,e){const i=this._cachedMeta;if(this._parsing){const s=i._parsed.splice(t,e);i._stacked&&io(i,s)}i.data.splice(t,e)}_sync(t){if(this._parsing)this._syncList.push(t);else{const[e,i,s]=t;this[e](i,s)}this.chart._dataChanges.push([this.index,...t])}_onDataPush(){const t=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-t,t])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(t,e){e&&this._sync(["_removeElements",t,e]);const i=arguments.length-2;i&&this._sync(["_insertElements",t,i])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}Dn.defaults={};Dn.prototype.datasetElementType=null;Dn.prototype.dataElementType=null;function Uw(n,t){if(!n._cache.$bar){const e=n.getMatchingVisibleMetas(t);let i=[];for(let s=0,r=e.length;s<r;s++)i=i.concat(e[s].controller.getAllParsedValues(n));n._cache.$bar=Xp(i.sort((s,r)=>s-r))}return n._cache.$bar}function Vw(n){const t=n.iScale,e=Uw(t,n.type);let i=t._length,s,r,o,a;const l=()=>{o===32767||o===-32768||(nn(a)&&(i=Math.min(i,Math.abs(o-a)||i)),a=o)};for(s=0,r=e.length;s<r;++s)o=t.getPixelForValue(e[s]),l();for(a=void 0,s=0,r=t.ticks.length;s<r;++s)o=t.getPixelForTick(s),l();return i}function Ww(n,t,e,i){const s=e.barThickness;let r,o;return $t(s)?(r=t.min*e.categoryPercentage,o=e.barPercentage):(r=s*i,o=1),{chunk:r/i,ratio:o,start:t.pixels[n]-r/2}}function Gw(n,t,e,i){const s=t.pixels,r=s[n];let o=n>0?s[n-1]:null,a=n<s.length-1?s[n+1]:null;const l=e.categoryPercentage;o===null&&(o=r-(a===null?t.end-t.start:a-r)),a===null&&(a=r+r-o);const c=r-(r-Math.min(o,a))/2*l;return{chunk:Math.abs(a-o)/2*l/i,ratio:e.barPercentage,start:c}}function jw(n,t,e,i){const s=e.parse(n[0],i),r=e.parse(n[1],i),o=Math.min(s,r),a=Math.max(s,r);let l=o,c=a;Math.abs(o)>Math.abs(a)&&(l=a,c=o),t[e.axis]=c,t._custom={barStart:l,barEnd:c,start:s,end:r,min:o,max:a}}function bm(n,t,e,i){return re(n)?jw(n,t,e,i):t[e.axis]=e.parse(n,i),t}function Mm(n,t,e,i){const s=n.iScale,r=n.vScale,o=s.getLabels(),a=s===r,l=[];let c,h,u,d;for(c=e,h=e+i;c<h;++c)d=t[c],u={},u[s.axis]=a||s.parse(o[c],c),l.push(bm(d,u,r,c));return l}function Mh(n){return n&&n.barStart!==void 0&&n.barEnd!==void 0}function qw(n,t,e){return n!==0?Pn(n):(t.isHorizontal()?1:-1)*(t.min>=e?1:-1)}function Xw(n){let t,e,i,s,r;return n.horizontal?(t=n.base>n.x,e="left",i="right"):(t=n.base<n.y,e="bottom",i="top"),t?(s="end",r="start"):(s="start",r="end"),{start:e,end:i,reverse:t,top:s,bottom:r}}function $w(n,t,e,i){let s=t.borderSkipped;const r={};if(!s){n.borderSkipped=r;return}const{start:o,end:a,reverse:l,top:c,bottom:h}=Xw(n);s==="middle"&&e&&(n.enableBorderRadius=!0,(e._top||0)===i?s=c:(e._bottom||0)===i?s=h:(r[wm(h,o,a,l)]=!0,s=c)),r[wm(s,o,a,l)]=!0,n.borderSkipped=r}function wm(n,t,e,i){return i?(n=Yw(n,t,e),n=Sm(n,e,t)):n=Sm(n,t,e),n}function Yw(n,t,e){return n===t?e:n===e?t:n}function Sm(n,t,e){return n==="start"?t:n==="end"?e:n}function Zw(n,{inflateAmount:t},e){n.inflateAmount=t==="auto"?e===1?.33:0:t}class wh extends Dn{parsePrimitiveData(t,e,i,s){return Mm(t,e,i,s)}parseArrayData(t,e,i,s){return Mm(t,e,i,s)}parseObjectData(t,e,i,s){const{iScale:r,vScale:o}=t,{xAxisKey:a="x",yAxisKey:l="y"}=this._parsing,c=r.axis==="x"?a:l,h=o.axis==="x"?a:l,u=[];let d,f,p,x;for(d=i,f=i+s;d<f;++d)x=e[d],p={},p[r.axis]=r.parse(Xi(x,c),d),u.push(bm(Xi(x,h),p,o,d));return u}updateRangeFromParsed(t,e,i,s){super.updateRangeFromParsed(t,e,i,s);const r=i._custom;r&&e===this._cachedMeta.vScale&&(t.min=Math.min(t.min,r.min),t.max=Math.max(t.max,r.max))}getMaxOverflow(){return 0}getLabelAndValue(t){const e=this._cachedMeta,{iScale:i,vScale:s}=e,r=this.getParsed(t),o=r._custom,a=Mh(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(r[s.axis]);return{label:""+i.getLabelForValue(r[i.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();const t=this._cachedMeta;t.stack=this.getDataset().stack}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,s){const r=s==="reset",{index:o,_cachedMeta:{vScale:a}}=this,l=a.getBasePixel(),c=a.isHorizontal(),h=this._getRuler(),u=this.resolveDataElementOptions(e,s),d=this.getSharedOptions(u),f=this.includeOptions(s,d);this.updateSharedOptions(d,s,u);for(let p=e;p<e+i;p++){const x=this.getParsed(p),_=r||$t(x[a.axis])?{base:l,head:l}:this._calculateBarValuePixels(p),m=this._calculateBarIndexPixels(p,h),g=(x._stacks||{})[a.axis],S={horizontal:c,base:_.base,enableBorderRadius:!g||Mh(x._custom)||o===g._top||o===g._bottom,x:c?_.head:m.center,y:c?m.center:_.head,height:c?m.size:Math.abs(_.size),width:c?Math.abs(_.size):m.size};f&&(S.options=d||this.resolveDataElementOptions(p,t[p].active?"active":s));const v=S.options||t[p].options;$w(S,v,g,o),Zw(S,v,h.ratio),this.updateElement(t[p],p,S,s)}}_getStacks(t,e){const s=this._cachedMeta.iScale,r=s.getMatchingVisibleMetas(this._type),o=s.options.stacked,a=r.length,l=[];let c,h;for(c=0;c<a;++c)if(h=r[c],!!h.controller.options.grouped){if(typeof e!="undefined"){const u=h.controller.getParsed(e)[h.controller._cachedMeta.vScale.axis];if($t(u)||isNaN(u))continue}if((o===!1||l.indexOf(h.stack)===-1||o===void 0&&h.stack===void 0)&&l.push(h.stack),h.index===t)break}return l.length||l.push(void 0),l}_getStackCount(t){return this._getStacks(void 0,t).length}_getStackIndex(t,e,i){const s=this._getStacks(t,i),r=e!==void 0?s.indexOf(e):-1;return r===-1?s.length-1:r}_getRuler(){const t=this.options,e=this._cachedMeta,i=e.iScale,s=[];let r,o;for(r=0,o=e.data.length;r<o;++r)s.push(i.getPixelForValue(this.getParsed(r)[i.axis],r));const a=t.barThickness;return{min:a||Vw(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}_calculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i},options:{base:s,minBarLength:r}}=this,o=s||0,a=this.getParsed(t),l=a._custom,c=Mh(l);let h=a[e.axis],u=0,d=i?this.applyStack(e,a,i):h,f,p;d!==h&&(u=d-h,d=h),c&&(h=l.barStart,d=l.barEnd-l.barStart,h!==0&&Pn(h)!==Pn(l.barEnd)&&(u=0),u+=h);const x=!$t(s)&&!c?s:u;let _=e.getPixelForValue(x);if(this.chart.getDataVisibility(t)?f=e.getPixelForValue(u+d):f=_,p=f-_,Math.abs(p)<r&&(p=qw(p,e,o)*r,h===o&&(_-=p/2),f=_+p),_===e.getPixelForValue(o)){const m=Pn(p)*e.getLineWidthForValue(o)/2;_+=m,p-=m}return{size:p,base:_,head:f,center:f+p/2}}_calculateBarIndexPixels(t,e){const i=e.scale,s=this.options,r=s.skipNull,o=Ot(s.maxBarThickness,1/0);let a,l;if(e.grouped){const c=r?this._getStackCount(t):e.stackCount,h=s.barThickness==="flex"?Gw(t,e,s,c):Ww(t,e,s,c),u=this._getStackIndex(this.index,this._cachedMeta.stack,r?t:void 0);a=h.start+h.chunk*u+h.chunk/2,l=Math.min(o,h.chunk*h.ratio)}else a=i.getPixelForValue(this.getParsed(t)[i.axis],t),l=Math.min(o,e.min*e.ratio);return{base:a-l/2,head:a+l/2,center:a,size:l}}draw(){const t=this._cachedMeta,e=t.vScale,i=t.data,s=i.length;let r=0;for(;r<s;++r)this.getParsed(r)[e.axis]!==null&&i[r].draw(this._ctx)}}wh.id="bar";wh.defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};wh.overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};class Sh extends Dn{initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(t,e,i,s){const r=super.parsePrimitiveData(t,e,i,s);for(let o=0;o<r.length;o++)r[o]._custom=this.resolveDataElementOptions(o+i).radius;return r}parseArrayData(t,e,i,s){const r=super.parseArrayData(t,e,i,s);for(let o=0;o<r.length;o++){const a=e[i+o];r[o]._custom=Ot(a[2],this.resolveDataElementOptions(o+i).radius)}return r}parseObjectData(t,e,i,s){const r=super.parseObjectData(t,e,i,s);for(let o=0;o<r.length;o++){const a=e[i+o];r[o]._custom=Ot(a&&a.r&&+a.r,this.resolveDataElementOptions(o+i).radius)}return r}getMaxOverflow(){const t=this._cachedMeta.data;let e=0;for(let i=t.length-1;i>=0;--i)e=Math.max(e,t[i].size(this.resolveDataElementOptions(i))/2);return e>0&&e}getLabelAndValue(t){const e=this._cachedMeta,{xScale:i,yScale:s}=e,r=this.getParsed(t),o=i.getLabelForValue(r.x),a=s.getLabelForValue(r.y),l=r._custom;return{label:e.label,value:"("+o+", "+a+(l?", "+l:"")+")"}}update(t){const e=this._cachedMeta.data;this.updateElements(e,0,e.length,t)}updateElements(t,e,i,s){const r=s==="reset",{iScale:o,vScale:a}=this._cachedMeta,l=this.resolveDataElementOptions(e,s),c=this.getSharedOptions(l),h=this.includeOptions(s,c),u=o.axis,d=a.axis;for(let f=e;f<e+i;f++){const p=t[f],x=!r&&this.getParsed(f),_={},m=_[u]=r?o.getPixelForDecimal(.5):o.getPixelForValue(x[u]),g=_[d]=r?a.getBasePixel():a.getPixelForValue(x[d]);_.skip=isNaN(m)||isNaN(g),h&&(_.options=this.resolveDataElementOptions(f,p.active?"active":s),r&&(_.options.radius=0)),this.updateElement(p,f,_,s)}this.updateSharedOptions(c,s,l)}resolveDataElementOptions(t,e){const i=this.getParsed(t);let s=super.resolveDataElementOptions(t,e);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const r=s.radius;return e!=="active"&&(s.radius=0),s.radius+=Ot(i&&i._custom,r),s}}Sh.id="bubble";Sh.defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}};Sh.overrides={scales:{x:{type:"linear"},y:{type:"linear"}},plugins:{tooltip:{callbacks:{title(){return""}}}}};function Jw(n,t,e){let i=1,s=1,r=0,o=0;if(t<ie){const a=n,l=a+t,c=Math.cos(a),h=Math.sin(a),u=Math.cos(l),d=Math.sin(l),f=(S,v,E)=>Zr(S,a,l,!0)?1:Math.max(v,v*e,E,E*e),p=(S,v,E)=>Zr(S,a,l,!0)?-1:Math.min(v,v*e,E,E*e),x=f(0,c,u),_=f(ue,h,d),m=p(oe,c,u),g=p(oe+ue,h,d);i=(x-m)/2,s=(_-g)/2,r=-(x+m)/2,o=-(_+g)/2}return{ratioX:i,ratioY:s,offsetX:r,offsetY:o}}class so extends Dn{constructor(t,e){super(t,e);this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(t,e){const i=this.getDataset().data,s=this._cachedMeta;if(this._parsing===!1)s._parsed=i;else{let r=l=>+i[l];if(Wt(i[t])){const{key:l="value"}=this._parsing;r=c=>+Xi(i[c],l)}let o,a;for(o=t,a=t+e;o<a;++o)s._parsed[o]=r(o)}}_getRotation(){return pn(this.options.rotation-90)}_getCircumference(){return pn(this.options.circumference)}_getRotationExtents(){let t=ie,e=-ie;for(let i=0;i<this.chart.data.datasets.length;++i)if(this.chart.isDatasetVisible(i)){const s=this.chart.getDatasetMeta(i).controller,r=s._getRotation(),o=s._getCircumference();t=Math.min(t,r),e=Math.max(e,r+o)}return{rotation:t,circumference:e-t}}update(t){const e=this.chart,{chartArea:i}=e,s=this._cachedMeta,r=s.data,o=this.getMaxBorderWidth()+this.getMaxOffset(r)+this.options.spacing,a=Math.max((Math.min(i.width,i.height)-o)/2,0),l=Math.min(Zb(this.options.cutout,a),1),c=this._getRingWeight(this.index),{circumference:h,rotation:u}=this._getRotationExtents(),{ratioX:d,ratioY:f,offsetX:p,offsetY:x}=Jw(u,h,l),_=(i.width-o)/d,m=(i.height-o)/f,g=Math.max(Math.min(_,m)/2,0),S=Mp(this.options.radius,g),v=Math.max(S*l,0),E=(S-v)/this._getVisibleDatasetWeightTotal();this.offsetX=p*S,this.offsetY=x*S,s.total=this.calculateTotal(),this.outerRadius=S-E*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-E*c,0),this.updateElements(r,0,r.length,t)}_circumference(t,e){const i=this.options,s=this._cachedMeta,r=this._getCircumference();return e&&i.animation.animateRotate||!this.chart.getDataVisibility(t)||s._parsed[t]===null||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*r/ie)}updateElements(t,e,i,s){const r=s==="reset",o=this.chart,a=o.chartArea,c=o.options.animation,h=(a.left+a.right)/2,u=(a.top+a.bottom)/2,d=r&&c.animateScale,f=d?0:this.innerRadius,p=d?0:this.outerRadius,x=this.resolveDataElementOptions(e,s),_=this.getSharedOptions(x),m=this.includeOptions(s,_);let g=this._getRotation(),S;for(S=0;S<e;++S)g+=this._circumference(S,r);for(S=e;S<e+i;++S){const v=this._circumference(S,r),E=t[S],R={x:h+this.offsetX,y:u+this.offsetY,startAngle:g,endAngle:g+v,circumference:v,outerRadius:p,innerRadius:f};m&&(R.options=_||this.resolveDataElementOptions(S,E.active?"active":s)),g+=v,this.updateElement(E,S,R,s)}this.updateSharedOptions(_,s,x)}calculateTotal(){const t=this._cachedMeta,e=t.data;let i=0,s;for(s=0;s<e.length;s++){const r=t._parsed[s];r!==null&&!isNaN(r)&&this.chart.getDataVisibility(s)&&!e[s].hidden&&(i+=Math.abs(r))}return i}calculateCircumference(t){const e=this._cachedMeta.total;return e>0&&!isNaN(t)?ie*(Math.abs(t)/e):0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],r=no(e._parsed[t],i.options.locale);return{label:s[t]||"",value:r}}getMaxBorderWidth(t){let e=0;const i=this.chart;let s,r,o,a,l;if(!t){for(s=0,r=i.data.datasets.length;s<r;++s)if(i.isDatasetVisible(s)){o=i.getDatasetMeta(s),t=o.data,a=o.controller;break}}if(!t)return 0;for(s=0,r=t.length;s<r;++s)l=a.resolveDataElementOptions(s),l.borderAlign!=="inner"&&(e=Math.max(e,l.borderWidth||0,l.hoverBorderWidth||0));return e}getMaxOffset(t){let e=0;for(let i=0,s=t.length;i<s;++i){const r=this.resolveDataElementOptions(i);e=Math.max(e,r.offset||0,r.hoverOffset||0)}return e}_getRingWeightOffset(t){let e=0;for(let i=0;i<t;++i)this.chart.isDatasetVisible(i)&&(e+=this._getRingWeight(i));return e}_getRingWeight(t){return Math.max(Ot(this.chart.data.datasets[t].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}so.id="doughnut";so.defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};so.descriptors={_scriptable:n=>n!=="spacing",_indexable:n=>n!=="spacing"};so.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(n){const t=n.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:e}}=n.legend.options;return t.labels.map((i,s)=>{const o=n.getDatasetMeta(0).controller.getStyle(s);return{text:i,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,lineWidth:o.borderWidth,pointStyle:e,hidden:!n.getDataVisibility(s),index:s}})}return[]}},onClick(n,t,e){e.chart.toggleDataVisibility(t.index),e.chart.update()}},tooltip:{callbacks:{title(){return""},label(n){let t=n.label;const e=": "+n.formattedValue;return re(t)?(t=t.slice(),t[0]+=e):t+=e,t}}}}};class Ha extends Dn{initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){const e=this._cachedMeta,{dataset:i,data:s=[],_dataset:r}=e,o=this.chart._animationsDisabled;let{start:a,count:l}=Kw(e,s,o);this._drawStart=a,this._drawCount=l,Qw(e)&&(a=0,l=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!r._decimated,i.points=s;const c=this.resolveDatasetElementOptions(t);this.options.showLine||(c.borderWidth=0),c.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:c},t),this.updateElements(s,a,l,t)}updateElements(t,e,i,s){const r=s==="reset",{iScale:o,vScale:a,_stacked:l,_dataset:c}=this._cachedMeta,h=this.resolveDataElementOptions(e,s),u=this.getSharedOptions(h),d=this.includeOptions(s,u),f=o.axis,p=a.axis,{spanGaps:x,segment:_}=this.options,m=$r(x)?x:Number.POSITIVE_INFINITY,g=this.chart._animationsDisabled||r||s==="none";let S=e>0&&this.getParsed(e-1);for(let v=e;v<e+i;++v){const E=t[v],R=this.getParsed(v),D=g?E:{},$=$t(R[p]),it=D[f]=o.getPixelForValue(R[f],v),tt=D[p]=r||$?a.getBasePixel():a.getPixelForValue(l?this.applyStack(a,R,l):R[p],v);D.skip=isNaN(it)||isNaN(tt)||$,D.stop=v>0&&R[f]-S[f]>m,_&&(D.parsed=R,D.raw=c.data[v]),d&&(D.options=u||this.resolveDataElementOptions(v,E.active?"active":s)),g||this.updateElement(E,v,D,s),S=R}this.updateSharedOptions(u,s,h)}getMaxOverflow(){const t=this._cachedMeta,e=t.dataset,i=e.options&&e.options.borderWidth||0,s=t.data||[];if(!s.length)return i;const r=s[0].size(this.resolveDataElementOptions(0)),o=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(i,r,o)/2}draw(){const t=this._cachedMeta;t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}}Ha.id="line";Ha.defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};Ha.overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};function Kw(n,t,e){const i=t.length;let s=0,r=i;if(n._sorted){const{iScale:o,_parsed:a}=n,l=o.axis,{min:c,max:h,minDefined:u,maxDefined:d}=o.getUserBounds();u&&(s=Pe(Math.min(Ki(a,o.axis,c).lo,e?i:Ki(t,l,o.getPixelForValue(c)).lo),0,i-1)),d?r=Pe(Math.max(Ki(a,o.axis,h).hi+1,e?0:Ki(t,l,o.getPixelForValue(h)).hi+1),s,i)-s:r=i-s}return{start:s,count:r}}function Qw(n){const{xScale:t,yScale:e,_scaleRanges:i}=n,s={xmin:t.min,xmax:t.max,ymin:e.min,ymax:e.max};if(!i)return n._scaleRanges=s,!0;const r=i.xmin!==t.min||i.xmax!==t.max||i.ymin!==e.min||i.ymax!==e.max;return Object.assign(i,s),r}class Eh extends Dn{constructor(t,e){super(t,e);this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(t){const e=this._cachedMeta,i=this.chart,s=i.data.labels||[],r=no(e._parsed[t].r,i.options.locale);return{label:s[t]||"",value:r}}update(t){const e=this._cachedMeta.data;this._updateRadius(),this.updateElements(e,0,e.length,t)}_updateRadius(){const t=this.chart,e=t.chartArea,i=t.options,s=Math.min(e.right-e.left,e.bottom-e.top),r=Math.max(s/2,0),o=Math.max(i.cutoutPercentage?r/100*i.cutoutPercentage:1,0),a=(r-o)/t.getVisibleDatasetCount();this.outerRadius=r-a*this.index,this.innerRadius=this.outerRadius-a}updateElements(t,e,i,s){const r=s==="reset",o=this.chart,a=this.getDataset(),c=o.options.animation,h=this._cachedMeta.rScale,u=h.xCenter,d=h.yCenter,f=h.getIndexAngle(0)-.5*oe;let p=f,x;const _=360/this.countVisibleElements();for(x=0;x<e;++x)p+=this._computeAngle(x,s,_);for(x=e;x<e+i;x++){const m=t[x];let g=p,S=p+this._computeAngle(x,s,_),v=o.getDataVisibility(x)?h.getDistanceFromCenterForValue(a.data[x]):0;p=S,r&&(c.animateScale&&(v=0),c.animateRotate&&(g=S=f));const E={x:u,y:d,innerRadius:0,outerRadius:v,startAngle:g,endAngle:S,options:this.resolveDataElementOptions(x,m.active?"active":s)};this.updateElement(m,x,E,s)}}countVisibleElements(){const t=this.getDataset(),e=this._cachedMeta;let i=0;return e.data.forEach((s,r)=>{!isNaN(t.data[r])&&this.chart.getDataVisibility(r)&&i++}),i}_computeAngle(t,e,i){return this.chart.getDataVisibility(t)?pn(this.resolveDataElementOptions(t,e).angle||i):0}}Eh.id="polarArea";Eh.defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};Eh.overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(n){const t=n.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:e}}=n.legend.options;return t.labels.map((i,s)=>{const o=n.getDatasetMeta(0).controller.getStyle(s);return{text:i,fillStyle:o.backgroundColor,strokeStyle:o.borderColor,lineWidth:o.borderWidth,pointStyle:e,hidden:!n.getDataVisibility(s),index:s}})}return[]}},onClick(n,t,e){e.chart.toggleDataVisibility(t.index),e.chart.update()}},tooltip:{callbacks:{title(){return""},label(n){return n.chart.data.labels[n.dataIndex]+": "+n.formattedValue}}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};class Em extends so{}Em.id="pie";Em.defaults={cutout:0,rotation:0,circumference:360,radius:"100%"};class Th extends Dn{getLabelAndValue(t){const e=this._cachedMeta.vScale,i=this.getParsed(t);return{label:e.getLabels()[t],value:""+e.getLabelForValue(i[e.axis])}}update(t){const e=this._cachedMeta,i=e.dataset,s=e.data||[],r=e.iScale.getLabels();if(i.points=s,t!=="resize"){const o=this.resolveDatasetElementOptions(t);this.options.showLine||(o.borderWidth=0);const a={_loop:!0,_fullLoop:r.length===s.length,options:o};this.updateElement(i,void 0,a,t)}this.updateElements(s,0,s.length,t)}updateElements(t,e,i,s){const r=this.getDataset(),o=this._cachedMeta.rScale,a=s==="reset";for(let l=e;l<e+i;l++){const c=t[l],h=this.resolveDataElementOptions(l,c.active?"active":s),u=o.getPointPositionForValue(l,r.data[l]),d=a?o.xCenter:u.x,f=a?o.yCenter:u.y,p={x:d,y:f,angle:u.angle,skip:isNaN(d)||isNaN(f),options:h};this.updateElement(c,l,p,s)}}}Th.id="radar";Th.defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}};Th.overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};class Ah extends Ha{}Ah.id="scatter";Ah.defaults={showLine:!1,fill:!1};Ah.overrides={interaction:{mode:"point"},plugins:{tooltip:{callbacks:{title(){return""},label(n){return"("+n.label+", "+n.formattedValue+")"}}}},scales:{x:{type:"linear"},y:{type:"linear"}}};function es(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class Ch{constructor(t){this.options=t||{}}formats(){return es()}parse(t,e){return es()}format(t,e){return es()}add(t,e,i){return es()}diff(t,e,i){return es()}startOf(t,e,i){return es()}endOf(t,e){return es()}}Ch.override=function(n){Object.assign(Ch.prototype,n)};var tS={_date:Ch};function ro(n,t){return"native"in n?{x:n.x,y:n.y}:nm(n,t)}function eS(n,t){const e=n.getSortedVisibleDatasetMetas();let i,s,r;for(let o=0,a=e.length;o<a;++o){({index:i,data:s}=e[o]);for(let l=0,c=s.length;l<c;++l)r=s[l],r.skip||t(r,i,l)}}function nS(n,t,e,i){const{controller:s,data:r,_sorted:o}=n,a=s._cachedMeta.iScale;if(a&&t===a.axis&&t!=="r"&&o&&r.length){const l=a._reversePixels?BM:Ki;if(i){if(s._sharedOptions){const c=r[0],h=typeof c.getRange=="function"&&c.getRange(t);if(h){const u=l(r,t,e-h),d=l(r,t,e+h);return{lo:u.lo,hi:d.hi}}}}else return l(r,t,e)}return{lo:0,hi:r.length-1}}function Lh(n,t,e,i,s){const r=n.getSortedVisibleDatasetMetas(),o=e[t];for(let a=0,l=r.length;a<l;++a){const{index:c,data:h}=r[a],{lo:u,hi:d}=nS(r[a],t,o,s);for(let f=u;f<=d;++f){const p=h[f];p.skip||i(p,c,f)}}}function iS(n){const t=n.indexOf("x")!==-1,e=n.indexOf("y")!==-1;return function(i,s){const r=t?Math.abs(i.x-s.x):0,o=e?Math.abs(i.y-s.y):0;return Math.sqrt(Math.pow(r,2)+Math.pow(o,2))}}function Rh(n,t,e,i){const s=[];return Zi(t,n.chartArea,n._minPadding)&&Lh(n,e,t,function(o,a,l){o.inRange(t.x,t.y,i)&&s.push({element:o,datasetIndex:a,index:l})},!0),s}function sS(n,t,e,i){let s=[];function r(o,a,l){const{startAngle:c,endAngle:h}=o.getProps(["startAngle","endAngle"],i),{angle:u}=Rp(o,{x:t.x,y:t.y});Zr(u,c,h)&&s.push({element:o,datasetIndex:a,index:l})}return Lh(n,e,t,r),s}function rS(n,t,e,i,s){let r=[];const o=iS(e);let a=Number.POSITIVE_INFINITY;function l(c,h,u){const d=c.inRange(t.x,t.y,s);if(i&&!d)return;const f=c.getCenterPoint(s);if(!Zi(f,n.chartArea,n._minPadding)&&!d)return;const x=o(t,f);x<a?(r=[{element:c,datasetIndex:h,index:u}],a=x):x===a&&r.push({element:c,datasetIndex:h,index:u})}return Lh(n,e,t,l),r}function Ph(n,t,e,i,s){return Zi(t,n.chartArea,n._minPadding)?e==="r"&&!i?sS(n,t,e,s):rS(n,t,e,i,s):[]}function Tm(n,t,e,i){const s=ro(t,n),r=[],o=e.axis,a=o==="x"?"inXRange":"inYRange";let l=!1;return eS(n,(c,h,u)=>{c[a](s[o],i)&&r.push({element:c,datasetIndex:h,index:u}),c.inRange(s.x,s.y,i)&&(l=!0)}),e.intersect&&!l?[]:r}var oS={modes:{index(n,t,e,i){const s=ro(t,n),r=e.axis||"x",o=e.intersect?Rh(n,s,r,i):Ph(n,s,r,!1,i),a=[];return o.length?(n.getSortedVisibleDatasetMetas().forEach(l=>{const c=o[0].index,h=l.data[c];h&&!h.skip&&a.push({element:h,datasetIndex:l.index,index:c})}),a):[]},dataset(n,t,e,i){const s=ro(t,n),r=e.axis||"xy";let o=e.intersect?Rh(n,s,r,i):Ph(n,s,r,!1,i);if(o.length>0){const a=o[0].datasetIndex,l=n.getDatasetMeta(a).data;o=[];for(let c=0;c<l.length;++c)o.push({element:l[c],datasetIndex:a,index:c})}return o},point(n,t,e,i){const s=ro(t,n),r=e.axis||"xy";return Rh(n,s,r,i)},nearest(n,t,e,i){const s=ro(t,n),r=e.axis||"xy";return Ph(n,s,r,e.intersect,i)},x(n,t,e,i){return Tm(n,t,{axis:"x",intersect:e.intersect},i)},y(n,t,e,i){return Tm(n,t,{axis:"y",intersect:e.intersect},i)}}};const Am=["left","top","right","bottom"];function oo(n,t){return n.filter(e=>e.pos===t)}function Cm(n,t){return n.filter(e=>Am.indexOf(e.pos)===-1&&e.box.axis===t)}function ao(n,t){return n.sort((e,i)=>{const s=t?i:e,r=t?e:i;return s.weight===r.weight?s.index-r.index:s.weight-r.weight})}function aS(n){const t=[];let e,i,s,r,o,a;for(e=0,i=(n||[]).length;e<i;++e)s=n[e],{position:r,options:{stack:o,stackWeight:a=1}}=s,t.push({index:e,box:s,pos:r,horizontal:s.isHorizontal(),weight:s.weight,stack:o&&r+o,stackWeight:a});return t}function lS(n){const t={};for(const e of n){const{stack:i,pos:s,stackWeight:r}=e;if(!i||!Am.includes(s))continue;const o=t[i]||(t[i]={count:0,placed:0,weight:0,size:0});o.count++,o.weight+=r}return t}function cS(n,t){const e=lS(n),{vBoxMaxWidth:i,hBoxMaxHeight:s}=t;let r,o,a;for(r=0,o=n.length;r<o;++r){a=n[r];const{fullSize:l}=a.box,c=e[a.stack],h=c&&a.stackWeight/c.weight;a.horizontal?(a.width=h?h*i:l&&t.availableWidth,a.height=s):(a.width=i,a.height=h?h*s:l&&t.availableHeight)}return e}function hS(n){const t=aS(n),e=ao(t.filter(c=>c.box.fullSize),!0),i=ao(oo(t,"left"),!0),s=ao(oo(t,"right")),r=ao(oo(t,"top"),!0),o=ao(oo(t,"bottom")),a=Cm(t,"x"),l=Cm(t,"y");return{fullSize:e,leftAndTop:i.concat(r),rightAndBottom:s.concat(l).concat(o).concat(a),chartArea:oo(t,"chartArea"),vertical:i.concat(s).concat(l),horizontal:r.concat(o).concat(a)}}function Lm(n,t,e,i){return Math.max(n[e],t[e])+Math.max(n[i],t[i])}function Rm(n,t){n.top=Math.max(n.top,t.top),n.left=Math.max(n.left,t.left),n.bottom=Math.max(n.bottom,t.bottom),n.right=Math.max(n.right,t.right)}function uS(n,t,e,i){const{pos:s,box:r}=e,o=n.maxPadding;if(!Wt(s)){e.size&&(n[s]-=e.size);const u=i[e.stack]||{size:0,count:1};u.size=Math.max(u.size,e.horizontal?r.height:r.width),e.size=u.size/u.count,n[s]+=e.size}r.getPadding&&Rm(o,r.getPadding());const a=Math.max(0,t.outerWidth-Lm(o,n,"left","right")),l=Math.max(0,t.outerHeight-Lm(o,n,"top","bottom")),c=a!==n.w,h=l!==n.h;return n.w=a,n.h=l,e.horizontal?{same:c,other:h}:{same:h,other:c}}function dS(n){const t=n.maxPadding;function e(i){const s=Math.max(t[i]-n[i],0);return n[i]+=s,s}n.y+=e("top"),n.x+=e("left"),e("right"),e("bottom")}function fS(n,t){const e=t.maxPadding;function i(s){const r={left:0,top:0,right:0,bottom:0};return s.forEach(o=>{r[o]=Math.max(t[o],e[o])}),r}return i(n?["left","right"]:["top","bottom"])}function lo(n,t,e,i){const s=[];let r,o,a,l,c,h;for(r=0,o=n.length,c=0;r<o;++r){a=n[r],l=a.box,l.update(a.width||t.w,a.height||t.h,fS(a.horizontal,t));const{same:u,other:d}=uS(t,e,a,i);c|=u&&s.length,h=h||d,l.fullSize||s.push(a)}return c&&lo(s,t,e,i)||h}function Ua(n,t,e,i,s){n.top=e,n.left=t,n.right=t+i,n.bottom=e+s,n.width=i,n.height=s}function Pm(n,t,e,i){const s=e.padding;let{x:r,y:o}=t;for(const a of n){const l=a.box,c=i[a.stack]||{count:1,placed:0,weight:1},h=a.stackWeight/c.weight||1;if(a.horizontal){const u=t.w*h,d=c.size||l.height;nn(c.start)&&(o=c.start),l.fullSize?Ua(l,s.left,o,e.outerWidth-s.right-s.left,d):Ua(l,t.left+c.placed,o,u,d),c.start=o,c.placed+=u,o=l.bottom}else{const u=t.h*h,d=c.size||l.width;nn(c.start)&&(r=c.start),l.fullSize?Ua(l,r,s.top,d,e.outerHeight-s.bottom-s.top):Ua(l,r,t.top+c.placed,d,u),c.start=r,c.placed+=u,r=l.right}}t.x=r,t.y=o}Bt.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}});var on={addBox(n,t){n.boxes||(n.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},n.boxes.push(t)},removeBox(n,t){const e=n.boxes?n.boxes.indexOf(t):-1;e!==-1&&n.boxes.splice(e,1)},configure(n,t,e){t.fullSize=e.fullSize,t.position=e.position,t.weight=e.weight},update(n,t,e,i){if(!n)return;const s=De(n.options.layout.padding),r=Math.max(t-s.width,0),o=Math.max(e-s.height,0),a=hS(n.boxes),l=a.vertical,c=a.horizontal;Yt(n.boxes,x=>{typeof x.beforeLayout=="function"&&x.beforeLayout()});const h=l.reduce((x,_)=>_.box.options&&_.box.options.display===!1?x:x+1,0)||1,u=Object.freeze({outerWidth:t,outerHeight:e,padding:s,availableWidth:r,availableHeight:o,vBoxMaxWidth:r/2/h,hBoxMaxHeight:o/2}),d=Object.assign({},s);Rm(d,De(i));const f=Object.assign({maxPadding:d,w:r,h:o,x:s.left,y:s.top},s),p=cS(l.concat(c),u);lo(a.fullSize,f,u,p),lo(l,f,u,p),lo(c,f,u,p)&&lo(l,f,u,p),dS(f),Pm(a.leftAndTop,f,u,p),f.x+=f.w,f.y+=f.h,Pm(a.rightAndBottom,f,u,p),n.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},Yt(a.chartArea,x=>{const _=x.box;Object.assign(_,n.chartArea),_.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})})}};class Dm{acquireContext(t,e){}releaseContext(t){return!1}addEventListener(t,e,i){}removeEventListener(t,e,i){}getDevicePixelRatio(){return 1}getMaximumSize(t,e,i,s){return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}isAttached(t){return!0}updateConfig(t){}}class pS extends Dm{acquireContext(t){return t&&t.getContext&&t.getContext("2d")||null}updateConfig(t){t.options.animation=!1}}const Va="$chartjs",mS={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},Im=n=>n===null||n==="";function gS(n,t){const e=n.style,i=n.getAttribute("height"),s=n.getAttribute("width");if(n[Va]={initial:{height:i,width:s,style:{display:e.display,height:e.height,width:e.width}}},e.display=e.display||"block",e.boxSizing=e.boxSizing||"border-box",Im(s)){const r=sm(n,"width");r!==void 0&&(n.width=r)}if(Im(i))if(n.style.height==="")n.height=n.width/(t||2);else{const r=sm(n,"height");r!==void 0&&(n.height=r)}return n}const Fm=hw?{passive:!0}:!1;function xS(n,t,e){n.addEventListener(t,e,Fm)}function _S(n,t,e){n.canvas.removeEventListener(t,e,Fm)}function yS(n,t){const e=mS[n.type]||n.type,{x:i,y:s}=nm(n,t);return{type:e,chart:t,native:n,x:i!==void 0?i:null,y:s!==void 0?s:null}}function Wa(n,t){for(const e of n)if(e===t||e.contains(t))return!0}function vS(n,t,e){const i=n.canvas,s=new MutationObserver(r=>{let o=!1;for(const a of r)o=o||Wa(a.addedNodes,i),o=o&&!Wa(a.removedNodes,i);o&&e()});return s.observe(document,{childList:!0,subtree:!0}),s}function bS(n,t,e){const i=n.canvas,s=new MutationObserver(r=>{let o=!1;for(const a of r)o=o||Wa(a.removedNodes,i),o=o&&!Wa(a.addedNodes,i);o&&e()});return s.observe(document,{childList:!0,subtree:!0}),s}const co=new Map;let Om=0;function km(){const n=window.devicePixelRatio;n!==Om&&(Om=n,co.forEach((t,e)=>{e.currentDevicePixelRatio!==n&&t()}))}function MS(n,t){co.size||window.addEventListener("resize",km),co.set(n,t)}function wS(n){co.delete(n),co.size||window.removeEventListener("resize",km)}function SS(n,t,e){const i=n.canvas,s=i&&_h(i);if(!s)return;const r=bp((a,l)=>{const c=s.clientWidth;e(a,l),c<s.clientWidth&&e()},window),o=new ResizeObserver(a=>{const l=a[0],c=l.contentRect.width,h=l.contentRect.height;c===0&&h===0||r(c,h)});return o.observe(s),MS(n,r),o}function Dh(n,t,e){e&&e.disconnect(),t==="resize"&&wS(n)}function ES(n,t,e){const i=n.canvas,s=bp(r=>{n.ctx!==null&&e(yS(r,n))},n,r=>{const o=r[0];return[o,o.offsetX,o.offsetY]});return xS(i,t,s),s}class TS extends Dm{acquireContext(t,e){const i=t&&t.getContext&&t.getContext("2d");return i&&i.canvas===t?(gS(t,e),i):null}releaseContext(t){const e=t.canvas;if(!e[Va])return!1;const i=e[Va].initial;["height","width"].forEach(r=>{const o=i[r];$t(o)?e.removeAttribute(r):e.setAttribute(r,o)});const s=i.style||{};return Object.keys(s).forEach(r=>{e.style[r]=s[r]}),e.width=e.width,delete e[Va],!0}addEventListener(t,e,i){this.removeEventListener(t,e);const s=t.$proxies||(t.$proxies={}),o={attach:vS,detach:bS,resize:SS}[e]||ES;s[e]=o(t,e,i)}removeEventListener(t,e){const i=t.$proxies||(t.$proxies={}),s=i[e];if(!s)return;({attach:Dh,detach:Dh,resize:Dh}[e]||_S)(t,e,s),i[e]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(t,e,i,s){return cw(t,e,i,s)}isAttached(t){const e=_h(t);return!!(e&&e.isConnected)}}function AS(n){return!em()||typeof OffscreenCanvas!="undefined"&&n instanceof OffscreenCanvas?pS:TS}class gn{constructor(){this.x=void 0,this.y=void 0,this.active=!1,this.options=void 0,this.$animations=void 0}tooltipPosition(t){const{x:e,y:i}=this.getProps(["x","y"],t);return{x:e,y:i}}hasValue(){return $r(this.x)&&$r(this.y)}getProps(t,e){const i=this.$animations;if(!e||!i)return this;const s={};return t.forEach(r=>{s[r]=i[r]&&i[r].active()?i[r]._to:this[r]}),s}}gn.defaults={};gn.defaultRoutes=void 0;const Nm={values(n){return re(n)?n:""+n},numeric(n,t,e){if(n===0)return"0";const i=this.chart.options.locale;let s,r=n;if(e.length>1){const c=Math.max(Math.abs(e[0].value),Math.abs(e[e.length-1].value));(c<1e-4||c>1e15)&&(s="scientific"),r=CS(n,e)}const o=sn(Math.abs(r)),a=Math.max(Math.min(-1*Math.floor(o),20),0),l={notation:s,minimumFractionDigits:a,maximumFractionDigits:a};return Object.assign(l,this.options.ticks.format),no(n,i,l)},logarithmic(n,t,e){if(n===0)return"0";const i=n/Math.pow(10,Math.floor(sn(n)));return i===1||i===2||i===5?Nm.numeric.call(this,n,t,e):""}};function CS(n,t){let e=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;return Math.abs(e)>=1&&n!==Math.floor(n)&&(e=n-Math.floor(n)),e}var Ga={formatters:Nm};Bt.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",grace:0,grid:{display:!0,lineWidth:1,drawBorder:!0,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(n,t)=>t.lineWidth,tickColor:(n,t)=>t.color,offset:!1,borderDash:[],borderDashOffset:0,borderWidth:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:Ga.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}});Bt.route("scale.ticks","color","","color");Bt.route("scale.grid","color","","borderColor");Bt.route("scale.grid","borderColor","","borderColor");Bt.route("scale.title","color","","color");Bt.describe("scale",{_fallback:!1,_scriptable:n=>!n.startsWith("before")&&!n.startsWith("after")&&n!=="callback"&&n!=="parser",_indexable:n=>n!=="borderDash"&&n!=="tickBorderDash"});Bt.describe("scales",{_fallback:"scale"});Bt.describe("scale.ticks",{_scriptable:n=>n!=="backdropPadding"&&n!=="callback",_indexable:n=>n!=="backdropPadding"});function LS(n,t){const e=n.options.ticks,i=e.maxTicksLimit||RS(n),s=e.major.enabled?DS(t):[],r=s.length,o=s[0],a=s[r-1],l=[];if(r>i)return IS(t,l,s,r/i),l;const c=PS(s,t,i);if(r>0){let h,u;const d=r>1?Math.round((a-o)/(r-1)):null;for(ja(t,l,c,$t(d)?0:o-d,o),h=0,u=r-1;h<u;h++)ja(t,l,c,s[h],s[h+1]);return ja(t,l,c,a,$t(d)?t.length:a+d),l}return ja(t,l,c),l}function RS(n){const t=n.options.offset,e=n._tickSize(),i=n._length/e+(t?0:1),s=n._maxLength/e;return Math.floor(Math.min(i,s))}function PS(n,t,e){const i=FS(n),s=t.length/e;if(!i)return Math.max(s,1);const r=sM(i);for(let o=0,a=r.length-1;o<a;o++){const l=r[o];if(l>s)return l}return Math.max(s,1)}function DS(n){const t=[];let e,i;for(e=0,i=n.length;e<i;e++)n[e].major&&t.push(e);return t}function IS(n,t,e,i){let s=0,r=e[0],o;for(i=Math.ceil(i),o=0;o<n.length;o++)o===r&&(t.push(n[o]),s++,r=e[s*i])}function ja(n,t,e,i,s){const r=Ot(i,0),o=Math.min(Ot(s,n.length),n.length);let a=0,l,c,h;for(e=Math.ceil(e),s&&(l=s-i,e=l/Math.floor(l/e)),h=r;h<0;)a++,h=Math.round(r+a*e);for(c=Math.max(r,0);c<o;c++)c===h&&(t.push(n[c]),a++,h=Math.round(r+a*e))}function FS(n){const t=n.length;let e,i;if(t<2)return!1;for(i=n[0],e=1;e<t;++e)if(n[e]-n[e-1]!==i)return!1;return i}const OS=n=>n==="left"?"right":n==="right"?"left":n,zm=(n,t,e)=>t==="top"||t==="left"?n[t]+e:n[t]-e;function Bm(n,t){const e=[],i=n.length/t,s=n.length;let r=0;for(;r<s;r+=i)e.push(n[Math.floor(r)]);return e}function kS(n,t,e){const i=n.ticks.length,s=Math.min(t,i-1),r=n._startPixel,o=n._endPixel,a=1e-6;let l=n.getPixelForTick(s),c;if(!(e&&(i===1?c=Math.max(l-r,o-l):t===0?c=(n.getPixelForTick(1)-l)/2:c=(l-n.getPixelForTick(s-1))/2,l+=s<t?c:-c,l<r-a||l>o+a)))return l}function NS(n,t){Yt(n,e=>{const i=e.gc,s=i.length/2;let r;if(s>t){for(r=0;r<s;++r)delete e.data[i[r]];i.splice(0,s)}})}function ho(n){return n.drawTicks?n.tickLength:0}function Hm(n,t){if(!n.display)return 0;const e=ge(n.font,t),i=De(n.padding);return(re(n.text)?n.text.length:1)*e.lineHeight+i.height}function zS(n,t){return fi(n,{scale:t,type:"scale"})}function BS(n,t,e){return fi(n,{tick:e,index:t,type:"tick"})}function HS(n,t,e){let i=Qc(n);return(e&&t!=="right"||!e&&t==="right")&&(i=OS(i)),i}function US(n,t,e,i){const{top:s,left:r,bottom:o,right:a,chart:l}=n,{chartArea:c,scales:h}=l;let u=0,d,f,p;const x=o-s,_=a-r;if(n.isHorizontal()){if(f=Re(i,r,a),Wt(e)){const m=Object.keys(e)[0],g=e[m];p=h[m].getPixelForValue(g)+x-t}else e==="center"?p=(c.bottom+c.top)/2+x-t:p=zm(n,e,t);d=a-r}else{if(Wt(e)){const m=Object.keys(e)[0],g=e[m];f=h[m].getPixelForValue(g)-_+t}else e==="center"?f=(c.left+c.right)/2-_+t:f=zm(n,e,t);p=Re(i,o,s),u=e==="left"?-ue:ue}return{titleX:f,titleY:p,maxWidth:d,rotation:u}}class ns extends gn{constructor(t){super();this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(t){this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}parse(t,e){return t}getUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=this;return t=en(t,Number.POSITIVE_INFINITY),e=en(e,Number.NEGATIVE_INFINITY),i=en(i,Number.POSITIVE_INFINITY),s=en(s,Number.NEGATIVE_INFINITY),{min:en(t,i),max:en(e,s),minDefined:Ae(t),maxDefined:Ae(e)}}getMinMax(t){let{min:e,max:i,minDefined:s,maxDefined:r}=this.getUserBounds(),o;if(s&&r)return{min:e,max:i};const a=this.getMatchingVisibleMetas();for(let l=0,c=a.length;l<c;++l)o=a[l].controller.getMinMax(this,t),s||(e=Math.min(e,o.min)),r||(i=Math.max(i,o.max));return e=r&&e>i?i:e,i=s&&e>i?e:i,{min:en(e,en(i,e)),max:en(i,en(e,i))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const t=this.chart.data;return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){ne(this.options.beforeUpdate,[this])}update(t,e,i){const{beginAtZero:s,grace:r,ticks:o}=this.options,a=o.sampleSize;this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=zM(this,r,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const l=a<this.ticks.length;this._convertTicksToLabels(l?Bm(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&&(o.autoSkip||o.source==="auto")&&(this.ticks=LS(this,this.ticks),this._labelSizes=null),l&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let t=this.options.reverse,e,i;this.isHorizontal()?(e=this.left,i=this.right):(e=this.top,i=this.bottom,t=!t),this._startPixel=e,this._endPixel=i,this._reversePixels=t,this._length=i-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){ne(this.options.afterUpdate,[this])}beforeSetDimensions(){ne(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){ne(this.options.afterSetDimensions,[this])}_callHooks(t){this.chart.notifyPlugins(t,this.getContext()),ne(this.options[t],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){ne(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(t){const e=this.options.ticks;let i,s,r;for(i=0,s=t.length;i<s;i++)r=t[i],r.label=ne(e.callback,[r.value,i,t],this)}afterTickToLabelConversion(){ne(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){ne(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const t=this.options,e=t.ticks,i=this.ticks.length,s=e.minRotation||0,r=e.maxRotation;let o=s,a,l,c;if(!this._isVisible()||!e.display||s>=r||i<=1||!this.isHorizontal()){this.labelRotation=s;return}const h=this._getLabelSizes(),u=h.widest.width,d=h.highest.height,f=Pe(this.chart.width-u,0,this.maxWidth);a=t.offset?this.maxWidth/i:f/(i-1),u+6>a&&(a=f/(i-(t.offset?.5:1)),l=this.maxHeight-ho(t.grid)-e.padding-Hm(t.title,this.chart.options.font),c=Math.sqrt(u*u+d*d),o=eh(Math.min(Math.asin(Pe((h.highest.height+6)/a,-1,1)),Math.asin(Pe(l/c,-1,1))-Math.asin(Pe(d/c,-1,1)))),o=Math.max(s,Math.min(r,o))),this.labelRotation=o}afterCalculateLabelRotation(){ne(this.options.afterCalculateLabelRotation,[this])}beforeFit(){ne(this.options.beforeFit,[this])}fit(){const t={width:0,height:0},{chart:e,options:{ticks:i,title:s,grid:r}}=this,o=this._isVisible(),a=this.isHorizontal();if(o){const l=Hm(s,e.options.font);if(a?(t.width=this.maxWidth,t.height=ho(r)+l):(t.height=this.maxHeight,t.width=ho(r)+l),i.display&&this.ticks.length){const{first:c,last:h,widest:u,highest:d}=this._getLabelSizes(),f=i.padding*2,p=pn(this.labelRotation),x=Math.cos(p),_=Math.sin(p);if(a){const m=i.mirror?0:_*u.width+x*d.height;t.height=Math.min(this.maxHeight,t.height+m+f)}else{const m=i.mirror?0:x*u.width+_*d.height;t.width=Math.min(this.maxWidth,t.width+m+f)}this._calculatePadding(c,h,_,x)}}this._handleMargins(),a?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}_calculatePadding(t,e,i,s){const{ticks:{align:r,padding:o},position:a}=this.options,l=this.labelRotation!==0,c=a!=="top"&&this.axis==="x";if(this.isHorizontal()){const h=this.getPixelForTick(0)-this.left,u=this.right-this.getPixelForTick(this.ticks.length-1);let d=0,f=0;l?c?(d=s*t.width,f=i*e.height):(d=i*t.height,f=s*e.width):r==="start"?f=e.width:r==="end"?d=t.width:(d=t.width/2,f=e.width/2),this.paddingLeft=Math.max((d-h+o)*this.width/(this.width-h),0),this.paddingRight=Math.max((f-u+o)*this.width/(this.width-u),0)}else{let h=e.height/2,u=t.height/2;r==="start"?(h=0,u=t.height):r==="end"&&(h=e.height,u=0),this.paddingTop=h+o,this.paddingBottom=u+o}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){ne(this.options.afterFit,[this])}isHorizontal(){const{axis:t,position:e}=this.options;return e==="top"||e==="bottom"||t==="x"}isFullSize(){return this.options.fullSize}_convertTicksToLabels(t){this.beforeTickToLabelConversion(),this.generateTickLabels(t);let e,i;for(e=0,i=t.length;e<i;e++)$t(t[e].label)&&(t.splice(e,1),i--,e--);this.afterTickToLabelConversion()}_getLabelSizes(){let t=this._labelSizes;if(!t){const e=this.options.ticks.sampleSize;let i=this.ticks;e<i.length&&(i=Bm(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length)}return t}_computeLabelSizes(t,e){const{ctx:i,_longestTextCache:s}=this,r=[],o=[];let a=0,l=0,c,h,u,d,f,p,x,_,m,g,S;for(c=0;c<e;++c){if(d=t[c].label,f=this._resolveTickFontOptions(c),i.font=p=f.string,x=s[p]=s[p]||{data:{},gc:[]},_=f.lineHeight,m=g=0,!$t(d)&&!re(d))m=Ia(i,x.data,x.gc,m,d),g=_;else if(re(d))for(h=0,u=d.length;h<u;++h)S=d[h],!$t(S)&&!re(S)&&(m=Ia(i,x.data,x.gc,m,S),g+=_);r.push(m),o.push(g),a=Math.max(m,a),l=Math.max(g,l)}NS(s,e);const v=r.indexOf(a),E=o.indexOf(l),R=D=>({width:r[D]||0,height:o[D]||0});return{first:R(0),last:R(e-1),widest:R(v),highest:R(E),widths:r,heights:o}}getLabelForValue(t){return t}getPixelForValue(t,e){return NaN}getValueForPixel(t){}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getPixelForDecimal(t){this._reversePixels&&(t=1-t);const e=this._startPixel+t*this._length;return aM(this._alignToPixels?Yi(this.chart,e,0):e)}getDecimalForPixel(t){const e=(t-this._startPixel)/this._length;return this._reversePixels?1-e:e}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:t,max:e}=this;return t<0&&e<0?e:t>0&&e>0?t:0}getContext(t){const e=this.ticks||[];if(t>=0&&t<e.length){const i=e[t];return i.$context||(i.$context=BS(this.getContext(),t,i))}return this.$context||(this.$context=zS(this.chart.getContext(),this))}_tickSize(){const t=this.options.ticks,e=pn(this.labelRotation),i=Math.abs(Math.cos(e)),s=Math.abs(Math.sin(e)),r=this._getLabelSizes(),o=t.autoSkipPadding||0,a=r?r.widest.width+o:0,l=r?r.highest.height+o:0;return this.isHorizontal()?l*i>a*s?a/i:l/s:l*s<a*i?l/i:a/s}_isVisible(){const t=this.options.display;return t!=="auto"?!!t:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(t){const e=this.axis,i=this.chart,s=this.options,{grid:r,position:o}=s,a=r.offset,l=this.isHorizontal(),h=this.ticks.length+(a?1:0),u=ho(r),d=[],f=r.setContext(this.getContext()),p=f.drawBorder?f.borderWidth:0,x=p/2,_=function(V){return Yi(i,V,p)};let m,g,S,v,E,R,D,$,it,tt,N,T;if(o==="top")m=_(this.bottom),R=this.bottom-u,$=m-x,tt=_(t.top)+x,T=t.bottom;else if(o==="bottom")m=_(this.top),tt=t.top,T=_(t.bottom)-x,R=m+x,$=this.top+u;else if(o==="left")m=_(this.right),E=this.right-u,D=m-x,it=_(t.left)+x,N=t.right;else if(o==="right")m=_(this.left),it=t.left,N=_(t.right)-x,E=m+x,D=this.left+u;else if(e==="x"){if(o==="center")m=_((t.top+t.bottom)/2+.5);else if(Wt(o)){const V=Object.keys(o)[0],k=o[V];m=_(this.chart.scales[V].getPixelForValue(k))}tt=t.top,T=t.bottom,R=m+x,$=R+u}else if(e==="y"){if(o==="center")m=_((t.left+t.right)/2);else if(Wt(o)){const V=Object.keys(o)[0],k=o[V];m=_(this.chart.scales[V].getPixelForValue(k))}E=m-x,D=E-u,it=t.left,N=t.right}const A=Ot(s.ticks.maxTicksLimit,h),W=Math.max(1,Math.ceil(h/A));for(g=0;g<h;g+=W){const V=r.setContext(this.getContext(g)),k=V.lineWidth,U=V.color,ct=r.borderDash||[],xt=V.borderDashOffset,et=V.tickWidth,ot=V.tickColor,yt=V.tickBorderDash||[],gt=V.tickBorderDashOffset;S=kS(this,g,a),S!==void 0&&(v=Yi(i,S,k),l?E=D=it=N=v:R=$=tt=T=v,d.push({tx1:E,ty1:R,tx2:D,ty2:$,x1:it,y1:tt,x2:N,y2:T,width:k,color:U,borderDash:ct,borderDashOffset:xt,tickWidth:et,tickColor:ot,tickBorderDash:yt,tickBorderDashOffset:gt}))}return this._ticksLength=h,this._borderValue=m,d}_computeLabelItems(t){const e=this.axis,i=this.options,{position:s,ticks:r}=i,o=this.isHorizontal(),a=this.ticks,{align:l,crossAlign:c,padding:h,mirror:u}=r,d=ho(i.grid),f=d+h,p=u?-h:f,x=-pn(this.labelRotation),_=[];let m,g,S,v,E,R,D,$,it,tt,N,T,A="middle";if(s==="top")R=this.bottom-p,D=this._getXAxisLabelAlignment();else if(s==="bottom")R=this.top+p,D=this._getXAxisLabelAlignment();else if(s==="left"){const V=this._getYAxisLabelAlignment(d);D=V.textAlign,E=V.x}else if(s==="right"){const V=this._getYAxisLabelAlignment(d);D=V.textAlign,E=V.x}else if(e==="x"){if(s==="center")R=(t.top+t.bottom)/2+f;else if(Wt(s)){const V=Object.keys(s)[0],k=s[V];R=this.chart.scales[V].getPixelForValue(k)+f}D=this._getXAxisLabelAlignment()}else if(e==="y"){if(s==="center")E=(t.left+t.right)/2-f;else if(Wt(s)){const V=Object.keys(s)[0],k=s[V];E=this.chart.scales[V].getPixelForValue(k)}D=this._getYAxisLabelAlignment(d).textAlign}e==="y"&&(l==="start"?A="top":l==="end"&&(A="bottom"));const W=this._getLabelSizes();for(m=0,g=a.length;m<g;++m){S=a[m],v=S.label;const V=r.setContext(this.getContext(m));$=this.getPixelForTick(m)+r.labelOffset,it=this._resolveTickFontOptions(m),tt=it.lineHeight,N=re(v)?v.length:1;const k=N/2,U=V.color,ct=V.textStrokeColor,xt=V.textStrokeWidth;o?(E=$,s==="top"?c==="near"||x!==0?T=-N*tt+tt/2:c==="center"?T=-W.highest.height/2-k*tt+tt:T=-W.highest.height+tt/2:c==="near"||x!==0?T=tt/2:c==="center"?T=W.highest.height/2-k*tt:T=W.highest.height-N*tt,u&&(T*=-1)):(R=$,T=(1-N)*tt/2);let et;if(V.showLabelBackdrop){const ot=De(V.backdropPadding),yt=W.heights[m],gt=W.widths[m];let wt=R+T-ot.top,J=E-ot.left;switch(A){case"middle":wt-=yt/2;break;case"bottom":wt-=yt;break}switch(D){case"center":J-=gt/2;break;case"right":J-=gt;break}et={left:J,top:wt,width:gt+ot.width,height:yt+ot.height,color:V.backdropColor}}_.push({rotation:x,label:v,font:it,color:U,strokeColor:ct,strokeWidth:xt,textOffset:T,textAlign:D,textBaseline:A,translation:[E,R],backdrop:et})}return _}_getXAxisLabelAlignment(){const{position:t,ticks:e}=this.options;if(-pn(this.labelRotation))return t==="top"?"left":"right";let s="center";return e.align==="start"?s="left":e.align==="end"&&(s="right"),s}_getYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:r}}=this.options,o=this._getLabelSizes(),a=t+r,l=o.widest.width;let c,h;return e==="left"?s?(h=this.right+r,i==="near"?c="left":i==="center"?(c="center",h+=l/2):(c="right",h+=l)):(h=this.right-a,i==="near"?c="right":i==="center"?(c="center",h-=l/2):(c="left",h=this.left)):e==="right"?s?(h=this.left+r,i==="near"?c="right":i==="center"?(c="center",h-=l/2):(c="left",h-=l)):(h=this.left+a,i==="near"?c="left":i==="center"?(c="center",h+=l/2):(c="right",h=this.right)):c="right",{textAlign:c,x:h}}_computeLabelArea(){if(this.options.ticks.mirror)return;const t=this.chart,e=this.options.position;if(e==="left"||e==="right")return{top:0,left:this.left,bottom:t.height,right:this.right};if(e==="top"||e==="bottom")return{top:this.top,left:0,bottom:this.bottom,right:t.width}}drawBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:r,height:o}=this;e&&(t.save(),t.fillStyle=e,t.fillRect(i,s,r,o),t.restore())}getLineWidthForValue(t){const e=this.options.grid;if(!this._isVisible()||!e.display)return 0;const s=this.ticks.findIndex(r=>r.value===t);return s>=0?e.setContext(this.getContext(s)).lineWidth:0}drawGrid(t){const e=this.options.grid,i=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));let r,o;const a=(l,c,h)=>{!h.width||!h.color||(i.save(),i.lineWidth=h.width,i.strokeStyle=h.color,i.setLineDash(h.borderDash||[]),i.lineDashOffset=h.borderDashOffset,i.beginPath(),i.moveTo(l.x,l.y),i.lineTo(c.x,c.y),i.stroke(),i.restore())};if(e.display)for(r=0,o=s.length;r<o;++r){const l=s[r];e.drawOnChartArea&&a({x:l.x1,y:l.y1},{x:l.x2,y:l.y2},l),e.drawTicks&&a({x:l.tx1,y:l.ty1},{x:l.tx2,y:l.ty2},{color:l.tickColor,width:l.tickWidth,borderDash:l.tickBorderDash,borderDashOffset:l.tickBorderDashOffset})}}drawBorder(){const{chart:t,ctx:e,options:{grid:i}}=this,s=i.setContext(this.getContext()),r=i.drawBorder?s.borderWidth:0;if(!r)return;const o=i.setContext(this.getContext(0)).lineWidth,a=this._borderValue;let l,c,h,u;this.isHorizontal()?(l=Yi(t,this.left,r)-r/2,c=Yi(t,this.right,o)+o/2,h=u=a):(h=Yi(t,this.top,r)-r/2,u=Yi(t,this.bottom,o)+o/2,l=c=a),e.save(),e.lineWidth=s.borderWidth,e.strokeStyle=s.borderColor,e.beginPath(),e.moveTo(l,h),e.lineTo(c,u),e.stroke(),e.restore()}drawLabels(t){if(!this.options.ticks.display)return;const i=this.ctx,s=this._computeLabelArea();s&&uh(i,s);const r=this._labelItems||(this._labelItems=this._computeLabelItems(t));let o,a;for(o=0,a=r.length;o<a;++o){const l=r[o],c=l.font,h=l.label;l.backdrop&&(i.fillStyle=l.backdrop.color,i.fillRect(l.backdrop.left,l.backdrop.top,l.backdrop.width,l.backdrop.height));let u=l.textOffset;Ji(i,h,0,u,c,l)}s&&dh(i)}drawTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=this;if(!i.display)return;const r=ge(i.font),o=De(i.padding),a=i.align;let l=r.lineHeight/2;e==="bottom"||e==="center"||Wt(e)?(l+=o.bottom,re(i.text)&&(l+=r.lineHeight*(i.text.length-1))):l+=o.top;const{titleX:c,titleY:h,maxWidth:u,rotation:d}=US(this,l,e,a);Ji(t,i.text,0,0,r,{color:i.color,maxWidth:u,rotation:d,textAlign:HS(a,e,s),textBaseline:"middle",translation:[c,h]})}draw(t){!this._isVisible()||(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}_layers(){const t=this.options,e=t.ticks&&t.ticks.z||0,i=Ot(t.grid&&t.grid.z,-1);return!this._isVisible()||this.draw!==ns.prototype.draw?[{z:e,draw:s=>{this.draw(s)}}]:[{z:i,draw:s=>{this.drawBackground(),this.drawGrid(s),this.drawTitle()}},{z:i+1,draw:()=>{this.drawBorder()}},{z:e,draw:s=>{this.drawLabels(s)}}]}getMatchingVisibleMetas(t){const e=this.chart.getSortedVisibleDatasetMetas(),i=this.axis+"AxisID",s=[];let r,o;for(r=0,o=e.length;r<o;++r){const a=e[r];a[i]===this.id&&(!t||a.type===t)&&s.push(a)}return s}_resolveTickFontOptions(t){const e=this.options.ticks.setContext(this.getContext(t));return ge(e.font)}_maxDigits(){const t=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/t}}class qa{constructor(t,e,i){this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}isForType(t){return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}register(t){const e=Object.getPrototypeOf(t);let i;GS(e)&&(i=this.register(e));const s=this.items,r=t.id,o=this.scope+"."+r;if(!r)throw new Error("class does not have id: "+t);return r in s||(s[r]=t,VS(t,o,i),this.override&&Bt.override(t.id,t.overrides)),o}get(t){return this.items[t]}unregister(t){const e=this.items,i=t.id,s=this.scope;i in e&&delete e[i],s&&i in Bt[s]&&(delete Bt[s][i],this.override&&delete $i[i])}}function VS(n,t,e){const i=jr(Object.create(null),[e?Bt.get(e):{},Bt.get(t),n.defaults]);Bt.set(t,i),n.defaultRoutes&&WS(t,n.defaultRoutes),n.descriptors&&Bt.describe(t,n.descriptors)}function WS(n,t){Object.keys(t).forEach(e=>{const i=e.split("."),s=i.pop(),r=[n].concat(i).join("."),o=t[e].split("."),a=o.pop(),l=o.join(".");Bt.route(r,s,l,a)})}function GS(n){return"id"in n&&"defaults"in n}class jS{constructor(){this.controllers=new qa(Dn,"datasets",!0),this.elements=new qa(gn,"elements"),this.plugins=new qa(Object,"plugins"),this.scales=new qa(ns,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(...t){this._each("register",t)}remove(...t){this._each("unregister",t)}addControllers(...t){this._each("register",t,this.controllers)}addElements(...t){this._each("register",t,this.elements)}addPlugins(...t){this._each("register",t,this.plugins)}addScales(...t){this._each("register",t,this.scales)}getController(t){return this._get(t,this.controllers,"controller")}getElement(t){return this._get(t,this.elements,"element")}getPlugin(t){return this._get(t,this.plugins,"plugin")}getScale(t){return this._get(t,this.scales,"scale")}removeControllers(...t){this._each("unregister",t,this.controllers)}removeElements(...t){this._each("unregister",t,this.elements)}removePlugins(...t){this._each("unregister",t,this.plugins)}removeScales(...t){this._each("unregister",t,this.scales)}_each(t,e,i){[...e].forEach(s=>{const r=i||this._getRegistryForType(s);i||r.isForType(s)||r===this.plugins&&s.id?this._exec(t,r,s):Yt(s,o=>{const a=i||this._getRegistryForType(o);this._exec(t,a,o)})})}_exec(t,e,i){const s=th(t);ne(i["before"+s],[],i),e[t](i),ne(i["after"+s],[],i)}_getRegistryForType(t){for(let e=0;e<this._typedRegistries.length;e++){const i=this._typedRegistries[e];if(i.isForType(t))return i}return this.plugins}_get(t,e,i){const s=e.get(t);if(s===void 0)throw new Error('"'+t+'" is not a registered '+i+".");return s}}var qn=new jS;class qS{constructor(){this._init=[]}notify(t,e,i,s){e==="beforeInit"&&(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install"));const r=s?this._descriptors(t).filter(s):this._descriptors(t),o=this._notify(r,t,e,i);return e==="afterDestroy"&&(this._notify(r,t,"stop"),this._notify(this._init,t,"uninstall")),o}_notify(t,e,i,s){s=s||{};for(const r of t){const o=r.plugin,a=o[i],l=[e,s,r.options];if(ne(a,l,o)===!1&&s.cancelable)return!1}return!0}invalidate(){$t(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(t){if(this._cache)return this._cache;const e=this._cache=this._createDescriptors(t);return this._notifyStateChanges(t),e}_createDescriptors(t,e){const i=t&&t.config,s=Ot(i.options&&i.options.plugins,{}),r=XS(i);return s===!1&&!e?[]:YS(t,r,s,e)}_notifyStateChanges(t){const e=this._oldCache||[],i=this._cache,s=(r,o)=>r.filter(a=>!o.some(l=>a.plugin.id===l.plugin.id));this._notify(s(e,i),t,"stop"),this._notify(s(i,e),t,"start")}}function XS(n){const t=[],e=Object.keys(qn.plugins.items);for(let s=0;s<e.length;s++)t.push(qn.getPlugin(e[s]));const i=n.plugins||[];for(let s=0;s<i.length;s++){const r=i[s];t.indexOf(r)===-1&&t.push(r)}return t}function $S(n,t){return!t&&n===!1?null:n===!0?{}:n}function YS(n,t,e,i){const s=[],r=n.getContext();for(let o=0;o<t.length;o++){const a=t[o],l=a.id,c=$S(e[l],i);c!==null&&s.push({plugin:a,options:ZS(n.config,a,c,r)})}return s}function ZS(n,t,e,i){const s=n.pluginScopeKeys(t),r=n.getOptionScopes(e,s);return n.createResolver(r,i,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function Ih(n,t){const e=Bt.datasets[n]||{};return((t.datasets||{})[n]||{}).indexAxis||t.indexAxis||e.indexAxis||"x"}function JS(n,t){let e=n;return n==="_index_"?e=t:n==="_value_"&&(e=t==="x"?"y":"x"),e}function KS(n,t){return n===t?"_index_":"_value_"}function QS(n){if(n==="top"||n==="bottom")return"x";if(n==="left"||n==="right")return"y"}function Fh(n,t){return n==="x"||n==="y"?n:t.axis||QS(t.position)||n.charAt(0).toLowerCase()}function t1(n,t){const e=$i[n.type]||{scales:{}},i=t.scales||{},s=Ih(n.type,t),r=Object.create(null),o=Object.create(null);return Object.keys(i).forEach(a=>{const l=i[a];if(!Wt(l))return console.error(`Invalid scale configuration for scale: ${a}`);if(l._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${a}`);const c=Fh(a,l),h=KS(c,s),u=e.scales||{};r[c]=r[c]||a,o[a]=qr(Object.create(null),[{axis:c},l,u[c],u[h]])}),n.data.datasets.forEach(a=>{const l=a.type||n.type,c=a.indexAxis||Ih(l,t),u=($i[l]||{}).scales||{};Object.keys(u).forEach(d=>{const f=JS(d,c),p=a[f+"AxisID"]||r[f]||f;o[p]=o[p]||Object.create(null),qr(o[p],[{axis:f},i[p],u[d]])})}),Object.keys(o).forEach(a=>{const l=o[a];qr(l,[Bt.scales[l.type],Bt.scale])}),o}function Um(n){const t=n.options||(n.options={});t.plugins=Ot(t.plugins,{}),t.scales=t1(n,t)}function Vm(n){return n=n||{},n.datasets=n.datasets||[],n.labels=n.labels||[],n}function e1(n){return n=n||{},n.data=Vm(n.data),Um(n),n}const Wm=new Map,Gm=new Set;function Xa(n,t){let e=Wm.get(n);return e||(e=t(),Wm.set(n,e),Gm.add(e)),e}const uo=(n,t,e)=>{const i=Xi(t,e);i!==void 0&&n.add(i)};class n1{constructor(t){this._config=e1(t),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(t){this._config.type=t}get data(){return this._config.data}set data(t){this._config.data=Vm(t)}get options(){return this._config.options}set options(t){this._config.options=t}get plugins(){return this._config.plugins}update(){const t=this._config;this.clearCache(),Um(t)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(t){return Xa(t,()=>[[`datasets.${t}`,""]])}datasetAnimationScopeKeys(t,e){return Xa(`${t}.transition.${e}`,()=>[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])}datasetElementScopeKeys(t,e){return Xa(`${t}-${e}`,()=>[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])}pluginScopeKeys(t){const e=t.id,i=this.type;return Xa(`${i}-plugin-${e}`,()=>[[`plugins.${e}`,...t.additionalOptionScopes||[]]])}_cachedScopes(t,e){const i=this._scopeCache;let s=i.get(t);return(!s||e)&&(s=new Map,i.set(t,s)),s}getOptionScopes(t,e,i){const{options:s,type:r}=this,o=this._cachedScopes(t,i),a=o.get(e);if(a)return a;const l=new Set;e.forEach(h=>{t&&(l.add(t),h.forEach(u=>uo(l,t,u))),h.forEach(u=>uo(l,s,u)),h.forEach(u=>uo(l,$i[r]||{},u)),h.forEach(u=>uo(l,Bt,u)),h.forEach(u=>uo(l,ch,u))});const c=Array.from(l);return c.length===0&&c.push(Object.create(null)),Gm.has(e)&&o.set(e,c),c}chartOptionScopes(){const{options:t,type:e}=this;return[t,$i[e]||{},Bt.datasets[e]||{},{type:e},Bt,ch]}resolveNamedOptions(t,e,i,s=[""]){const r={$shared:!0},{resolver:o,subPrefixes:a}=jm(this._resolverCache,t,s);let l=o;if(s1(o,e)){r.$shared=!1,i=ui(i)?i():i;const c=this.createResolver(t,i,a);l=ks(o,i,c)}for(const c of e)r[c]=l[c];return r}createResolver(t,e,i=[""],s){const{resolver:r}=jm(this._resolverCache,t,i);return Wt(e)?ks(r,e,void 0,s):r}}function jm(n,t,e){let i=n.get(t);i||(i=new Map,n.set(t,i));const s=e.join();let r=i.get(s);return r||(r={resolver:mh(t,e),subPrefixes:e.filter(a=>!a.toLowerCase().includes("hover"))},i.set(s,r)),r}const i1=n=>Wt(n)&&Object.getOwnPropertyNames(n).reduce((t,e)=>t||ui(n[e]),!1);function s1(n,t){const{isScriptable:e,isIndexable:i}=$p(n);for(const s of t){const r=e(s),o=i(s),a=(o||r)&&n[s];if(r&&(ui(a)||i1(a))||o&&re(a))return!0}return!1}var r1="3.7.0";const o1=["top","bottom","left","right","chartArea"];function qm(n,t){return n==="top"||n==="bottom"||o1.indexOf(n)===-1&&t==="x"}function Xm(n,t){return function(e,i){return e[n]===i[n]?e[t]-i[t]:e[n]-i[n]}}function $m(n){const t=n.chart,e=t.options.animation;t.notifyPlugins("afterRender"),ne(e&&e.onComplete,[n],t)}function a1(n){const t=n.chart,e=t.options.animation;ne(e&&e.onProgress,[n],t)}function Ym(n){return em()&&typeof n=="string"?n=document.getElementById(n):n&&n.length&&(n=n[0]),n&&n.canvas&&(n=n.canvas),n}const $a={},Zm=n=>{const t=Ym(n);return Object.values($a).filter(e=>e.canvas===t).pop()};function l1(n,t,e){const i=Object.keys(n);for(const s of i){const r=+s;if(r>=t){const o=n[s];delete n[s],(e>0||r>t)&&(n[r+e]=o)}}}function c1(n,t,e,i){return!e||n.type==="mouseout"?null:i?t:n}class Jm{constructor(t,e){const i=this.config=new n1(e),s=Ym(t),r=Zm(s);if(r)throw new Error("Canvas is already in use. Chart with ID '"+r.id+"' must be destroyed before the canvas can be reused.");const o=i.createResolver(i.chartOptionScopes(),this.getContext());this.platform=new(i.platform||AS(s)),this.platform.updateConfig(i);const a=this.platform.acquireContext(s,o.aspectRatio),l=a&&a.canvas,c=l&&l.height,h=l&&l.width;if(this.id=Yb(),this.ctx=a,this.canvas=l,this.width=h,this.height=c,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new qS,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=Xb(u=>this.update(u),o.resizeDelay||0),this._dataChanges=[],$a[this.id]=this,!a||!l){console.error("Failed to create chart: can't acquire context from the given item");return}jn.listen(this,"complete",$m),jn.listen(this,"progress",a1),this._initialize(),this.attached&&this.update()}get aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:s,_aspectRatio:r}=this;return $t(t)?e&&r?r:s?i/s:null:t}get data(){return this.config.data}set data(t){this.config.data=t}get options(){return this._options}set options(t){this.config.options=t}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():im(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return Wp(this.canvas,this.ctx),this}stop(){return jn.stop(this),this}resize(t,e){jn.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}_resize(t,e){const i=this.options,s=this.canvas,r=i.maintainAspectRatio&&this.aspectRatio,o=this.platform.getMaximumSize(s,t,e,r),a=i.devicePixelRatio||this.platform.getDevicePixelRatio(),l=this.width?"resize":"attach";this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,!!im(this,a,!0)&&(this.notifyPlugins("resize",{size:o}),ne(i.onResize,[this,o],this),this.attached&&this._doResize(l)&&this.render())}ensureScalesHaveIDs(){const e=this.options.scales||{};Yt(e,(i,s)=>{i.id=s})}buildOrUpdateScales(){const t=this.options,e=t.scales,i=this.scales,s=Object.keys(i).reduce((o,a)=>(o[a]=!1,o),{});let r=[];e&&(r=r.concat(Object.keys(e).map(o=>{const a=e[o],l=Fh(o,a),c=l==="r",h=l==="x";return{options:a,dposition:c?"chartArea":h?"bottom":"left",dtype:c?"radialLinear":h?"category":"linear"}}))),Yt(r,o=>{const a=o.options,l=a.id,c=Fh(l,a),h=Ot(a.type,o.dtype);(a.position===void 0||qm(a.position,c)!==qm(o.dposition))&&(a.position=o.dposition),s[l]=!0;let u=null;if(l in i&&i[l].type===h)u=i[l];else{const d=qn.getScale(h);u=new d({id:l,type:h,ctx:this.ctx,chart:this}),i[u.id]=u}u.init(a,t)}),Yt(s,(o,a)=>{o||delete i[a]}),Yt(i,o=>{on.configure(this,o,o.options),on.addBox(this,o)})}_updateMetasets(){const t=this._metasets,e=this.data.datasets.length,i=t.length;if(t.sort((s,r)=>s.index-r.index),i>e){for(let s=e;s<i;++s)this._destroyDatasetMeta(s);t.splice(e,i-e)}this._sortedMetasets=t.slice(0).sort(Xm("order","index"))}_removeUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=this;t.length>e.length&&delete this._stacks,t.forEach((i,s)=>{e.filter(r=>r===i._dataset).length===0&&this._destroyDatasetMeta(s)})}buildOrUpdateControllers(){const t=[],e=this.data.datasets;let i,s;for(this._removeUnreferencedMetasets(),i=0,s=e.length;i<s;i++){const r=e[i];let o=this.getDatasetMeta(i);const a=r.type||this.config.type;if(o.type&&o.type!==a&&(this._destroyDatasetMeta(i),o=this.getDatasetMeta(i)),o.type=a,o.indexAxis=r.indexAxis||Ih(a,this.options),o.order=r.order||0,o.index=i,o.label=""+r.label,o.visible=this.isDatasetVisible(i),o.controller)o.controller.updateIndex(i),o.controller.linkScales();else{const l=qn.getController(a),{datasetElementType:c,dataElementType:h}=Bt.datasets[a];Object.assign(l.prototype,{dataElementType:qn.getElement(h),datasetElementType:c&&qn.getElement(c)}),o.controller=new l(this,i),t.push(o.controller)}}return this._updateMetasets(),t}_resetElements(){Yt(this.data.datasets,(t,e)=>{this.getDatasetMeta(e).controller.reset()},this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(t){const e=this.config;e.update();const i=this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!i.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0})===!1)return;const r=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let o=0;for(let c=0,h=this.data.datasets.length;c<h;c++){const{controller:u}=this.getDatasetMeta(c),d=!s&&r.indexOf(u)===-1;u.buildOrUpdateElements(d),o=Math.max(+u.getMaxOverflow(),o)}o=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||Yt(r,c=>{c.reset()}),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(Xm("z","_idx"));const{_active:a,_lastEvent:l}=this;l?this._eventHandler(l,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){Yt(this.scales,t=>{on.removeBox(this,t)}),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const t=this.options,e=new Set(Object.keys(this._listeners)),i=new Set(t.events);(!Ep(e,i)||!!this._responsiveListeners!==t.responsive)&&(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:t}=this,e=this._getUniformDataChanges()||[];for(const{method:i,start:s,count:r}of e){const o=i==="_removeElements"?-r:r;l1(t,s,o)}}_getUniformDataChanges(){const t=this._dataChanges;if(!t||!t.length)return;this._dataChanges=[];const e=this.data.datasets.length,i=r=>new Set(t.filter(o=>o[0]===r).map((o,a)=>a+","+o.splice(1).join(","))),s=i(0);for(let r=1;r<e;r++)if(!Ep(s,i(r)))return;return Array.from(s).map(r=>r.split(",")).map(r=>({method:r[1],start:+r[2],count:+r[3]}))}_updateLayout(t){if(this.notifyPlugins("beforeLayout",{cancelable:!0})===!1)return;on.update(this,this.width,this.height,t);const e=this.chartArea,i=e.width<=0||e.height<=0;this._layers=[],Yt(this.boxes,s=>{i&&s.position==="chartArea"||(s.configure&&s.configure(),this._layers.push(...s._layers()))},this),this._layers.forEach((s,r)=>{s._idx=r}),this.notifyPlugins("afterLayout")}_updateDatasets(t){if(this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})!==!1){for(let e=0,i=this.data.datasets.length;e<i;++e)this.getDatasetMeta(e).controller.configure();for(let e=0,i=this.data.datasets.length;e<i;++e)this._updateDataset(e,ui(t)?t({datasetIndex:e}):t);this.notifyPlugins("afterDatasetsUpdate",{mode:t})}}_updateDataset(t,e){const i=this.getDatasetMeta(t),s={meta:i,index:t,mode:e,cancelable:!0};this.notifyPlugins("beforeDatasetUpdate",s)!==!1&&(i.controller._update(e),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}render(){this.notifyPlugins("beforeRender",{cancelable:!0})!==!1&&(jn.has(this)?this.attached&&!jn.running(this)&&jn.start(this):(this.draw(),$m({chart:this})))}draw(){let t;if(this._resizeBeforeDraw){const{width:i,height:s}=this._resizeBeforeDraw;this._resize(i,s),this._resizeBeforeDraw=null}if(this.clear(),this.width<=0||this.height<=0||this.notifyPlugins("beforeDraw",{cancelable:!0})===!1)return;const e=this._layers;for(t=0;t<e.length&&e[t].z<=0;++t)e[t].draw(this.chartArea);for(this._drawDatasets();t<e.length;++t)e[t].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(t){const e=this._sortedMetasets,i=[];let s,r;for(s=0,r=e.length;s<r;++s){const o=e[s];(!t||o.visible)&&i.push(o)}return i}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0})===!1)return;const t=this.getSortedVisibleDatasetMetas();for(let e=t.length-1;e>=0;--e)this._drawDataset(t[e]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(t){const e=this.ctx,i=t._clip,s=!i.disabled,r=this.chartArea,o={meta:t,index:t.index,cancelable:!0};this.notifyPlugins("beforeDatasetDraw",o)!==!1&&(s&&uh(e,{left:i.left===!1?0:r.left-i.left,right:i.right===!1?this.width:r.right+i.right,top:i.top===!1?0:r.top-i.top,bottom:i.bottom===!1?this.height:r.bottom+i.bottom}),t.controller.draw(),s&&dh(e),o.cancelable=!1,this.notifyPlugins("afterDatasetDraw",o))}getElementsAtEventForMode(t,e,i,s){const r=oS.modes[e];return typeof r=="function"?r(this,t,i,s):[]}getDatasetMeta(t){const e=this.data.datasets[t],i=this._metasets;let s=i.filter(r=>r&&r._dataset===e).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&&e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}getContext(){return this.$context||(this.$context=fi(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(t){const e=this.data.datasets[t];if(!e)return!1;const i=this.getDatasetMeta(t);return typeof i.hidden=="boolean"?!i.hidden:!e.hidden}setDatasetVisibility(t,e){const i=this.getDatasetMeta(t);i.hidden=!e}toggleDataVisibility(t){this._hiddenIndices[t]=!this._hiddenIndices[t]}getDataVisibility(t){return!this._hiddenIndices[t]}_updateVisibility(t,e,i){const s=i?"show":"hide",r=this.getDatasetMeta(t),o=r.controller._resolveAnimations(void 0,s);nn(e)?(r.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(r,{visible:i}),this.update(a=>a.datasetIndex===t?s:void 0))}hide(t,e){this._updateVisibility(t,e,!1)}show(t,e){this._updateVisibility(t,e,!0)}_destroyDatasetMeta(t){const e=this._metasets[t];e&&e.controller&&e.controller._destroy(),delete this._metasets[t]}_stop(){let t,e;for(this.stop(),jn.remove(this),t=0,e=this.data.datasets.length;t<e;++t)this._destroyDatasetMeta(t)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:t,ctx:e}=this;this._stop(),this.config.clearCache(),t&&(this.unbindEvents(),Wp(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),this.notifyPlugins("destroy"),delete $a[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(...t){return this.canvas.toDataURL(...t)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const t=this._listeners,e=this.platform,i=(r,o)=>{e.addEventListener(this,r,o),t[r]=o},s=(r,o,a)=>{r.offsetX=o,r.offsetY=a,this._eventHandler(r)};Yt(this.options.events,r=>i(r,s))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const t=this._responsiveListeners,e=this.platform,i=(l,c)=>{e.addEventListener(this,l,c),t[l]=c},s=(l,c)=>{t[l]&&(e.removeEventListener(this,l,c),delete t[l])},r=(l,c)=>{this.canvas&&this.resize(l,c)};let o;const a=()=>{s("attach",a),this.attached=!0,this.resize(),i("resize",r),i("detach",o)};o=()=>{this.attached=!1,s("resize",r),this._stop(),this._resize(0,0),i("attach",a)},e.isAttached(this.canvas)?a():o()}unbindEvents(){Yt(this._listeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._listeners={},Yt(this._responsiveListeners,(t,e)=>{this.platform.removeEventListener(this,e,t)}),this._responsiveListeners=void 0}updateHoverStyle(t,e,i){const s=i?"set":"remove";let r,o,a,l;for(e==="dataset"&&(r=this.getDatasetMeta(t[0].datasetIndex),r.controller["_"+s+"DatasetHoverStyle"]()),a=0,l=t.length;a<l;++a){o=t[a];const c=o&&this.getDatasetMeta(o.datasetIndex).controller;c&&c[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}}getActiveElements(){return this._active||[]}setActiveElements(t){const e=this._active||[],i=t.map(({datasetIndex:r,index:o})=>{const a=this.getDatasetMeta(r);if(!a)throw new Error("No dataset found at index "+r);return{datasetIndex:r,element:a.data[o],index:o}});!Sa(i,e)&&(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}notifyPlugins(t,e,i){return this._plugins.notify(this,t,e,i)}_updateHoverStyles(t,e,i){const s=this.options.hover,r=(l,c)=>l.filter(h=>!c.some(u=>h.datasetIndex===u.datasetIndex&&h.index===u.index)),o=r(e,t),a=i?t:r(t,e);o.length&&this.updateHoverStyle(o,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(t,e){const i={event:t,replay:e,cancelable:!0,inChartArea:Zi(t,this.chartArea,this._minPadding)},s=o=>(o.options.events||this.options.events).includes(t.native.type);if(this.notifyPlugins("beforeEvent",i,s)===!1)return;const r=this._handleEvent(t,e,i.inChartArea);return i.cancelable=!1,this.notifyPlugins("afterEvent",i,s),(r||i.changed)&&this.render(),this}_handleEvent(t,e,i){const{_active:s=[],options:r}=this,o=e,a=this._getActiveElements(t,s,i,o),l=eM(t),c=c1(t,this._lastEvent,i,l);i&&(this._lastEvent=null,ne(r.onHover,[t,a,this],this),l&&ne(r.onClick,[t,a,this],this));const h=!Sa(a,s);return(h||e)&&(this._active=a,this._updateHoverStyles(a,s,e)),this._lastEvent=c,h}_getActiveElements(t,e,i,s){if(t.type==="mouseout")return[];if(!i)return e;const r=this.options.hover;return this.getElementsAtEventForMode(t,r.mode,r,s)}}const Km=()=>Yt(Jm.instances,n=>n._plugins.invalidate()),pi=!0;Object.defineProperties(Jm,{defaults:{enumerable:pi,value:Bt},instances:{enumerable:pi,value:$a},overrides:{enumerable:pi,value:$i},registry:{enumerable:pi,value:qn},version:{enumerable:pi,value:r1},getChart:{enumerable:pi,value:Zm},register:{enumerable:pi,value:(...n)=>{qn.add(...n),Km()}},unregister:{enumerable:pi,value:(...n)=>{qn.remove(...n),Km()}}});function Qm(n,t,e){const{startAngle:i,pixelMargin:s,x:r,y:o,outerRadius:a,innerRadius:l}=t;let c=s/a;n.beginPath(),n.arc(r,o,a,i-c,e+c),l>s?(c=s/l,n.arc(r,o,l,e+c,i-c,!0)):n.arc(r,o,s,e+ue,i-ue),n.closePath(),n.clip()}function h1(n){return fh(n,["outerStart","outerEnd","innerStart","innerEnd"])}function u1(n,t,e,i){const s=h1(n.options.borderRadius),r=(e-t)/2,o=Math.min(r,i*t/2),a=l=>{const c=(e-Math.min(r,l))*i/2;return Pe(l,0,Math.min(r,c))};return{outerStart:a(s.outerStart),outerEnd:a(s.outerEnd),innerStart:Pe(s.innerStart,0,o),innerEnd:Pe(s.innerEnd,0,o)}}function Bs(n,t,e,i){return{x:e+n*Math.cos(t),y:i+n*Math.sin(t)}}function Oh(n,t,e,i,s){const{x:r,y:o,startAngle:a,pixelMargin:l,innerRadius:c}=t,h=Math.max(t.outerRadius+i+e-l,0),u=c>0?c+i+e+l:0;let d=0;const f=s-a;if(i){const k=c>0?c-i:0,U=h>0?h-i:0,ct=(k+U)/2,xt=ct!==0?f*ct/(ct+i):f;d=(f-xt)/2}const p=Math.max(.001,f*h-e/oe)/h,x=(f-p)/2,_=a+x+d,m=s-x-d,{outerStart:g,outerEnd:S,innerStart:v,innerEnd:E}=u1(t,u,h,m-_),R=h-g,D=h-S,$=_+g/R,it=m-S/D,tt=u+v,N=u+E,T=_+v/tt,A=m-E/N;if(n.beginPath(),n.arc(r,o,h,$,it),S>0){const k=Bs(D,it,r,o);n.arc(k.x,k.y,S,it,m+ue)}const W=Bs(N,m,r,o);if(n.lineTo(W.x,W.y),E>0){const k=Bs(N,A,r,o);n.arc(k.x,k.y,E,m+ue,A+Math.PI)}if(n.arc(r,o,u,m-E/u,_+v/u,!0),v>0){const k=Bs(tt,T,r,o);n.arc(k.x,k.y,v,T+Math.PI,_-ue)}const V=Bs(R,_,r,o);if(n.lineTo(V.x,V.y),g>0){const k=Bs(R,$,r,o);n.arc(k.x,k.y,g,_-ue,$)}n.closePath()}function d1(n,t,e,i){const{fullCircles:s,startAngle:r,circumference:o}=t;let a=t.endAngle;if(s){Oh(n,t,e,i,r+ie);for(let l=0;l<s;++l)n.fill();isNaN(o)||(a=r+o%ie,o%ie==0&&(a+=ie))}return Oh(n,t,e,i,a),n.fill(),a}function f1(n,t,e){const{x:i,y:s,startAngle:r,pixelMargin:o,fullCircles:a}=t,l=Math.max(t.outerRadius-o,0),c=t.innerRadius+o;let h;for(e&&Qm(n,t,r+ie),n.beginPath(),n.arc(i,s,c,r+ie,r,!0),h=0;h<a;++h)n.stroke();for(n.beginPath(),n.arc(i,s,l,r,r+ie),h=0;h<a;++h)n.stroke()}function p1(n,t,e,i,s){const{options:r}=t,{borderWidth:o,borderJoinStyle:a}=r,l=r.borderAlign==="inner";!o||(l?(n.lineWidth=o*2,n.lineJoin=a||"round"):(n.lineWidth=o,n.lineJoin=a||"bevel"),t.fullCircles&&f1(n,t,l),l&&Qm(n,t,s),Oh(n,t,e,i,s),n.stroke())}class kh extends gn{constructor(t){super();this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.getProps(["x","y"],i),{angle:r,distance:o}=Rp(s,{x:t,y:e}),{startAngle:a,endAngle:l,innerRadius:c,outerRadius:h,circumference:u}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),d=this.options.spacing/2,p=Ot(u,l-a)>=ie||Zr(r,a,l),x=di(o,c+d,h+d);return p&&x}getCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:r,innerRadius:o,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius","circumference"],t),{offset:l,spacing:c}=this.options,h=(s+r)/2,u=(o+a+c+l)/2;return{x:e+Math.cos(h)*u,y:i+Math.sin(h)*u}}tooltipPosition(t){return this.getCenterPoint(t)}draw(t){const{options:e,circumference:i}=this,s=(e.offset||0)/2,r=(e.spacing||0)/2;if(this.pixelMargin=e.borderAlign==="inner"?.33:0,this.fullCircles=i>ie?Math.floor(i/ie):0,i===0||this.innerRadius<0||this.outerRadius<0)return;t.save();let o=0;if(s){o=s/2;const l=(this.startAngle+this.endAngle)/2;t.translate(Math.cos(l)*o,Math.sin(l)*o),this.circumference>=oe&&(o=s)}t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor;const a=d1(t,this,o,r);p1(t,this,o,r,a),t.restore()}}kh.id="arc";kh.defaults={borderAlign:"center",borderColor:"#fff",borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0};kh.defaultRoutes={backgroundColor:"backgroundColor"};function tg(n,t,e=t){n.lineCap=Ot(e.borderCapStyle,t.borderCapStyle),n.setLineDash(Ot(e.borderDash,t.borderDash)),n.lineDashOffset=Ot(e.borderDashOffset,t.borderDashOffset),n.lineJoin=Ot(e.borderJoinStyle,t.borderJoinStyle),n.lineWidth=Ot(e.borderWidth,t.borderWidth),n.strokeStyle=Ot(e.borderColor,t.borderColor)}function m1(n,t,e){n.lineTo(e.x,e.y)}function g1(n){return n.stepped?RM:n.tension||n.cubicInterpolationMode==="monotone"?PM:m1}function eg(n,t,e={}){const i=n.length,{start:s=0,end:r=i-1}=e,{start:o,end:a}=t,l=Math.max(s,o),c=Math.min(r,a),h=s<o&&r<o||s>a&&r>a;return{count:i,start:l,loop:t.loop,ilen:c<l&&!h?i+c-l:c-l}}function x1(n,t,e,i){const{points:s,options:r}=t,{count:o,start:a,loop:l,ilen:c}=eg(s,e,i),h=g1(r);let{move:u=!0,reverse:d}=i||{},f,p,x;for(f=0;f<=c;++f)p=s[(a+(d?c-f:f))%o],!p.skip&&(u?(n.moveTo(p.x,p.y),u=!1):h(n,x,p,d,r.stepped),x=p);return l&&(p=s[(a+(d?c:0))%o],h(n,x,p,d,r.stepped)),!!l}function _1(n,t,e,i){const s=t.points,{count:r,start:o,ilen:a}=eg(s,e,i),{move:l=!0,reverse:c}=i||{};let h=0,u=0,d,f,p,x,_,m;const g=v=>(o+(c?a-v:v))%r,S=()=>{x!==_&&(n.lineTo(h,_),n.lineTo(h,x),n.lineTo(h,m))};for(l&&(f=s[g(0)],n.moveTo(f.x,f.y)),d=0;d<=a;++d){if(f=s[g(d)],f.skip)continue;const v=f.x,E=f.y,R=v|0;R===p?(E<x?x=E:E>_&&(_=E),h=(u*h+v)/++u):(S(),n.lineTo(v,E),p=R,u=0,x=_=E),m=E}S()}function Nh(n){const t=n.options,e=t.borderDash&&t.borderDash.length;return!n._decimated&&!n._loop&&!t.tension&&t.cubicInterpolationMode!=="monotone"&&!t.stepped&&!e?_1:x1}function y1(n){return n.stepped?uw:n.tension||n.cubicInterpolationMode==="monotone"?dw:ts}function v1(n,t,e,i){let s=t._path;s||(s=t._path=new Path2D,t.path(s,e,i)&&s.closePath()),tg(n,t.options),n.stroke(s)}function b1(n,t,e,i){const{segments:s,options:r}=t,o=Nh(t);for(const a of s)tg(n,r,a.style),n.beginPath(),o(n,t,a,{start:e,end:e+i-1})&&n.closePath(),n.stroke()}const M1=typeof Path2D=="function";function w1(n,t,e,i){M1&&!t.options.segment?v1(n,t,e,i):b1(n,t,e,i)}class Ya extends gn{constructor(t){super();this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&&Object.assign(this,t)}updateControlPoints(t,e){const i=this.options;if((i.tension||i.cubicInterpolationMode==="monotone")&&!i.stepped&&!this._pointsUpdated){const s=i.spanGaps?this._loop:this._fullLoop;iw(this._points,i,t,s,e),this._pointsUpdated=!0}}set points(t){this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=bw(this,this.options.segment))}first(){const t=this.segments,e=this.points;return t.length&&e[t[0].start]}last(){const t=this.segments,e=this.points,i=t.length;return i&&e[t[i-1].end]}interpolate(t,e){const i=this.options,s=t[e],r=this.points,o=_w(this,{property:e,start:s,end:s});if(!o.length)return;const a=[],l=y1(i);let c,h;for(c=0,h=o.length;c<h;++c){const{start:u,end:d}=o[c],f=r[u],p=r[d];if(f===p){a.push(f);continue}const x=Math.abs((s-f[e])/(p[e]-f[e])),_=l(f,p,x,i.stepped);_[e]=t[e],a.push(_)}return a.length===1?a[0]:a}pathSegment(t,e,i){return Nh(this)(t,this,e,i)}path(t,e,i){const s=this.segments,r=Nh(this);let o=this._loop;e=e||0,i=i||this.points.length-e;for(const a of s)o&=r(t,this,a,{start:e,end:e+i-1});return!!o}draw(t,e,i,s){const r=this.options||{};(this.points||[]).length&&r.borderWidth&&(t.save(),w1(t,this,i,s),t.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}Ya.id="line";Ya.defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};Ya.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};Ya.descriptors={_scriptable:!0,_indexable:n=>n!=="borderDash"&&n!=="fill"};function ng(n,t,e,i){const s=n.options,{[e]:r}=n.getProps([e],i);return Math.abs(t-r)<s.radius+s.hitRadius}class zh extends gn{constructor(t){super();this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&&Object.assign(this,t)}inRange(t,e,i){const s=this.options,{x:r,y:o}=this.getProps(["x","y"],i);return Math.pow(t-r,2)+Math.pow(e-o,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(t,e){return ng(this,t,"x",e)}inYRange(t,e){return ng(this,t,"y",e)}getCenterPoint(t){const{x:e,y:i}=this.getProps(["x","y"],t);return{x:e,y:i}}size(t){t=t||this.options||{};let e=t.radius||0;e=Math.max(e,e&&t.hoverRadius||0);const i=e&&t.borderWidth||0;return(e+i)*2}draw(t,e){const i=this.options;this.skip||i.radius<.1||!Zi(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,Fa(t,i,this.x,this.y))}getRange(){const t=this.options||{};return t.radius+t.hitRadius}}zh.id="point";zh.defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};zh.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};function ig(n,t){const{x:e,y:i,base:s,width:r,height:o}=n.getProps(["x","y","base","width","height"],t);let a,l,c,h,u;return n.horizontal?(u=o/2,a=Math.min(e,s),l=Math.max(e,s),c=i-u,h=i+u):(u=r/2,a=e-u,l=e+u,c=Math.min(i,s),h=Math.max(i,s)),{left:a,top:c,right:l,bottom:h}}function mi(n,t,e,i){return n?0:Pe(t,e,i)}function S1(n,t,e){const i=n.options.borderWidth,s=n.borderSkipped,r=Gp(i);return{t:mi(s.top,r.top,0,e),r:mi(s.right,r.right,0,t),b:mi(s.bottom,r.bottom,0,e),l:mi(s.left,r.left,0,t)}}function E1(n,t,e){const{enableBorderRadius:i}=n.getProps(["enableBorderRadius"]),s=n.options.borderRadius,r=Os(s),o=Math.min(t,e),a=n.borderSkipped,l=i||Wt(s);return{topLeft:mi(!l||a.top||a.left,r.topLeft,0,o),topRight:mi(!l||a.top||a.right,r.topRight,0,o),bottomLeft:mi(!l||a.bottom||a.left,r.bottomLeft,0,o),bottomRight:mi(!l||a.bottom||a.right,r.bottomRight,0,o)}}function T1(n){const t=ig(n),e=t.right-t.left,i=t.bottom-t.top,s=S1(n,e/2,i/2),r=E1(n,e/2,i/2);return{outer:{x:t.left,y:t.top,w:e,h:i,radius:r},inner:{x:t.left+s.l,y:t.top+s.t,w:e-s.l-s.r,h:i-s.t-s.b,radius:{topLeft:Math.max(0,r.topLeft-Math.max(s.t,s.l)),topRight:Math.max(0,r.topRight-Math.max(s.t,s.r)),bottomLeft:Math.max(0,r.bottomLeft-Math.max(s.b,s.l)),bottomRight:Math.max(0,r.bottomRight-Math.max(s.b,s.r))}}}}function Bh(n,t,e,i){const s=t===null,r=e===null,a=n&&!(s&&r)&&ig(n,i);return a&&(s||di(t,a.left,a.right))&&(r||di(e,a.top,a.bottom))}function A1(n){return n.topLeft||n.topRight||n.bottomLeft||n.bottomRight}function C1(n,t){n.rect(t.x,t.y,t.w,t.h)}function Hh(n,t,e={}){const i=n.x!==e.x?-t:0,s=n.y!==e.y?-t:0,r=(n.x+n.w!==e.x+e.w?t:0)-i,o=(n.y+n.h!==e.y+e.h?t:0)-s;return{x:n.x+i,y:n.y+s,w:n.w+r,h:n.h+o,radius:n.radius}}class Uh extends gn{constructor(t){super();this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&&Object.assign(this,t)}draw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=this,{inner:r,outer:o}=T1(this),a=A1(o.radius)?Oa:C1;t.save(),(o.w!==r.w||o.h!==r.h)&&(t.beginPath(),a(t,Hh(o,e,r)),t.clip(),a(t,Hh(r,-e,o)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),a(t,Hh(r,e)),t.fillStyle=s,t.fill(),t.restore()}inRange(t,e,i){return Bh(this,t,e,i)}inXRange(t,e){return Bh(this,t,null,e)}inYRange(t,e){return Bh(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,base:s,horizontal:r}=this.getProps(["x","y","base","horizontal"],t);return{x:r?(e+s)/2:e,y:r?i:(i+s)/2}}getRange(t){return t==="x"?this.width/2:this.height/2}}Uh.id="bar";Uh.defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};Uh.defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};const sg=(n,t)=>{let{boxHeight:e=t,boxWidth:i=t}=n;return n.usePointStyle&&(e=Math.min(e,t),i=Math.min(i,t)),{boxWidth:i,boxHeight:e,itemHeight:Math.max(t,e)}},L1=(n,t)=>n!==null&&t!==null&&n.datasetIndex===t.datasetIndex&&n.index===t.index;class rg extends gn{constructor(t){super();this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e,i){this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const t=this.options.labels||{};let e=ne(t.generateLabels,[this.chart],this)||[];t.filter&&(e=e.filter(i=>t.filter(i,this.chart.data))),t.sort&&(e=e.sort((i,s)=>t.sort(i,s,this.chart.data))),this.options.reverse&&e.reverse(),this.legendItems=e}fit(){const{options:t,ctx:e}=this;if(!t.display){this.width=this.height=0;return}const i=t.labels,s=ge(i.font),r=s.size,o=this._computeTitleHeight(),{boxWidth:a,itemHeight:l}=sg(i,r);let c,h;e.font=s.string,this.isHorizontal()?(c=this.maxWidth,h=this._fitRows(o,r,a,l)+10):(h=this.maxHeight,c=this._fitCols(o,r,a,l)+10),this.width=Math.min(c,t.maxWidth||this.maxWidth),this.height=Math.min(h,t.maxHeight||this.maxHeight)}_fitRows(t,e,i,s){const{ctx:r,maxWidth:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.lineWidths=[0],h=s+a;let u=t;r.textAlign="left",r.textBaseline="middle";let d=-1,f=-h;return this.legendItems.forEach((p,x)=>{const _=i+e/2+r.measureText(p.text).width;(x===0||c[c.length-1]+_+2*a>o)&&(u+=h,c[c.length-(x>0?0:1)]=0,f+=h,d++),l[x]={left:0,top:f,row:d,width:_,height:s},c[c.length-1]+=_+a}),u}_fitCols(t,e,i,s){const{ctx:r,maxHeight:o,options:{labels:{padding:a}}}=this,l=this.legendHitBoxes=[],c=this.columnSizes=[],h=o-t;let u=a,d=0,f=0,p=0,x=0;return this.legendItems.forEach((_,m)=>{const g=i+e/2+r.measureText(_.text).width;m>0&&f+s+2*a>h&&(u+=d+a,c.push({width:d,height:f}),p+=d+a,x++,d=f=0),l[m]={left:p,top:f,col:x,width:g,height:s},d=Math.max(d,g),f+=s+a}),u+=d,c.push({width:d,height:f}),u}adjustHitBoxes(){if(!this.options.display)return;const t=this._computeTitleHeight(),{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:r}}=this,o=zs(r,this.left,this.width);if(this.isHorizontal()){let a=0,l=Re(i,this.left+s,this.right-this.lineWidths[a]);for(const c of e)a!==c.row&&(a=c.row,l=Re(i,this.left+s,this.right-this.lineWidths[a])),c.top+=this.top+t+s,c.left=o.leftForLtr(o.x(l),c.width),l+=c.width+s}else{let a=0,l=Re(i,this.top+t+s,this.bottom-this.columnSizes[a].height);for(const c of e)c.col!==a&&(a=c.col,l=Re(i,this.top+t+s,this.bottom-this.columnSizes[a].height)),c.top=l,c.left+=this.left+s,c.left=o.leftForLtr(o.x(c.left),c.width),l+=c.height+s}}isHorizontal(){return this.options.position==="top"||this.options.position==="bottom"}draw(){if(this.options.display){const t=this.ctx;uh(t,this),this._draw(),dh(t)}}_draw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=this,{align:r,labels:o}=t,a=Bt.color,l=zs(t.rtl,this.left,this.width),c=ge(o.font),{color:h,padding:u}=o,d=c.size,f=d/2;let p;this.drawTitle(),s.textAlign=l.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=c.string;const{boxWidth:x,boxHeight:_,itemHeight:m}=sg(o,d),g=function(D,$,it){if(isNaN(x)||x<=0||isNaN(_)||_<0)return;s.save();const tt=Ot(it.lineWidth,1);if(s.fillStyle=Ot(it.fillStyle,a),s.lineCap=Ot(it.lineCap,"butt"),s.lineDashOffset=Ot(it.lineDashOffset,0),s.lineJoin=Ot(it.lineJoin,"miter"),s.lineWidth=tt,s.strokeStyle=Ot(it.strokeStyle,a),s.setLineDash(Ot(it.lineDash,[])),o.usePointStyle){const N={radius:x*Math.SQRT2/2,pointStyle:it.pointStyle,rotation:it.rotation,borderWidth:tt},T=l.xPlus(D,x/2),A=$+f;Fa(s,N,T,A)}else{const N=$+Math.max((d-_)/2,0),T=l.leftForLtr(D,x),A=Os(it.borderRadius);s.beginPath(),Object.values(A).some(W=>W!==0)?Oa(s,{x:T,y:N,w:x,h:_,radius:A}):s.rect(T,N,x,_),s.fill(),tt!==0&&s.stroke()}s.restore()},S=function(D,$,it){Ji(s,it.text,D,$+m/2,c,{strikethrough:it.hidden,textAlign:l.textAlign(it.textAlign)})},v=this.isHorizontal(),E=this._computeTitleHeight();v?p={x:Re(r,this.left+u,this.right-i[0]),y:this.top+u+E,line:0}:p={x:this.left+u,y:Re(r,this.top+E+u,this.bottom-e[0].height),line:0},om(this.ctx,t.textDirection);const R=m+u;this.legendItems.forEach((D,$)=>{s.strokeStyle=D.fontColor||h,s.fillStyle=D.fontColor||h;const it=s.measureText(D.text).width,tt=l.textAlign(D.textAlign||(D.textAlign=o.textAlign)),N=x+f+it;let T=p.x,A=p.y;l.setWidth(this.width),v?$>0&&T+N+u>this.right&&(A=p.y+=R,p.line++,T=p.x=Re(r,this.left+u,this.right-i[p.line])):$>0&&A+R>this.bottom&&(T=p.x=T+e[p.line].width+u,p.line++,A=p.y=Re(r,this.top+E+u,this.bottom-e[p.line].height));const W=l.x(T);g(W,A,D),T=$b(tt,T+x+f,v?T+N:this.right,t.rtl),S(l.x(T),A,D),v?p.x+=N+u:p.y+=R}),am(this.ctx,t.textDirection)}drawTitle(){const t=this.options,e=t.title,i=ge(e.font),s=De(e.padding);if(!e.display)return;const r=zs(t.rtl,this.left,this.width),o=this.ctx,a=e.position,l=i.size/2,c=s.top+l;let h,u=this.left,d=this.width;if(this.isHorizontal())d=Math.max(...this.lineWidths),h=this.top+c,u=Re(t.align,u,this.right-d);else{const p=this.columnSizes.reduce((x,_)=>Math.max(x,_.height),0);h=c+Re(t.align,this.top,this.bottom-p-t.labels.padding-this._computeTitleHeight())}const f=Re(a,u,u+d);o.textAlign=r.textAlign(Qc(a)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,Ji(o,e.text,f,h,i)}_computeTitleHeight(){const t=this.options.title,e=ge(t.font),i=De(t.padding);return t.display?e.lineHeight+i.height:0}_getLegendItemAt(t,e){let i,s,r;if(di(t,this.left,this.right)&&di(e,this.top,this.bottom)){for(r=this.legendHitBoxes,i=0;i<r.length;++i)if(s=r[i],di(t,s.left,s.left+s.width)&&di(e,s.top,s.top+s.height))return this.legendItems[i]}return null}handleEvent(t){const e=this.options;if(!R1(t.type,e))return;const i=this._getLegendItemAt(t.x,t.y);if(t.type==="mousemove"){const s=this._hoveredItem,r=L1(s,i);s&&!r&&ne(e.onLeave,[t,s,this],this),this._hoveredItem=i,i&&!r&&ne(e.onHover,[t,i,this],this)}else i&&ne(e.onClick,[t,i,this],this)}}function R1(n,t){return!!(n==="mousemove"&&(t.onHover||t.onLeave)||t.onClick&&(n==="click"||n==="mouseup"))}var O3={id:"legend",_element:rg,start(n,t,e){const i=n.legend=new rg({ctx:n.ctx,options:e,chart:n});on.configure(n,i,e),on.addBox(n,i)},stop(n){on.removeBox(n,n.legend),delete n.legend},beforeUpdate(n,t,e){const i=n.legend;on.configure(n,i,e),i.options=e},afterUpdate(n){const t=n.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(n,t){t.replay||n.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(n,t,e){const i=t.datasetIndex,s=e.chart;s.isDatasetVisible(i)?(s.hide(i),t.hidden=!0):(s.show(i),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:n=>n.chart.options.color,boxWidth:40,padding:10,generateLabels(n){const t=n.data.datasets,{labels:{usePointStyle:e,pointStyle:i,textAlign:s,color:r}}=n.legend.options;return n._getSortedDatasetMetas().map(o=>{const a=o.controller.getStyle(e?0:void 0),l=De(a.borderWidth);return{text:t[o.index].label,fillStyle:a.backgroundColor,fontColor:r,hidden:!o.visible,lineCap:a.borderCapStyle,lineDash:a.borderDash,lineDashOffset:a.borderDashOffset,lineJoin:a.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:a.borderColor,pointStyle:i||a.pointStyle,rotation:a.rotation,textAlign:s||a.textAlign,borderRadius:0,datasetIndex:o.index}},this)}},title:{color:n=>n.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:n=>!n.startsWith("on"),labels:{_scriptable:n=>!["generateLabels","filter","sort"].includes(n)}}};class og extends gn{constructor(t){super();this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(t,e){const i=this.options;if(this.left=0,this.top=0,!i.display){this.width=this.height=this.right=this.bottom=0;return}this.width=this.right=t,this.height=this.bottom=e;const s=re(i.text)?i.text.length:1;this._padding=De(i.padding);const r=s*ge(i.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=r:this.width=r}isHorizontal(){const t=this.options.position;return t==="top"||t==="bottom"}_drawArgs(t){const{top:e,left:i,bottom:s,right:r,options:o}=this,a=o.align;let l=0,c,h,u;return this.isHorizontal()?(h=Re(a,i,r),u=e+t,c=r-i):(o.position==="left"?(h=i+t,u=Re(a,s,e),l=oe*-.5):(h=r-t,u=Re(a,e,s),l=oe*.5),c=s-e),{titleX:h,titleY:u,maxWidth:c,rotation:l}}draw(){const t=this.ctx,e=this.options;if(!e.display)return;const i=ge(e.font),r=i.lineHeight/2+this._padding.top,{titleX:o,titleY:a,maxWidth:l,rotation:c}=this._drawArgs(r);Ji(t,e.text,0,0,i,{color:e.color,maxWidth:l,rotation:c,textAlign:Qc(e.align),textBaseline:"middle",translation:[o,a]})}}function P1(n,t){const e=new og({ctx:n.ctx,options:t,chart:n});on.configure(n,e,t),on.addBox(n,e),n.titleBlock=e}var k3={id:"title",_element:og,start(n,t,e){P1(n,e)},stop(n){const t=n.titleBlock;on.removeBox(n,t),delete n.titleBlock},beforeUpdate(n,t,e){const i=n.titleBlock;on.configure(n,i,e),i.options=e},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const fo={average(n){if(!n.length)return!1;let t,e,i=0,s=0,r=0;for(t=0,e=n.length;t<e;++t){const o=n[t].element;if(o&&o.hasValue()){const a=o.tooltipPosition();i+=a.x,s+=a.y,++r}}return{x:i/r,y:s/r}},nearest(n,t){if(!n.length)return!1;let e=t.x,i=t.y,s=Number.POSITIVE_INFINITY,r,o,a;for(r=0,o=n.length;r<o;++r){const l=n[r].element;if(l&&l.hasValue()){const c=l.getCenterPoint(),h=nh(t,c);h<s&&(s=h,a=l)}}if(a){const l=a.tooltipPosition();e=l.x,i=l.y}return{x:e,y:i}}};function In(n,t){return t&&(re(t)?Array.prototype.push.apply(n,t):n.push(t)),n}function Xn(n){return(typeof n=="string"||n instanceof String)&&n.indexOf(`
`)>-1?n.split(`
`):n}function D1(n,t){const{element:e,datasetIndex:i,index:s}=t,r=n.getDatasetMeta(i).controller,{label:o,value:a}=r.getLabelAndValue(s);return{chart:n,label:o,parsed:r.getParsed(s),raw:n.data.datasets[i].data[s],formattedValue:a,dataset:r.getDataset(),dataIndex:s,datasetIndex:i,element:e}}function ag(n,t){const e=n.chart.ctx,{body:i,footer:s,title:r}=n,{boxWidth:o,boxHeight:a}=t,l=ge(t.bodyFont),c=ge(t.titleFont),h=ge(t.footerFont),u=r.length,d=s.length,f=i.length,p=De(t.padding);let x=p.height,_=0,m=i.reduce((v,E)=>v+E.before.length+E.lines.length+E.after.length,0);if(m+=n.beforeBody.length+n.afterBody.length,u&&(x+=u*c.lineHeight+(u-1)*t.titleSpacing+t.titleMarginBottom),m){const v=t.displayColors?Math.max(a,l.lineHeight):l.lineHeight;x+=f*v+(m-f)*l.lineHeight+(m-1)*t.bodySpacing}d&&(x+=t.footerMarginTop+d*h.lineHeight+(d-1)*t.footerSpacing);let g=0;const S=function(v){_=Math.max(_,e.measureText(v).width+g)};return e.save(),e.font=c.string,Yt(n.title,S),e.font=l.string,Yt(n.beforeBody.concat(n.afterBody),S),g=t.displayColors?o+2+t.boxPadding:0,Yt(i,v=>{Yt(v.before,S),Yt(v.lines,S),Yt(v.after,S)}),g=0,e.font=h.string,Yt(n.footer,S),e.restore(),_+=p.width,{width:_,height:x}}function I1(n,t){const{y:e,height:i}=t;return e<i/2?"top":e>n.height-i/2?"bottom":"center"}function F1(n,t,e,i){const{x:s,width:r}=i,o=e.caretSize+e.caretPadding;if(n==="left"&&s+r+o>t.width||n==="right"&&s-r-o<0)return!0}function O1(n,t,e,i){const{x:s,width:r}=e,{width:o,chartArea:{left:a,right:l}}=n;let c="center";return i==="center"?c=s<=(a+l)/2?"left":"right":s<=r/2?c="left":s>=o-r/2&&(c="right"),F1(c,n,t,e)&&(c="center"),c}function lg(n,t,e){const i=e.yAlign||t.yAlign||I1(n,e);return{xAlign:e.xAlign||t.xAlign||O1(n,t,e,i),yAlign:i}}function k1(n,t){let{x:e,width:i}=n;return t==="right"?e-=i:t==="center"&&(e-=i/2),e}function N1(n,t,e){let{y:i,height:s}=n;return t==="top"?i+=e:t==="bottom"?i-=s+e:i-=s/2,i}function cg(n,t,e,i){const{caretSize:s,caretPadding:r,cornerRadius:o}=n,{xAlign:a,yAlign:l}=e,c=s+r,{topLeft:h,topRight:u,bottomLeft:d,bottomRight:f}=Os(o);let p=k1(t,a);const x=N1(t,l,c);return l==="center"?a==="left"?p+=c:a==="right"&&(p-=c):a==="left"?p-=Math.max(h,d)+s:a==="right"&&(p+=Math.max(u,f)+s),{x:Pe(p,0,i.width-t.width),y:Pe(x,0,i.height-t.height)}}function Za(n,t,e){const i=De(e.padding);return t==="center"?n.x+n.width/2:t==="right"?n.x+n.width-i.right:n.x+i.left}function hg(n){return In([],Xn(n))}function z1(n,t,e){return fi(n,{tooltip:t,tooltipItems:e,type:"tooltip"})}function ug(n,t){const e=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return e?n.override(e):n}class Vh extends gn{constructor(t){super();this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart||t._chart,this._chart=this.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(t){this.options=t,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const t=this._cachedAnimations;if(t)return t;const e=this.chart,i=this.options.setContext(this.getContext()),s=i.enabled&&e.options.animation&&i.animations,r=new fm(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(r)),r}getContext(){return this.$context||(this.$context=z1(this.chart.getContext(),this,this._tooltipItems))}getTitle(t,e){const{callbacks:i}=e,s=i.beforeTitle.apply(this,[t]),r=i.title.apply(this,[t]),o=i.afterTitle.apply(this,[t]);let a=[];return a=In(a,Xn(s)),a=In(a,Xn(r)),a=In(a,Xn(o)),a}getBeforeBody(t,e){return hg(e.callbacks.beforeBody.apply(this,[t]))}getBody(t,e){const{callbacks:i}=e,s=[];return Yt(t,r=>{const o={before:[],lines:[],after:[]},a=ug(i,r);In(o.before,Xn(a.beforeLabel.call(this,r))),In(o.lines,a.label.call(this,r)),In(o.after,Xn(a.afterLabel.call(this,r))),s.push(o)}),s}getAfterBody(t,e){return hg(e.callbacks.afterBody.apply(this,[t]))}getFooter(t,e){const{callbacks:i}=e,s=i.beforeFooter.apply(this,[t]),r=i.footer.apply(this,[t]),o=i.afterFooter.apply(this,[t]);let a=[];return a=In(a,Xn(s)),a=In(a,Xn(r)),a=In(a,Xn(o)),a}_createItems(t){const e=this._active,i=this.chart.data,s=[],r=[],o=[];let a=[],l,c;for(l=0,c=e.length;l<c;++l)a.push(D1(this.chart,e[l]));return t.filter&&(a=a.filter((h,u,d)=>t.filter(h,u,d,i))),t.itemSort&&(a=a.sort((h,u)=>t.itemSort(h,u,i))),Yt(a,h=>{const u=ug(t.callbacks,h);s.push(u.labelColor.call(this,h)),r.push(u.labelPointStyle.call(this,h)),o.push(u.labelTextColor.call(this,h))}),this.labelColors=s,this.labelPointStyles=r,this.labelTextColors=o,this.dataPoints=a,a}update(t,e){const i=this.options.setContext(this.getContext()),s=this._active;let r,o=[];if(!s.length)this.opacity!==0&&(r={opacity:0});else{const a=fo[i.position].call(this,s,this._eventPosition);o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);const l=this._size=ag(this,i),c=Object.assign({},a,l),h=lg(this.chart,i,c),u=cg(i,c,h,this.chart);this.xAlign=h.xAlign,this.yAlign=h.yAlign,r={opacity:1,x:u.x,y:u.y,width:l.width,height:l.height,caretX:a.x,caretY:a.y}}this._tooltipItems=o,this.$context=void 0,r&&this._resolveAnimations().update(this,r),t&&i.external&&i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}drawCaret(t,e,i,s){const r=this.getCaretPosition(t,i,s);e.lineTo(r.x1,r.y1),e.lineTo(r.x2,r.y2),e.lineTo(r.x3,r.y3)}getCaretPosition(t,e,i){const{xAlign:s,yAlign:r}=this,{caretSize:o,cornerRadius:a}=i,{topLeft:l,topRight:c,bottomLeft:h,bottomRight:u}=Os(a),{x:d,y:f}=t,{width:p,height:x}=e;let _,m,g,S,v,E;return r==="center"?(v=f+x/2,s==="left"?(_=d,m=_-o,S=v+o,E=v-o):(_=d+p,m=_+o,S=v-o,E=v+o),g=_):(s==="left"?m=d+Math.max(l,h)+o:s==="right"?m=d+p-Math.max(c,u)-o:m=this.caretX,r==="top"?(S=f,v=S-o,_=m-o,g=m+o):(S=f+x,v=S+o,_=m+o,g=m-o),E=S),{x1:_,x2:m,x3:g,y1:S,y2:v,y3:E}}drawTitle(t,e,i){const s=this.title,r=s.length;let o,a,l;if(r){const c=zs(i.rtl,this.x,this.width);for(t.x=Za(this,i.titleAlign,i),e.textAlign=c.textAlign(i.titleAlign),e.textBaseline="middle",o=ge(i.titleFont),a=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,l=0;l<r;++l)e.fillText(s[l],c.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+a,l+1===r&&(t.y+=i.titleMarginBottom-a)}}_drawColorBox(t,e,i,s,r){const o=this.labelColors[i],a=this.labelPointStyles[i],{boxHeight:l,boxWidth:c,boxPadding:h}=r,u=ge(r.bodyFont),d=Za(this,"left",r),f=s.x(d),p=l<u.lineHeight?(u.lineHeight-l)/2:0,x=e.y+p;if(r.usePointStyle){const _={radius:Math.min(c,l)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},m=s.leftForLtr(f,c)+c/2,g=x+l/2;t.strokeStyle=r.multiKeyBackground,t.fillStyle=r.multiKeyBackground,Fa(t,_,m,g),t.strokeStyle=o.borderColor,t.fillStyle=o.backgroundColor,Fa(t,_,m,g)}else{t.lineWidth=o.borderWidth||1,t.strokeStyle=o.borderColor,t.setLineDash(o.borderDash||[]),t.lineDashOffset=o.borderDashOffset||0;const _=s.leftForLtr(f,c-h),m=s.leftForLtr(s.xPlus(f,1),c-h-2),g=Os(o.borderRadius);Object.values(g).some(S=>S!==0)?(t.beginPath(),t.fillStyle=r.multiKeyBackground,Oa(t,{x:_,y:x,w:c,h:l,radius:g}),t.fill(),t.stroke(),t.fillStyle=o.backgroundColor,t.beginPath(),Oa(t,{x:m,y:x+1,w:c-2,h:l-2,radius:g}),t.fill()):(t.fillStyle=r.multiKeyBackground,t.fillRect(_,x,c,l),t.strokeRect(_,x,c,l),t.fillStyle=o.backgroundColor,t.fillRect(m,x+1,c-2,l-2))}t.fillStyle=this.labelTextColors[i]}drawBody(t,e,i){const{body:s}=this,{bodySpacing:r,bodyAlign:o,displayColors:a,boxHeight:l,boxWidth:c,boxPadding:h}=i,u=ge(i.bodyFont);let d=u.lineHeight,f=0;const p=zs(i.rtl,this.x,this.width),x=function($){e.fillText($,p.x(t.x+f),t.y+d/2),t.y+=d+r},_=p.textAlign(o);let m,g,S,v,E,R,D;for(e.textAlign=o,e.textBaseline="middle",e.font=u.string,t.x=Za(this,_,i),e.fillStyle=i.bodyColor,Yt(this.beforeBody,x),f=a&&_!=="right"?o==="center"?c/2+h:c+2+h:0,v=0,R=s.length;v<R;++v){for(m=s[v],g=this.labelTextColors[v],e.fillStyle=g,Yt(m.before,x),S=m.lines,a&&S.length&&(this._drawColorBox(e,t,v,p,i),d=Math.max(u.lineHeight,l)),E=0,D=S.length;E<D;++E)x(S[E]),d=u.lineHeight;Yt(m.after,x)}f=0,d=u.lineHeight,Yt(this.afterBody,x),t.y-=r}drawFooter(t,e,i){const s=this.footer,r=s.length;let o,a;if(r){const l=zs(i.rtl,this.x,this.width);for(t.x=Za(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=l.textAlign(i.footerAlign),e.textBaseline="middle",o=ge(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,a=0;a<r;++a)e.fillText(s[a],l.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}}drawBackground(t,e,i,s){const{xAlign:r,yAlign:o}=this,{x:a,y:l}=t,{width:c,height:h}=i,{topLeft:u,topRight:d,bottomLeft:f,bottomRight:p}=Os(s.cornerRadius);e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(a+u,l),o==="top"&&this.drawCaret(t,e,i,s),e.lineTo(a+c-d,l),e.quadraticCurveTo(a+c,l,a+c,l+d),o==="center"&&r==="right"&&this.drawCaret(t,e,i,s),e.lineTo(a+c,l+h-p),e.quadraticCurveTo(a+c,l+h,a+c-p,l+h),o==="bottom"&&this.drawCaret(t,e,i,s),e.lineTo(a+f,l+h),e.quadraticCurveTo(a,l+h,a,l+h-f),o==="center"&&r==="left"&&this.drawCaret(t,e,i,s),e.lineTo(a,l+u),e.quadraticCurveTo(a,l,a+u,l),e.closePath(),e.fill(),s.borderWidth>0&&e.stroke()}_updateAnimationTarget(t){const e=this.chart,i=this.$animations,s=i&&i.x,r=i&&i.y;if(s||r){const o=fo[t.position].call(this,this._active,this._eventPosition);if(!o)return;const a=this._size=ag(this,t),l=Object.assign({},o,this._size),c=lg(e,t,l),h=cg(t,l,c,e);(s._to!==h.x||r._to!==h.y)&&(this.xAlign=c.xAlign,this.yAlign=c.yAlign,this.width=a.width,this.height=a.height,this.caretX=o.x,this.caretY=o.y,this._resolveAnimations().update(this,h))}}draw(t){const e=this.options.setContext(this.getContext());let i=this.opacity;if(!i)return;this._updateAnimationTarget(e);const s={width:this.width,height:this.height},r={x:this.x,y:this.y};i=Math.abs(i)<.001?0:i;const o=De(e.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;e.enabled&&a&&(t.save(),t.globalAlpha=i,this.drawBackground(r,t,s,e),om(t,e.textDirection),r.y+=o.top,this.drawTitle(r,t,e),this.drawBody(r,t,e),this.drawFooter(r,t,e),am(t,e.textDirection),t.restore())}getActiveElements(){return this._active||[]}setActiveElements(t,e){const i=this._active,s=t.map(({datasetIndex:a,index:l})=>{const c=this.chart.getDatasetMeta(a);if(!c)throw new Error("Cannot find a dataset at index "+a);return{datasetIndex:a,element:c.data[l],index:l}}),r=!Sa(i,s),o=this._positionChanged(s,e);(r||o)&&(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(t,e,i=!0){if(e&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,r=this._active||[],o=this._getActiveElements(t,r,e,i),a=this._positionChanged(o,t),l=e||!Sa(o,r)||a;return l&&(this._active=o,(s.enabled||s.external)&&(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),l}_getActiveElements(t,e,i,s){const r=this.options;if(t.type==="mouseout")return[];if(!s)return e;const o=this.chart.getElementsAtEventForMode(t,r.mode,r,i);return r.reverse&&o.reverse(),o}_positionChanged(t,e){const{caretX:i,caretY:s,options:r}=this,o=fo[r.position].call(this,t,e);return o!==!1&&(i!==o.x||s!==o.y)}}Vh.positioners=fo;var N3={id:"tooltip",_element:Vh,positioners:fo,afterInit(n,t,e){e&&(n.tooltip=new Vh({chart:n,options:e}))},beforeUpdate(n,t,e){n.tooltip&&n.tooltip.initialize(e)},reset(n,t,e){n.tooltip&&n.tooltip.initialize(e)},afterDraw(n){const t=n.tooltip,e={tooltip:t};n.notifyPlugins("beforeTooltipDraw",e)!==!1&&(t&&t.draw(n.ctx),n.notifyPlugins("afterTooltipDraw",e))},afterEvent(n,t){if(n.tooltip){const e=t.replay;n.tooltip.handleEvent(t.event,e,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(n,t)=>t.bodyFont.size,boxWidth:(n,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:{beforeTitle:Gn,title(n){if(n.length>0){const t=n[0],e=t.chart.data.labels,i=e?e.length:0;if(this&&this.options&&this.options.mode==="dataset")return t.dataset.label||"";if(t.label)return t.label;if(i>0&&t.dataIndex<i)return e[t.dataIndex]}return""},afterTitle:Gn,beforeBody:Gn,beforeLabel:Gn,label(n){if(this&&this.options&&this.options.mode==="dataset")return n.label+": "+n.formattedValue||n.formattedValue;let t=n.dataset.label||"";t&&(t+=": ");const e=n.formattedValue;return $t(e)||(t+=e),t},labelColor(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(n){const e=n.chart.getDatasetMeta(n.datasetIndex).controller.getStyle(n.dataIndex);return{pointStyle:e.pointStyle,rotation:e.rotation}},afterLabel:Gn,afterBody:Gn,beforeFooter:Gn,footer:Gn,afterFooter:Gn}},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:n=>n!=="filter"&&n!=="itemSort"&&n!=="external",_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};const B1=(n,t,e,i)=>(typeof t=="string"?(e=n.push(t)-1,i.unshift({index:e,label:t})):isNaN(t)&&(e=null),e);function H1(n,t,e,i){const s=n.indexOf(t);if(s===-1)return B1(n,t,e,i);const r=n.lastIndexOf(t);return s!==r?e:s}const U1=(n,t)=>n===null?null:Pe(Math.round(n),0,t);class Wh extends ns{constructor(t){super(t);this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(t){const e=this._addedLabels;if(e.length){const i=this.getLabels();for(const{index:s,label:r}of e)i[s]===r&&i.splice(s,1);this._addedLabels=[]}super.init(t)}parse(t,e){if($t(t))return null;const i=this.getLabels();return e=isFinite(e)&&i[e]===t?e:H1(i,t,Ot(e,t),this._addedLabels),U1(e,i.length-1)}determineDataLimits(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let{min:i,max:s}=this.getMinMax(!0);this.options.bounds==="ticks"&&(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}buildTicks(){const t=this.min,e=this.max,i=this.options.offset,s=[];let r=this.getLabels();r=t===0&&e===r.length-1?r:r.slice(t,e+1),this._valueRange=Math.max(r.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);for(let o=t;o<=e;o++)s.push({value:o});return s}getLabelForValue(t){const e=this.getLabels();return t>=0&&t<e.length?e[t]:t}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(t){return typeof t!="number"&&(t=this.parse(t)),t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getPixelForTick(t){const e=this.ticks;return t<0||t>e.length-1?null:this.getPixelForValue(e[t].value)}getValueForPixel(t){return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}getBasePixel(){return this.bottom}}Wh.id="category";Wh.defaults={ticks:{callback:Wh.prototype.getLabelForValue}};function V1(n,t){const e=[],i=1e-14,{bounds:s,step:r,min:o,max:a,precision:l,count:c,maxTicks:h,maxDigits:u,includeBounds:d}=n,f=r||1,p=h-1,{min:x,max:_}=t,m=!$t(o),g=!$t(a),S=!$t(c),v=(_-x)/(u+1);let E=Ap((_-x)/p/f)*f,R,D,$,it;if(E<i&&!m&&!g)return[{value:x},{value:_}];it=Math.ceil(_/E)-Math.floor(x/E),it>p&&(E=Ap(it*E/p/f)*f),$t(l)||(R=Math.pow(10,l),E=Math.ceil(E*R)/R),s==="ticks"?(D=Math.floor(x/E)*E,$=Math.ceil(_/E)*E):(D=x,$=_),m&&g&&r&&rM((a-o)/r,E/1e3)?(it=Math.round(Math.min((a-o)/E,h)),E=(a-o)/it,D=o,$=a):S?(D=m?o:D,$=g?a:$,it=c-1,E=($-D)/it):(it=($-D)/E,Yr(it,Math.round(it),E/1e3)?it=Math.round(it):it=Math.ceil(it));const tt=Math.max(Lp(E),Lp(D));R=Math.pow(10,$t(l)?tt:l),D=Math.round(D*R)/R,$=Math.round($*R)/R;let N=0;for(m&&(d&&D!==o?(e.push({value:o}),D<o&&N++,Yr(Math.round((D+N*E)*R)/R,o,dg(o,v,n))&&N++):D<o&&N++);N<it;++N)e.push({value:Math.round((D+N*E)*R)/R});return g&&d&&$!==a?e.length&&Yr(e[e.length-1].value,a,dg(a,v,n))?e[e.length-1].value=a:e.push({value:a}):(!g||$===a)&&e.push({value:$}),e}function dg(n,t,{horizontal:e,minRotation:i}){const s=pn(i),r=(e?Math.sin(s):Math.cos(s))||.001,o=.75*t*(""+n).length;return Math.min(t/r,o)}class Ja extends ns{constructor(t){super(t);this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(t,e){return $t(t)||(typeof t=="number"||t instanceof Number)&&!isFinite(+t)?null:+t}handleTickRangeOptions(){const{beginAtZero:t}=this.options,{minDefined:e,maxDefined:i}=this.getUserBounds();let{min:s,max:r}=this;const o=l=>s=e?s:l,a=l=>r=i?r:l;if(t){const l=Pn(s),c=Pn(r);l<0&&c<0?a(0):l>0&&c>0&&o(0)}if(s===r){let l=1;(r>=Number.MAX_SAFE_INTEGER||s<=Number.MIN_SAFE_INTEGER)&&(l=Math.abs(r*.05)),a(r+l),t||o(s-l)}this.min=s,this.max=r}getTickLimit(){const t=this.options.ticks;let{maxTicksLimit:e,stepSize:i}=t,s;return i?(s=Math.ceil(this.max/i)-Math.floor(this.min/i)+1,s>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${s} ticks. Limiting to 1000.`),s=1e3)):(s=this.computeTickLimit(),e=e||11),e&&(s=Math.min(e,s)),s}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const t=this.options,e=t.ticks;let i=this.getTickLimit();i=Math.max(2,i);const s={maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:e.includeBounds!==!1},r=this._range||this,o=V1(s,r);return t.bounds==="ticks"&&Cp(o,this,"value"),t.reverse?(o.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),o}configure(){const t=this.ticks;let e=this.min,i=this.max;if(super.configure(),this.options.offset&&t.length){const s=(i-e)/Math.max(t.length-1,1)/2;e-=s,i+=s}this._startValue=e,this._endValue=i,this._valueRange=i-e}getLabelForValue(t){return no(t,this.chart.options.locale,this.options.ticks.format)}}class fg extends Ja{determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=Ae(t)?t:0,this.max=Ae(e)?e:1,this.handleTickRangeOptions()}computeTickLimit(){const t=this.isHorizontal(),e=t?this.width:this.height,i=pn(this.options.ticks.minRotation),s=(t?Math.sin(i):Math.cos(i))||.001,r=this._resolveTickFontOptions(0);return Math.ceil(e/Math.min(40,r.lineHeight/s))}getPixelForValue(t){return t===null?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}getValueForPixel(t){return this._startValue+this.getDecimalForPixel(t)*this._valueRange}}fg.id="linear";fg.defaults={ticks:{callback:Ga.formatters.numeric}};function pg(n){return n/Math.pow(10,Math.floor(sn(n)))===1}function W1(n,t){const e=Math.floor(sn(t.max)),i=Math.ceil(t.max/Math.pow(10,e)),s=[];let r=en(n.min,Math.pow(10,Math.floor(sn(t.min)))),o=Math.floor(sn(r)),a=Math.floor(r/Math.pow(10,o)),l=o<0?Math.pow(10,Math.abs(o)):1;do s.push({value:r,major:pg(r)}),++a,a===10&&(a=1,++o,l=o>=0?1:l),r=Math.round(a*Math.pow(10,o)*l)/l;while(o<e||o===e&&a<i);const c=en(n.max,r);return s.push({value:c,major:pg(r)}),s}class mg extends ns{constructor(t){super(t);this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(t,e){const i=Ja.prototype.parse.apply(this,[t,e]);if(i===0){this._zero=!0;return}return Ae(i)&&i>0?i:null}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!0);this.min=Ae(t)?Math.max(0,t):null,this.max=Ae(e)?Math.max(0,e):null,this.options.beginAtZero&&(this._zero=!0),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:t,maxDefined:e}=this.getUserBounds();let i=this.min,s=this.max;const r=l=>i=t?i:l,o=l=>s=e?s:l,a=(l,c)=>Math.pow(10,Math.floor(sn(l))+c);i===s&&(i<=0?(r(1),o(10)):(r(a(i,-1)),o(a(s,1)))),i<=0&&r(a(s,-1)),s<=0&&o(a(i,1)),this._zero&&this.min!==this._suggestedMin&&i===a(this.min,0)&&r(a(i,-1)),this.min=i,this.max=s}buildTicks(){const t=this.options,e={min:this._userMin,max:this._userMax},i=W1(e,this);return t.bounds==="ticks"&&Cp(i,this,"value"),t.reverse?(i.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),i}getLabelForValue(t){return t===void 0?"0":no(t,this.chart.options.locale,this.options.ticks.format)}configure(){const t=this.min;super.configure(),this._startValue=sn(t),this._valueRange=sn(this.max)-sn(t)}getPixelForValue(t){return(t===void 0||t===0)&&(t=this.min),t===null||isNaN(t)?NaN:this.getPixelForDecimal(t===this.min?0:(sn(t)-this._startValue)/this._valueRange)}getValueForPixel(t){const e=this.getDecimalForPixel(t);return Math.pow(10,this._startValue+e*this._valueRange)}}mg.id="logarithmic";mg.defaults={ticks:{callback:Ga.formatters.logarithmic,major:{enabled:!0}}};function Gh(n){const t=n.ticks;if(t.display&&n.display){const e=De(t.backdropPadding);return Ot(t.font&&t.font.size,Bt.font.size)+e.height}return 0}function G1(n,t,e){return e=re(e)?e:[e],{w:LM(n,t.string,e),h:e.length*t.lineHeight}}function gg(n,t,e,i,s){return n===i||n===s?{start:t-e/2,end:t+e/2}:n<i||n>s?{start:t-e,end:t}:{start:t,end:t+e}}function j1(n){const t={l:n.left+n._padding.left,r:n.right-n._padding.right,t:n.top+n._padding.top,b:n.bottom-n._padding.bottom},e=Object.assign({},t),i=[],s=[],r=n._pointLabels.length,o=n.options.pointLabels,a=o.centerPointLabels?oe/r:0;for(let l=0;l<r;l++){const c=o.setContext(n.getPointLabelContext(l));s[l]=c.padding;const h=n.getPointPosition(l,n.drawingArea+s[l],a),u=ge(c.font),d=G1(n.ctx,u,n._pointLabels[l]);i[l]=d;const f=mn(n.getIndexAngle(l)+a),p=Math.round(eh(f)),x=gg(p,h.x,d.w,0,180),_=gg(p,h.y,d.h,90,270);q1(e,t,f,x,_)}n.setCenterPoint(t.l-e.l,e.r-t.r,t.t-e.t,e.b-t.b),n._pointLabelItems=X1(n,i,s)}function q1(n,t,e,i,s){const r=Math.abs(Math.sin(e)),o=Math.abs(Math.cos(e));let a=0,l=0;i.start<t.l?(a=(t.l-i.start)/r,n.l=Math.min(n.l,t.l-a)):i.end>t.r&&(a=(i.end-t.r)/r,n.r=Math.max(n.r,t.r+a)),s.start<t.t?(l=(t.t-s.start)/o,n.t=Math.min(n.t,t.t-l)):s.end>t.b&&(l=(s.end-t.b)/o,n.b=Math.max(n.b,t.b+l))}function X1(n,t,e){const i=[],s=n._pointLabels.length,r=n.options,o=Gh(r)/2,a=n.drawingArea,l=r.pointLabels.centerPointLabels?oe/s:0;for(let c=0;c<s;c++){const h=n.getPointPosition(c,a+o+e[c],l),u=Math.round(eh(mn(h.angle+ue))),d=t[c],f=Z1(h.y,d.h,u),p=$1(u),x=Y1(h.x,d.w,p);i.push({x:h.x,y:f,textAlign:p,left:x,top:f,right:x+d.w,bottom:f+d.h})}return i}function $1(n){return n===0||n===180?"center":n<180?"left":"right"}function Y1(n,t,e){return e==="right"?n-=t:e==="center"&&(n-=t/2),n}function Z1(n,t,e){return e===90||e===270?n-=t/2:(e>270||e<90)&&(n-=t),n}function J1(n,t){const{ctx:e,options:{pointLabels:i}}=n;for(let s=t-1;s>=0;s--){const r=i.setContext(n.getPointLabelContext(s)),o=ge(r.font),{x:a,y:l,textAlign:c,left:h,top:u,right:d,bottom:f}=n._pointLabelItems[s],{backdropColor:p}=r;if(!$t(p)){const x=De(r.backdropPadding);e.fillStyle=p,e.fillRect(h-x.left,u-x.top,d-h+x.width,f-u+x.height)}Ji(e,n._pointLabels[s],a,l+o.lineHeight/2,o,{color:r.color,textAlign:c,textBaseline:"middle"})}}function xg(n,t,e,i){const{ctx:s}=n;if(e)s.arc(n.xCenter,n.yCenter,t,0,ie);else{let r=n.getPointPosition(0,t);s.moveTo(r.x,r.y);for(let o=1;o<i;o++)r=n.getPointPosition(o,t),s.lineTo(r.x,r.y)}}function K1(n,t,e,i){const s=n.ctx,r=t.circular,{color:o,lineWidth:a}=t;!r&&!i||!o||!a||e<0||(s.save(),s.strokeStyle=o,s.lineWidth=a,s.setLineDash(t.borderDash),s.lineDashOffset=t.borderDashOffset,s.beginPath(),xg(n,e,r,i),s.closePath(),s.stroke(),s.restore())}function Q1(n,t,e){return fi(n,{label:e,index:t,type:"pointLabel"})}class Ka extends Ja{constructor(t){super(t);this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const t=this._padding=De(Gh(this.options)/2),e=this.width=this.maxWidth-t.width,i=this.height=this.maxHeight-t.height;this.xCenter=Math.floor(this.left+e/2+t.left),this.yCenter=Math.floor(this.top+i/2+t.top),this.drawingArea=Math.floor(Math.min(e,i)/2)}determineDataLimits(){const{min:t,max:e}=this.getMinMax(!1);this.min=Ae(t)&&!isNaN(t)?t:0,this.max=Ae(e)&&!isNaN(e)?e:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/Gh(this.options))}generateTickLabels(t){Ja.prototype.generateTickLabels.call(this,t),this._pointLabels=this.getLabels().map((e,i)=>{const s=ne(this.options.pointLabels.callback,[e,i],this);return s||s===0?s:""}).filter((e,i)=>this.chart.getDataVisibility(i))}fit(){const t=this.options;t.display&&t.pointLabels.display?j1(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(t,e,i,s){this.xCenter+=Math.floor((t-e)/2),this.yCenter+=Math.floor((i-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(t,e,i,s))}getIndexAngle(t){const e=ie/(this._pointLabels.length||1),i=this.options.startAngle||0;return mn(t*e+pn(i))}getDistanceFromCenterForValue(t){if($t(t))return NaN;const e=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-t)*e:(t-this.min)*e}getValueForDistanceFromCenter(t){if($t(t))return NaN;const e=t/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-e:this.min+e}getPointLabelContext(t){const e=this._pointLabels||[];if(t>=0&&t<e.length){const i=e[t];return Q1(this.getContext(),t,i)}}getPointPosition(t,e,i=0){const s=this.getIndexAngle(t)-ue+i;return{x:Math.cos(s)*e+this.xCenter,y:Math.sin(s)*e+this.yCenter,angle:s}}getPointPositionForValue(t,e){return this.getPointPosition(t,this.getDistanceFromCenterForValue(e))}getBasePosition(t){return this.getPointPositionForValue(t||0,this.getBaseValue())}getPointLabelPosition(t){const{left:e,top:i,right:s,bottom:r}=this._pointLabelItems[t];return{left:e,top:i,right:s,bottom:r}}drawBackground(){const{backgroundColor:t,grid:{circular:e}}=this.options;if(t){const i=this.ctx;i.save(),i.beginPath(),xg(this,this.getDistanceFromCenterForValue(this._endValue),e,this._pointLabels.length),i.closePath(),i.fillStyle=t,i.fill(),i.restore()}}drawGrid(){const t=this.ctx,e=this.options,{angleLines:i,grid:s}=e,r=this._pointLabels.length;let o,a,l;if(e.pointLabels.display&&J1(this,r),s.display&&this.ticks.forEach((c,h)=>{if(h!==0){a=this.getDistanceFromCenterForValue(c.value);const u=s.setContext(this.getContext(h-1));K1(this,u,a,r)}}),i.display){for(t.save(),o=r-1;o>=0;o--){const c=i.setContext(this.getPointLabelContext(o)),{color:h,lineWidth:u}=c;!u||!h||(t.lineWidth=u,t.strokeStyle=h,t.setLineDash(c.borderDash),t.lineDashOffset=c.borderDashOffset,a=this.getDistanceFromCenterForValue(e.ticks.reverse?this.min:this.max),l=this.getPointPosition(o,a),t.beginPath(),t.moveTo(this.xCenter,this.yCenter),t.lineTo(l.x,l.y),t.stroke())}t.restore()}}drawBorder(){}drawLabels(){const t=this.ctx,e=this.options,i=e.ticks;if(!i.display)return;const s=this.getIndexAngle(0);let r,o;t.save(),t.translate(this.xCenter,this.yCenter),t.rotate(s),t.textAlign="center",t.textBaseline="middle",this.ticks.forEach((a,l)=>{if(l===0&&!e.reverse)return;const c=i.setContext(this.getContext(l)),h=ge(c.font);if(r=this.getDistanceFromCenterForValue(this.ticks[l].value),c.showLabelBackdrop){t.font=h.string,o=t.measureText(a.label).width,t.fillStyle=c.backdropColor;const u=De(c.backdropPadding);t.fillRect(-o/2-u.left,-r-h.size/2-u.top,o+u.width,h.size+u.height)}Ji(t,a.label,0,-r,h,{color:c.color})}),t.restore()}drawTitle(){}}Ka.id="radialLinear";Ka.defaults={display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:Ga.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback(n){return n},padding:5,centerPointLabels:!1}};Ka.defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};Ka.descriptors={angleLines:{_fallback:"grid"}};const Qa={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},We=Object.keys(Qa);function tE(n,t){return n-t}function _g(n,t){if($t(t))return null;const e=n._adapter,{parser:i,round:s,isoWeekday:r}=n._parseOpts;let o=t;return typeof i=="function"&&(o=i(o)),Ae(o)||(o=typeof i=="string"?e.parse(o,i):e.parse(o)),o===null?null:(s&&(o=s==="week"&&($r(r)||r===!0)?e.startOf(o,"isoWeek",r):e.startOf(o,s)),+o)}function yg(n,t,e,i){const s=We.length;for(let r=We.indexOf(n);r<s-1;++r){const o=Qa[We[r]],a=o.steps?o.steps:Number.MAX_SAFE_INTEGER;if(o.common&&Math.ceil((e-t)/(a*o.size))<=i)return We[r]}return We[s-1]}function eE(n,t,e,i,s){for(let r=We.length-1;r>=We.indexOf(e);r--){const o=We[r];if(Qa[o].common&&n._adapter.diff(s,i,o)>=t-1)return o}return We[e?We.indexOf(e):0]}function nE(n){for(let t=We.indexOf(n)+1,e=We.length;t<e;++t)if(Qa[We[t]].common)return We[t]}function vg(n,t,e){if(!e)n[t]=!0;else if(e.length){const{lo:i,hi:s}=ph(e,t),r=e[i]>=t?e[i]:e[s];n[r]=!0}}function iE(n,t,e,i){const s=n._adapter,r=+s.startOf(t[0].value,i),o=t[t.length-1].value;let a,l;for(a=r;a<=o;a=+s.add(a,1,i))l=e[a],l>=0&&(t[l].major=!0);return t}function bg(n,t,e){const i=[],s={},r=t.length;let o,a;for(o=0;o<r;++o)a=t[o],s[a]=o,i.push({value:a,major:!1});return r===0||!e?i:iE(n,i,s,e)}class tl extends ns{constructor(t){super(t);this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(t,e){const i=t.time||(t.time={}),s=this._adapter=new tS._date(t.adapters.date);qr(i.displayFormats,s.formats()),this._parseOpts={parser:i.parser,round:i.round,isoWeekday:i.isoWeekday},super.init(t),this._normalized=e.normalized}parse(t,e){return t===void 0?null:_g(this,t)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const t=this.options,e=this._adapter,i=t.time.unit||"day";let{min:s,max:r,minDefined:o,maxDefined:a}=this.getUserBounds();function l(c){!o&&!isNaN(c.min)&&(s=Math.min(s,c.min)),!a&&!isNaN(c.max)&&(r=Math.max(r,c.max))}(!o||!a)&&(l(this._getLabelBounds()),(t.bounds!=="ticks"||t.ticks.source!=="labels")&&l(this.getMinMax(!1))),s=Ae(s)&&!isNaN(s)?s:+e.startOf(Date.now(),i),r=Ae(r)&&!isNaN(r)?r:+e.endOf(Date.now(),i)+1,this.min=Math.min(s,r-1),this.max=Math.max(s+1,r)}_getLabelBounds(){const t=this.getLabelTimestamps();let e=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY;return t.length&&(e=t[0],i=t[t.length-1]),{min:e,max:i}}buildTicks(){const t=this.options,e=t.time,i=t.ticks,s=i.source==="labels"?this.getLabelTimestamps():this._generate();t.bounds==="ticks"&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const r=this.min,o=this.max,a=HM(s,r,o);return this._unit=e.unit||(i.autoSkip?yg(e.minUnit,this.min,this.max,this._getLabelCapacity(r)):eE(this,a.length,e.minUnit,this.min,this.max)),this._majorUnit=!i.major.enabled||this._unit==="year"?void 0:nE(this._unit),this.initOffsets(s),t.reverse&&a.reverse(),bg(this,a,this._majorUnit)}initOffsets(t){let e=0,i=0,s,r;this.options.offset&&t.length&&(s=this.getDecimalForValue(t[0]),t.length===1?e=1-s:e=(this.getDecimalForValue(t[1])-s)/2,r=this.getDecimalForValue(t[t.length-1]),t.length===1?i=r:i=(r-this.getDecimalForValue(t[t.length-2]))/2);const o=t.length<3?.5:.25;e=Pe(e,0,o),i=Pe(i,0,o),this._offsets={start:e,end:i,factor:1/(e+1+i)}}_generate(){const t=this._adapter,e=this.min,i=this.max,s=this.options,r=s.time,o=r.unit||yg(r.minUnit,e,i,this._getLabelCapacity(e)),a=Ot(r.stepSize,1),l=o==="week"?r.isoWeekday:!1,c=$r(l)||l===!0,h={};let u=e,d,f;if(c&&(u=+t.startOf(u,"isoWeek",l)),u=+t.startOf(u,c?"day":o),t.diff(i,e,o)>1e5*a)throw new Error(e+" and "+i+" are too far apart with stepSize of "+a+" "+o);const p=s.ticks.source==="data"&&this.getDataTimestamps();for(d=u,f=0;d<i;d=+t.add(d,a,o),f++)vg(h,d,p);return(d===i||s.bounds==="ticks"||f===1)&&vg(h,d,p),Object.keys(h).sort((x,_)=>x-_).map(x=>+x)}getLabelForValue(t){const e=this._adapter,i=this.options.time;return i.tooltipFormat?e.format(t,i.tooltipFormat):e.format(t,i.displayFormats.datetime)}_tickFormatFunction(t,e,i,s){const r=this.options,o=r.time.displayFormats,a=this._unit,l=this._majorUnit,c=a&&o[a],h=l&&o[l],u=i[e],d=l&&h&&u&&u.major,f=this._adapter.format(t,s||(d?h:c)),p=r.ticks.callback;return p?ne(p,[f,e,i],this):f}generateTickLabels(t){let e,i,s;for(e=0,i=t.length;e<i;++e)s=t[e],s.label=this._tickFormatFunction(s.value,e,t)}getDecimalForValue(t){return t===null?NaN:(t-this.min)/(this.max-this.min)}getPixelForValue(t){const e=this._offsets,i=this.getDecimalForValue(t);return this.getPixelForDecimal((e.start+i)*e.factor)}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return this.min+i*(this.max-this.min)}_getLabelSize(t){const e=this.options.ticks,i=this.ctx.measureText(t).width,s=pn(this.isHorizontal()?e.maxRotation:e.minRotation),r=Math.cos(s),o=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:i*r+a*o,h:i*o+a*r}}_getLabelCapacity(t){const e=this.options.time,i=e.displayFormats,s=i[e.unit]||i.millisecond,r=this._tickFormatFunction(t,0,bg(this,[t],this._majorUnit),s),o=this._getLabelSize(r),a=Math.floor(this.isHorizontal()?this.width/o.w:this.height/o.h)-1;return a>0?a:1}getDataTimestamps(){let t=this._cache.data||[],e,i;if(t.length)return t;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(e=0,i=s.length;e<i;++e)t=t.concat(s[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(t)}getLabelTimestamps(){const t=this._cache.labels||[];let e,i;if(t.length)return t;const s=this.getLabels();for(e=0,i=s.length;e<i;++e)t.push(_g(this,s[e]));return this._cache.labels=this._normalized?t:this.normalize(t)}normalize(t){return Xp(t.sort(tE))}}tl.id="time";tl.defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",major:{enabled:!1}}};function el(n,t,e){let i=0,s=n.length-1,r,o,a,l;e?(t>=n[i].pos&&t<=n[s].pos&&({lo:i,hi:s}=Ki(n,"pos",t)),{pos:r,time:a}=n[i],{pos:o,time:l}=n[s]):(t>=n[i].time&&t<=n[s].time&&({lo:i,hi:s}=Ki(n,"time",t)),{time:r,pos:a}=n[i],{time:o,pos:l}=n[s]);const c=o-r;return c?a+(l-a)*(t-r)/c:a}class Mg extends tl{constructor(t){super(t);this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const t=this._getTimestampsForTable(),e=this._table=this.buildLookupTable(t);this._minPos=el(e,this.min),this._tableRange=el(e,this.max)-this._minPos,super.initOffsets(t)}buildLookupTable(t){const{min:e,max:i}=this,s=[],r=[];let o,a,l,c,h;for(o=0,a=t.length;o<a;++o)c=t[o],c>=e&&c<=i&&s.push(c);if(s.length<2)return[{time:e,pos:0},{time:i,pos:1}];for(o=0,a=s.length;o<a;++o)h=s[o+1],l=s[o-1],c=s[o],Math.round((h+l)/2)!==c&&r.push({time:c,pos:o/(a-1)});return r}_getTimestampsForTable(){let t=this._cache.all||[];if(t.length)return t;const e=this.getDataTimestamps(),i=this.getLabelTimestamps();return e.length&&i.length?t=this.normalize(e.concat(i)):t=e.length?e:i,t=this._cache.all=t,t}getDecimalForValue(t){return(el(this._table,t)-this._minPos)/this._tableRange}getValueForPixel(t){const e=this._offsets,i=this.getDecimalForPixel(t)/e.factor-e.end;return el(this._table,i*this._tableRange+this._minPos,!0)}}Mg.id="timeseries";Mg.defaults=tl.defaults;/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const jh="136",sE=0,wg=1,rE=2,Sg=1,oE=2,po=3,mo=0,xe=1,is=2,Eg=1,gi=0,go=1,Tg=2,Ag=3,Cg=4,aE=5,Hs=100,lE=101,cE=102,Lg=103,Rg=104,hE=200,uE=201,dE=202,fE=203,Pg=204,Dg=205,pE=206,mE=207,gE=208,xE=209,_E=210,yE=0,vE=1,bE=2,qh=3,ME=4,wE=5,SE=6,EE=7,nl=0,TE=1,AE=2,xi=0,CE=1,LE=2,RE=3,PE=4,DE=5,Ig=300,xo=301,_o=302,Xh=303,$h=304,il=306,Yh=307,Zh=1e3,Ze=1001,Jh=1002,_e=1003,Fg=1004,Og=1005,Be=1006,IE=1007,sl=1008,$n=1009,FE=1010,OE=1011,yo=1012,kE=1013,rl=1014,_i=1015,ss=1016,NE=1017,zE=1018,BE=1019,Us=1020,HE=1021,rs=1022,be=1023,UE=1024,VE=1025,os=1026,Vs=1027,WE=1028,GE=1029,jE=1030,qE=1031,XE=1032,$E=1033,kg=33776,Ng=33777,zg=33778,Bg=33779,Hg=35840,Ug=35841,Vg=35842,Wg=35843,YE=36196,Gg=37492,jg=37496,ZE=37808,JE=37809,KE=37810,QE=37811,tT=37812,eT=37813,nT=37814,iT=37815,sT=37816,rT=37817,oT=37818,aT=37819,lT=37820,cT=37821,hT=36492,uT=37840,dT=37841,fT=37842,pT=37843,mT=37844,gT=37845,xT=37846,_T=37847,yT=37848,vT=37849,bT=37850,MT=37851,wT=37852,ST=37853,ET=2200,TT=2201,AT=2202,ol=2300,al=2301,Kh=2302,Ws=2400,Gs=2401,ll=2402,Qh=2500,qg=2501,CT=0,xn=3e3,js=3001,LT=3200,RT=3201,qs=0,PT=1,tu=7680,DT=519,vo=35044,cl=35048,Xg="300 es";class as{addEventListener(t,e){this._listeners===void 0&&(this._listeners={});const i=this._listeners;i[t]===void 0&&(i[t]=[]),i[t].indexOf(e)===-1&&i[t].push(e)}hasEventListener(t,e){if(this._listeners===void 0)return!1;const i=this._listeners;return i[t]!==void 0&&i[t].indexOf(e)!==-1}removeEventListener(t,e){if(this._listeners===void 0)return;const s=this._listeners[t];if(s!==void 0){const r=s.indexOf(e);r!==-1&&s.splice(r,1)}}dispatchEvent(t){if(this._listeners===void 0)return;const i=this._listeners[t.type];if(i!==void 0){t.target=this;const s=i.slice(0);for(let r=0,o=s.length;r<o;r++)s[r].call(this,t);t.target=null}}}const Ce=[];for(let n=0;n<256;n++)Ce[n]=(n<16?"0":"")+n.toString(16);const eu=Math.PI/180,nu=180/Math.PI;function Fn(){const n=Math.random()*4294967295|0,t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(Ce[n&255]+Ce[n>>8&255]+Ce[n>>16&255]+Ce[n>>24&255]+"-"+Ce[t&255]+Ce[t>>8&255]+"-"+Ce[t>>16&15|64]+Ce[t>>24&255]+"-"+Ce[e&63|128]+Ce[e>>8&255]+"-"+Ce[e>>16&255]+Ce[e>>24&255]+Ce[i&255]+Ce[i>>8&255]+Ce[i>>16&255]+Ce[i>>24&255]).toUpperCase()}function Je(n,t,e){return Math.max(t,Math.min(e,n))}function IT(n,t){return(n%t+t)%t}function iu(n,t,e){return(1-e)*n+e*t}function $g(n){return(n&n-1)==0&&n!==0}function FT(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}class mt{constructor(t=0,e=0){this.x=t,this.y=e}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,e){return this.x=t,this.y=e,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const e=this.x,i=this.y,s=t.elements;return this.x=s[0]*e+s[3]*i+s[6],this.y=s[1]*e+s[4]*i+s[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y;return e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this}rotateAround(t,e){const i=Math.cos(e),s=Math.sin(e),r=this.x-t.x,o=this.y-t.y;return this.x=r*i-o*s+t.x,this.y=r*s+o*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}mt.prototype.isVector2=!0;class ye{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,r,o,a,l,c){const h=this.elements;return h[0]=t,h[1]=s,h[2]=a,h[3]=e,h[4]=r,h[5]=l,h[6]=i,h[7]=o,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],this}extractBasis(t,e,i){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,r=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],h=i[4],u=i[7],d=i[2],f=i[5],p=i[8],x=s[0],_=s[3],m=s[6],g=s[1],S=s[4],v=s[7],E=s[2],R=s[5],D=s[8];return r[0]=o*x+a*g+l*E,r[3]=o*_+a*S+l*R,r[6]=o*m+a*v+l*D,r[1]=c*x+h*g+u*E,r[4]=c*_+h*S+u*R,r[7]=c*m+h*v+u*D,r[2]=d*x+f*g+p*E,r[5]=d*_+f*S+p*R,r[8]=d*m+f*v+p*D,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8];return e*o*h-e*a*c-i*r*h+i*a*l+s*r*c-s*o*l}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=h*o-a*c,d=a*l-h*r,f=c*r-o*l,p=e*u+i*d+s*f;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/p;return t[0]=u*x,t[1]=(s*c-h*i)*x,t[2]=(a*i-s*o)*x,t[3]=d*x,t[4]=(h*e-s*l)*x,t[5]=(s*r-a*e)*x,t[6]=f*x,t[7]=(i*l-c*e)*x,t[8]=(o*e-i*r)*x,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,i,s,r,o,a){const l=Math.cos(r),c=Math.sin(r);return this.set(i*l,i*c,-i*(l*o+c*a)+o+t,-s*c,s*l,-s*(-c*o+l*a)+a+e,0,0,1),this}scale(t,e){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=e,i[4]*=e,i[7]*=e,this}rotate(t){const e=Math.cos(t),i=Math.sin(t),s=this.elements,r=s[0],o=s[3],a=s[6],l=s[1],c=s[4],h=s[7];return s[0]=e*r+i*l,s[3]=e*o+i*c,s[6]=e*a+i*h,s[1]=-i*r+e*l,s[4]=-i*o+e*c,s[7]=-i*a+e*h,this}translate(t,e){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=e*i[2],i[4]+=e*i[5],i[7]+=e*i[8],this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<9;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<9;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t}clone(){return new this.constructor().fromArray(this.elements)}}ye.prototype.isMatrix3=!0;function Yg(n){if(n.length===0)return-1/0;let t=n[0];for(let e=1,i=n.length;e<i;++e)n[e]>t&&(t=n[e]);return t}function hl(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}let Xs;class $s{static getDataURL(t){if(/^data:/i.test(t.src)||typeof HTMLCanvasElement=="undefined")return t.src;let e;if(t instanceof HTMLCanvasElement)e=t;else{Xs===void 0&&(Xs=hl("canvas")),Xs.width=t.width,Xs.height=t.height;const i=Xs.getContext("2d");t instanceof ImageData?i.putImageData(t,0,0):i.drawImage(t,0,0,t.width,t.height),e=Xs}return e.width>2048||e.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",t),e.toDataURL("image/jpeg",.6)):e.toDataURL("image/png")}}let OT=0;class Me extends as{constructor(t=Me.DEFAULT_IMAGE,e=Me.DEFAULT_MAPPING,i=Ze,s=Ze,r=Be,o=sl,a=be,l=$n,c=1,h=xn){super();Object.defineProperty(this,"id",{value:OT++}),this.uuid=Fn(),this.name="",this.image=t,this.mipmaps=[],this.mapping=e,this.wrapS=i,this.wrapT=s,this.magFilter=r,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new mt(0,0),this.repeat=new mt(1,1),this.center=new mt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new ye,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(t){return this.name=t.name,this.image=t.image,this.mipmaps=t.mipmaps.slice(0),this.mapping=t.mapping,this.wrapS=t.wrapS,this.wrapT=t.wrapT,this.magFilter=t.magFilter,this.minFilter=t.minFilter,this.anisotropy=t.anisotropy,this.format=t.format,this.internalFormat=t.internalFormat,this.type=t.type,this.offset.copy(t.offset),this.repeat.copy(t.repeat),this.center.copy(t.center),this.rotation=t.rotation,this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrix.copy(t.matrix),this.generateMipmaps=t.generateMipmaps,this.premultiplyAlpha=t.premultiplyAlpha,this.flipY=t.flipY,this.unpackAlignment=t.unpackAlignment,this.encoding=t.encoding,this.userData=JSON.parse(JSON.stringify(t.userData)),this}toJSON(t){const e=t===void 0||typeof t=="string";if(!e&&t.textures[this.uuid]!==void 0)return t.textures[this.uuid];const i={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const s=this.image;if(s.uuid===void 0&&(s.uuid=Fn()),!e&&t.images[s.uuid]===void 0){let r;if(Array.isArray(s)){r=[];for(let o=0,a=s.length;o<a;o++)s[o].isDataTexture?r.push(su(s[o].image)):r.push(su(s[o]))}else r=su(s);t.images[s.uuid]={uuid:s.uuid,url:r}}i.image=s.uuid}return JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),e||(t.textures[this.uuid]=i),i}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(t){if(this.mapping!==Ig)return t;if(t.applyMatrix3(this.matrix),t.x<0||t.x>1)switch(this.wrapS){case Zh:t.x=t.x-Math.floor(t.x);break;case Ze:t.x=t.x<0?0:1;break;case Jh:Math.abs(Math.floor(t.x)%2)===1?t.x=Math.ceil(t.x)-t.x:t.x=t.x-Math.floor(t.x);break}if(t.y<0||t.y>1)switch(this.wrapT){case Zh:t.y=t.y-Math.floor(t.y);break;case Ze:t.y=t.y<0?0:1;break;case Jh:Math.abs(Math.floor(t.y)%2)===1?t.y=Math.ceil(t.y)-t.y:t.y=t.y-Math.floor(t.y);break}return this.flipY&&(t.y=1-t.y),t}set needsUpdate(t){t===!0&&this.version++}}Me.DEFAULT_IMAGE=void 0;Me.DEFAULT_MAPPING=Ig;Me.prototype.isTexture=!0;function su(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?$s.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Zt{constructor(t=0,e=0,i=0,s=1){this.x=t,this.y=e,this.z=i,this.w=s}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;case 3:this.w=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this.w=t.w+e.w,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this.w+=t.w*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this.w=t.w-e.w,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,r=this.w,o=t.elements;return this.x=o[0]*e+o[4]*i+o[8]*s+o[12]*r,this.y=o[1]*e+o[5]*i+o[9]*s+o[13]*r,this.z=o[2]*e+o[6]*i+o[10]*s+o[14]*r,this.w=o[3]*e+o[7]*i+o[11]*s+o[15]*r,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const e=Math.sqrt(1-t.w*t.w);return e<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/e,this.y=t.y/e,this.z=t.z/e),this}setAxisAngleFromRotationMatrix(t){let e,i,s,r;const o=.01,a=.1,l=t.elements,c=l[0],h=l[4],u=l[8],d=l[1],f=l[5],p=l[9],x=l[2],_=l[6],m=l[10];if(Math.abs(h-d)<o&&Math.abs(u-x)<o&&Math.abs(p-_)<o){if(Math.abs(h+d)<a&&Math.abs(u+x)<a&&Math.abs(p+_)<a&&Math.abs(c+f+m-3)<a)return this.set(1,0,0,0),this;e=Math.PI;const S=(c+1)/2,v=(f+1)/2,E=(m+1)/2,R=(h+d)/4,D=(u+x)/4,$=(p+_)/4;return S>v&&S>E?S<o?(i=0,s=.707106781,r=.707106781):(i=Math.sqrt(S),s=R/i,r=D/i):v>E?v<o?(i=.707106781,s=0,r=.707106781):(s=Math.sqrt(v),i=R/s,r=$/s):E<o?(i=.707106781,s=.707106781,r=0):(r=Math.sqrt(E),i=D/r,s=$/r),this.set(i,s,r,e),this}let g=Math.sqrt((_-p)*(_-p)+(u-x)*(u-x)+(d-h)*(d-h));return Math.abs(g)<.001&&(g=1),this.x=(_-p)/g,this.y=(u-x)/g,this.z=(d-h)/g,this.w=Math.acos((c+f+m-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this.w=Math.max(t.w,Math.min(e.w,this.w)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this.w=Math.max(t,Math.min(e,this.w)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this.w+=(t.w-this.w)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this.w=t.w+(e.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this.w=t[e+3],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t[e+3]=this.w,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this.w=t.getW(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}Zt.prototype.isVector4=!0;class an extends as{constructor(t,e,i={}){super();this.width=t,this.height=e,this.depth=1,this.scissor=new Zt(0,0,t,e),this.scissorTest=!1,this.viewport=new Zt(0,0,t,e),this.texture=new Me(void 0,i.mapping,i.wrapS,i.wrapT,i.magFilter,i.minFilter,i.format,i.type,i.anisotropy,i.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:t,height:e,depth:1},this.texture.generateMipmaps=i.generateMipmaps!==void 0?i.generateMipmaps:!1,this.texture.internalFormat=i.internalFormat!==void 0?i.internalFormat:null,this.texture.minFilter=i.minFilter!==void 0?i.minFilter:Be,this.depthBuffer=i.depthBuffer!==void 0?i.depthBuffer:!0,this.stencilBuffer=i.stencilBuffer!==void 0?i.stencilBuffer:!1,this.depthTexture=i.depthTexture!==void 0?i.depthTexture:null}setTexture(t){t.image={width:this.width,height:this.height,depth:this.depth},this.texture=t}setSize(t,e,i=1){(this.width!==t||this.height!==e||this.depth!==i)&&(this.width=t,this.height=e,this.depth=i,this.texture.image.width=t,this.texture.image.height=e,this.texture.image.depth=i,this.dispose()),this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e)}clone(){return new this.constructor().copy(this)}copy(t){return this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.copy(t.viewport),this.texture=t.texture.clone(),this.texture.image=_d({},this.texture.image),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}an.prototype.isWebGLRenderTarget=!0;class kT extends an{constructor(t,e,i){super(t,e);const s=this.texture;this.texture=[];for(let r=0;r<i;r++)this.texture[r]=s.clone()}setSize(t,e,i=1){if(this.width!==t||this.height!==e||this.depth!==i){this.width=t,this.height=e,this.depth=i;for(let s=0,r=this.texture.length;s<r;s++)this.texture[s].image.width=t,this.texture[s].image.height=e,this.texture[s].image.depth=i;this.dispose()}return this.viewport.set(0,0,t,e),this.scissor.set(0,0,t,e),this}copy(t){this.dispose(),this.width=t.width,this.height=t.height,this.depth=t.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=t.depthBuffer,this.stencilBuffer=t.stencilBuffer,this.depthTexture=t.depthTexture,this.texture.length=0;for(let e=0,i=t.texture.length;e<i;e++)this.texture[e]=t.texture[e].clone();return this}}kT.prototype.isWebGLMultipleRenderTargets=!0;class ru extends an{constructor(t,e,i={}){super(t,e,i);this.samples=4,this.ignoreDepthForMultisampleCopy=i.ignoreDepth!==void 0?i.ignoreDepth:!0,this.useRenderToTexture=i.useRenderToTexture!==void 0?i.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(t){return super.copy.call(this,t),this.samples=t.samples,this.useRenderToTexture=t.useRenderToTexture,this.useRenderbuffer=t.useRenderbuffer,this}}ru.prototype.isWebGLMultisampleRenderTarget=!0;class Ge{constructor(t=0,e=0,i=0,s=1){this._x=t,this._y=e,this._z=i,this._w=s}static slerp(t,e,i,s){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,e,s)}static slerpFlat(t,e,i,s,r,o,a){let l=i[s+0],c=i[s+1],h=i[s+2],u=i[s+3];const d=r[o+0],f=r[o+1],p=r[o+2],x=r[o+3];if(a===0){t[e+0]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u;return}if(a===1){t[e+0]=d,t[e+1]=f,t[e+2]=p,t[e+3]=x;return}if(u!==x||l!==d||c!==f||h!==p){let _=1-a;const m=l*d+c*f+h*p+u*x,g=m>=0?1:-1,S=1-m*m;if(S>Number.EPSILON){const E=Math.sqrt(S),R=Math.atan2(E,m*g);_=Math.sin(_*R)/E,a=Math.sin(a*R)/E}const v=a*g;if(l=l*_+d*v,c=c*_+f*v,h=h*_+p*v,u=u*_+x*v,_===1-a){const E=1/Math.sqrt(l*l+c*c+h*h+u*u);l*=E,c*=E,h*=E,u*=E}}t[e]=l,t[e+1]=c,t[e+2]=h,t[e+3]=u}static multiplyQuaternionsFlat(t,e,i,s,r,o){const a=i[s],l=i[s+1],c=i[s+2],h=i[s+3],u=r[o],d=r[o+1],f=r[o+2],p=r[o+3];return t[e]=a*p+h*u+l*f-c*d,t[e+1]=l*p+h*d+c*u-a*f,t[e+2]=c*p+h*f+a*d-l*u,t[e+3]=h*p-a*u-l*d-c*f,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,e,i,s){return this._x=t,this._y=e,this._z=i,this._w=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,e){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,s=t._y,r=t._z,o=t._order,a=Math.cos,l=Math.sin,c=a(i/2),h=a(s/2),u=a(r/2),d=l(i/2),f=l(s/2),p=l(r/2);switch(o){case"XYZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"YXZ":this._x=d*h*u+c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"ZXY":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u-d*f*p;break;case"ZYX":this._x=d*h*u-c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u+d*f*p;break;case"YZX":this._x=d*h*u+c*f*p,this._y=c*f*u+d*h*p,this._z=c*h*p-d*f*u,this._w=c*h*u-d*f*p;break;case"XZY":this._x=d*h*u-c*f*p,this._y=c*f*u-d*h*p,this._z=c*h*p+d*f*u,this._w=c*h*u+d*f*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return e!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,e){const i=e/2,s=Math.sin(i);return this._x=t.x*s,this._y=t.y*s,this._z=t.z*s,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const e=t.elements,i=e[0],s=e[4],r=e[8],o=e[1],a=e[5],l=e[9],c=e[2],h=e[6],u=e[10],d=i+a+u;if(d>0){const f=.5/Math.sqrt(d+1);this._w=.25/f,this._x=(h-l)*f,this._y=(r-c)*f,this._z=(o-s)*f}else if(i>a&&i>u){const f=2*Math.sqrt(1+i-a-u);this._w=(h-l)/f,this._x=.25*f,this._y=(s+o)/f,this._z=(r+c)/f}else if(a>u){const f=2*Math.sqrt(1+a-i-u);this._w=(r-c)/f,this._x=(s+o)/f,this._y=.25*f,this._z=(l+h)/f}else{const f=2*Math.sqrt(1+u-i-a);this._w=(o-s)/f,this._x=(r+c)/f,this._y=(l+h)/f,this._z=.25*f}return this._onChangeCallback(),this}setFromUnitVectors(t,e){let i=t.dot(e)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*e.z-t.z*e.y,this._y=t.z*e.x-t.x*e.z,this._z=t.x*e.y-t.y*e.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Je(this.dot(t),-1,1)))}rotateTowards(t,e){const i=this.angleTo(t);if(i===0)return this;const s=Math.min(1,e/i);return this.slerp(t,s),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,e){return e!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,e)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,e){const i=t._x,s=t._y,r=t._z,o=t._w,a=e._x,l=e._y,c=e._z,h=e._w;return this._x=i*h+o*a+s*c-r*l,this._y=s*h+o*l+r*a-i*c,this._z=r*h+o*c+i*l-s*a,this._w=o*h-i*a-s*l-r*c,this._onChangeCallback(),this}slerp(t,e){if(e===0)return this;if(e===1)return this.copy(t);const i=this._x,s=this._y,r=this._z,o=this._w;let a=o*t._w+i*t._x+s*t._y+r*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=i,this._y=s,this._z=r,this;const l=1-a*a;if(l<=Number.EPSILON){const f=1-e;return this._w=f*o+e*this._w,this._x=f*i+e*this._x,this._y=f*s+e*this._y,this._z=f*r+e*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),h=Math.atan2(c,a),u=Math.sin((1-e)*h)/c,d=Math.sin(e*h)/c;return this._w=o*u+this._w*d,this._x=i*u+this._x*d,this._y=s*u+this._y*d,this._z=r*u+this._z*d,this._onChangeCallback(),this}slerpQuaternions(t,e,i){this.copy(t).slerp(e,i)}random(){const t=Math.random(),e=Math.sqrt(1-t),i=Math.sqrt(t),s=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(e*Math.cos(s),i*Math.sin(r),i*Math.cos(r),e*Math.sin(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,e=0){return this._x=t[e],this._y=t[e+1],this._z=t[e+2],this._w=t[e+3],this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._w,t}fromBufferAttribute(t,e){return this._x=t.getX(e),this._y=t.getY(e),this._z=t.getZ(e),this._w=t.getW(e),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}Ge.prototype.isQuaternion=!0;class I{constructor(t=0,e=0,i=0){this.x=t,this.y=e,this.z=i}set(t,e,i){return i===void 0&&(i=this.z),this.x=t,this.y=e,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,e){switch(t){case 0:this.x=e;break;case 1:this.y=e;break;case 2:this.z=e;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,e){return e!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,e)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,e){return this.x=t.x+e.x,this.y=t.y+e.y,this.z=t.z+e.z,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}sub(t,e){return e!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,e)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,e)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,e){return this.x=t.x*e.x,this.y=t.y*e.y,this.z=t.z*e.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(Zg.setFromEuler(t))}applyAxisAngle(t,e){return this.applyQuaternion(Zg.setFromAxisAngle(t,e))}applyMatrix3(t){const e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[3]*i+r[6]*s,this.y=r[1]*e+r[4]*i+r[7]*s,this.z=r[2]*e+r[5]*i+r[8]*s,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const e=this.x,i=this.y,s=this.z,r=t.elements,o=1/(r[3]*e+r[7]*i+r[11]*s+r[15]);return this.x=(r[0]*e+r[4]*i+r[8]*s+r[12])*o,this.y=(r[1]*e+r[5]*i+r[9]*s+r[13])*o,this.z=(r[2]*e+r[6]*i+r[10]*s+r[14])*o,this}applyQuaternion(t){const e=this.x,i=this.y,s=this.z,r=t.x,o=t.y,a=t.z,l=t.w,c=l*e+o*s-a*i,h=l*i+a*e-r*s,u=l*s+r*i-o*e,d=-r*e-o*i-a*s;return this.x=c*l+d*-r+h*-a-u*-o,this.y=h*l+d*-o+u*-r-c*-a,this.z=u*l+d*-a+c*-o-h*-r,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const e=this.x,i=this.y,s=this.z,r=t.elements;return this.x=r[0]*e+r[4]*i+r[8]*s,this.y=r[1]*e+r[5]*i+r[9]*s,this.z=r[2]*e+r[6]*i+r[10]*s,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this.z=Math.max(t,Math.min(e,this.z)),this}clampLength(t,e){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(e,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,e){return this.x+=(t.x-this.x)*e,this.y+=(t.y-this.y)*e,this.z+=(t.z-this.z)*e,this}lerpVectors(t,e,i){return this.x=t.x+(e.x-t.x)*i,this.y=t.y+(e.y-t.y)*i,this.z=t.z+(e.z-t.z)*i,this}cross(t,e){return e!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,e)):this.crossVectors(this,t)}crossVectors(t,e){const i=t.x,s=t.y,r=t.z,o=e.x,a=e.y,l=e.z;return this.x=s*l-r*a,this.y=r*o-i*l,this.z=i*a-s*o,this}projectOnVector(t){const e=t.lengthSq();if(e===0)return this.set(0,0,0);const i=t.dot(this)/e;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return ou.copy(this).projectOnVector(t),this.sub(ou)}reflect(t){return this.sub(ou.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const e=Math.sqrt(this.lengthSq()*t.lengthSq());if(e===0)return Math.PI/2;const i=this.dot(t)/e;return Math.acos(Je(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const e=this.x-t.x,i=this.y-t.y,s=this.z-t.z;return e*e+i*i+s*s}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,e,i){const s=Math.sin(e)*t;return this.x=s*Math.sin(i),this.y=Math.cos(e)*t,this.z=s*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,e,i){return this.x=t*Math.sin(e),this.y=i,this.z=t*Math.cos(e),this}setFromMatrixPosition(t){const e=t.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(t){const e=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),s=this.setFromMatrixColumn(t,2).length();return this.x=e,this.y=i,this.z=s,this}setFromMatrixColumn(t,e){return this.fromArray(t.elements,e*4)}setFromMatrix3Column(t,e){return this.fromArray(t.elements,e*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,e=0){return this.x=t[e],this.y=t[e+1],this.z=t[e+2],this}toArray(t=[],e=0){return t[e]=this.x,t[e+1]=this.y,t[e+2]=this.z,t}fromBufferAttribute(t,e,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(e),this.y=t.getY(e),this.z=t.getZ(e),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,e=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(e),this.y=i*Math.sin(e),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}I.prototype.isVector3=!0;const ou=new I,Zg=new Ge;class Ke{constructor(t=new I(1/0,1/0,1/0),e=new I(-1/0,-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromArray(t){let e=1/0,i=1/0,s=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.length;l<c;l+=3){const h=t[l],u=t[l+1],d=t[l+2];h<e&&(e=h),u<i&&(i=u),d<s&&(s=d),h>r&&(r=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,i,s),this.max.set(r,o,a),this}setFromBufferAttribute(t){let e=1/0,i=1/0,s=1/0,r=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.count;l<c;l++){const h=t.getX(l),u=t.getY(l),d=t.getZ(l);h<e&&(e=h),u<i&&(i=u),d<s&&(s=d),h>r&&(r=h),u>o&&(o=u),d>a&&(a=d)}return this.min.set(e,i,s),this.max.set(r,o,a),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=bo.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const e=t.geometry;e!==void 0&&(e.boundingBox===null&&e.computeBoundingBox(),au.copy(e.boundingBox),au.applyMatrix4(t.matrixWorld),this.union(au));const i=t.children;for(let s=0,r=i.length;s<r;s++)this.expandByObject(i[s]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,bo),bo.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let e,i;return t.normal.x>0?(e=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(e=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(e+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(e+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(e+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(e+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),e<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(Mo),ul.subVectors(this.max,Mo),Ys.subVectors(t.a,Mo),Zs.subVectors(t.b,Mo),Js.subVectors(t.c,Mo),yi.subVectors(Zs,Ys),vi.subVectors(Js,Zs),ls.subVectors(Ys,Js);let e=[0,-yi.z,yi.y,0,-vi.z,vi.y,0,-ls.z,ls.y,yi.z,0,-yi.x,vi.z,0,-vi.x,ls.z,0,-ls.x,-yi.y,yi.x,0,-vi.y,vi.x,0,-ls.y,ls.x,0];return!lu(e,Ys,Zs,Js,ul)||(e=[1,0,0,0,1,0,0,0,1],!lu(e,Ys,Zs,Js,ul))?!1:(dl.crossVectors(yi,vi),e=[dl.x,dl.y,dl.z],lu(e,Ys,Zs,Js,ul))}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return bo.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(bo).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Yn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Yn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Yn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Yn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Yn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Yn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Yn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Yn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Yn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}Ke.prototype.isBox3=!0;const Yn=[new I,new I,new I,new I,new I,new I,new I,new I],bo=new I,au=new Ke,Ys=new I,Zs=new I,Js=new I,yi=new I,vi=new I,ls=new I,Mo=new I,ul=new I,dl=new I,cs=new I;function lu(n,t,e,i,s){for(let r=0,o=n.length-3;r<=o;r+=3){cs.fromArray(n,r);const a=s.x*Math.abs(cs.x)+s.y*Math.abs(cs.y)+s.z*Math.abs(cs.z),l=t.dot(cs),c=e.dot(cs),h=i.dot(cs);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>a)return!1}return!0}const NT=new Ke,Jg=new I,fl=new I,cu=new I;class Ks{constructor(t=new I,e=-1){this.center=t,this.radius=e}set(t,e){return this.center.copy(t),this.radius=e,this}setFromPoints(t,e){const i=this.center;e!==void 0?i.copy(e):NT.setFromPoints(t).getCenter(i);let s=0;for(let r=0,o=t.length;r<o;r++)s=Math.max(s,i.distanceToSquared(t[r]));return this.radius=Math.sqrt(s),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const e=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=e*e}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,e){const i=this.center.distanceToSquared(t);return e.copy(t),i>this.radius*this.radius&&(e.sub(this.center).normalize(),e.multiplyScalar(this.radius).add(this.center)),e}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){cu.subVectors(t,this.center);const e=cu.lengthSq();if(e>this.radius*this.radius){const i=Math.sqrt(e),s=(i-this.radius)*.5;this.center.add(cu.multiplyScalar(s/i)),this.radius+=s}return this}union(t){return this.center.equals(t.center)===!0?fl.set(0,0,1).multiplyScalar(t.radius):fl.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(Jg.copy(t.center).add(fl)),this.expandByPoint(Jg.copy(t.center).sub(fl)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Zn=new I,hu=new I,pl=new I,bi=new I,uu=new I,ml=new I,du=new I;class Qs{constructor(t=new I,e=new I(0,0,-1)){this.origin=t,this.direction=e}set(t,e){return this.origin.copy(t),this.direction.copy(e),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,e){return e.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,Zn)),this}closestPointToPoint(t,e){e.subVectors(t,this.origin);const i=e.dot(this.direction);return i<0?e.copy(this.origin):e.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const e=Zn.subVectors(t,this.origin).dot(this.direction);return e<0?this.origin.distanceToSquared(t):(Zn.copy(this.direction).multiplyScalar(e).add(this.origin),Zn.distanceToSquared(t))}distanceSqToSegment(t,e,i,s){hu.copy(t).add(e).multiplyScalar(.5),pl.copy(e).sub(t).normalize(),bi.copy(this.origin).sub(hu);const r=t.distanceTo(e)*.5,o=-this.direction.dot(pl),a=bi.dot(this.direction),l=-bi.dot(pl),c=bi.lengthSq(),h=Math.abs(1-o*o);let u,d,f,p;if(h>0)if(u=o*l-a,d=o*a-l,p=r*h,u>=0)if(d>=-p)if(d<=p){const x=1/h;u*=x,d*=x,f=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d=-r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-o*r+a)),d=u>0?-r:Math.min(Math.max(-r,-l),r),f=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-r,-l),r),f=d*(d+2*l)+c):(u=Math.max(0,-(o*r+a)),d=u>0?r:Math.min(Math.max(-r,-l),r),f=-u*u+d*(d+2*l)+c);else d=o>0?-r:r,u=Math.max(0,-(o*d+a)),f=-u*u+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),s&&s.copy(pl).multiplyScalar(d).add(hu),f}intersectSphere(t,e){Zn.subVectors(t.center,this.origin);const i=Zn.dot(this.direction),s=Zn.dot(Zn)-i*i,r=t.radius*t.radius;if(s>r)return null;const o=Math.sqrt(r-s),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,e):this.at(a,e)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const e=t.normal.dot(this.direction);if(e===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/e;return i>=0?i:null}intersectPlane(t,e){const i=this.distanceToPlane(t);return i===null?null:this.at(i,e)}intersectsPlane(t){const e=t.distanceToPoint(this.origin);return e===0||t.normal.dot(this.direction)*e<0}intersectBox(t,e){let i,s,r,o,a,l;const c=1/this.direction.x,h=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(i=(t.min.x-d.x)*c,s=(t.max.x-d.x)*c):(i=(t.max.x-d.x)*c,s=(t.min.x-d.x)*c),h>=0?(r=(t.min.y-d.y)*h,o=(t.max.y-d.y)*h):(r=(t.max.y-d.y)*h,o=(t.min.y-d.y)*h),i>o||r>s||((r>i||i!==i)&&(i=r),(o<s||s!==s)&&(s=o),u>=0?(a=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(a=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),i>l||a>s)||((a>i||i!==i)&&(i=a),(l<s||s!==s)&&(s=l),s<0)?null:this.at(i>=0?i:s,e)}intersectsBox(t){return this.intersectBox(t,Zn)!==null}intersectTriangle(t,e,i,s,r){uu.subVectors(e,t),ml.subVectors(i,t),du.crossVectors(uu,ml);let o=this.direction.dot(du),a;if(o>0){if(s)return null;a=1}else if(o<0)a=-1,o=-o;else return null;bi.subVectors(this.origin,t);const l=a*this.direction.dot(ml.crossVectors(bi,ml));if(l<0)return null;const c=a*this.direction.dot(uu.cross(bi));if(c<0||l+c>o)return null;const h=-a*bi.dot(du);return h<0?null:this.at(h/o,r)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Tt{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,i,s,r,o,a,l,c,h,u,d,f,p,x,_){const m=this.elements;return m[0]=t,m[4]=e,m[8]=i,m[12]=s,m[1]=r,m[5]=o,m[9]=a,m[13]=l,m[2]=c,m[6]=h,m[10]=u,m[14]=d,m[3]=f,m[7]=p,m[11]=x,m[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Tt().fromArray(this.elements)}copy(t){const e=this.elements,i=t.elements;return e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15],this}copyPosition(t){const e=this.elements,i=t.elements;return e[12]=i[12],e[13]=i[13],e[14]=i[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,i){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,e,i){return this.set(t.x,e.x,i.x,0,t.y,e.y,i.y,0,t.z,e.z,i.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,i=t.elements,s=1/tr.setFromMatrixColumn(t,0).length(),r=1/tr.setFromMatrixColumn(t,1).length(),o=1/tr.setFromMatrixColumn(t,2).length();return e[0]=i[0]*s,e[1]=i[1]*s,e[2]=i[2]*s,e[3]=0,e[4]=i[4]*r,e[5]=i[5]*r,e[6]=i[6]*r,e[7]=0,e[8]=i[8]*o,e[9]=i[9]*o,e[10]=i[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,i=t.x,s=t.y,r=t.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(s),c=Math.sin(s),h=Math.cos(r),u=Math.sin(r);if(t.order==="XYZ"){const d=o*h,f=o*u,p=a*h,x=a*u;e[0]=l*h,e[4]=-l*u,e[8]=c,e[1]=f+p*c,e[5]=d-x*c,e[9]=-a*l,e[2]=x-d*c,e[6]=p+f*c,e[10]=o*l}else if(t.order==="YXZ"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d+x*a,e[4]=p*a-f,e[8]=o*c,e[1]=o*u,e[5]=o*h,e[9]=-a,e[2]=f*a-p,e[6]=x+d*a,e[10]=o*l}else if(t.order==="ZXY"){const d=l*h,f=l*u,p=c*h,x=c*u;e[0]=d-x*a,e[4]=-o*u,e[8]=p+f*a,e[1]=f+p*a,e[5]=o*h,e[9]=x-d*a,e[2]=-o*c,e[6]=a,e[10]=o*l}else if(t.order==="ZYX"){const d=o*h,f=o*u,p=a*h,x=a*u;e[0]=l*h,e[4]=p*c-f,e[8]=d*c+x,e[1]=l*u,e[5]=x*c+d,e[9]=f*c-p,e[2]=-c,e[6]=a*l,e[10]=o*l}else if(t.order==="YZX"){const d=o*l,f=o*c,p=a*l,x=a*c;e[0]=l*h,e[4]=x-d*u,e[8]=p*u+f,e[1]=u,e[5]=o*h,e[9]=-a*h,e[2]=-c*h,e[6]=f*u+p,e[10]=d-x*u}else if(t.order==="XZY"){const d=o*l,f=o*c,p=a*l,x=a*c;e[0]=l*h,e[4]=-u,e[8]=c*h,e[1]=d*u+x,e[5]=o*h,e[9]=f*u-p,e[2]=p*u-f,e[6]=a*h,e[10]=x*u+d}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(zT,t,BT)}lookAt(t,e,i){const s=this.elements;return Qe.subVectors(t,e),Qe.lengthSq()===0&&(Qe.z=1),Qe.normalize(),Mi.crossVectors(i,Qe),Mi.lengthSq()===0&&(Math.abs(i.z)===1?Qe.x+=1e-4:Qe.z+=1e-4,Qe.normalize(),Mi.crossVectors(i,Qe)),Mi.normalize(),gl.crossVectors(Qe,Mi),s[0]=Mi.x,s[4]=gl.x,s[8]=Qe.x,s[1]=Mi.y,s[5]=gl.y,s[9]=Qe.y,s[2]=Mi.z,s[6]=gl.z,s[10]=Qe.z,this}multiply(t,e){return e!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const i=t.elements,s=e.elements,r=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],h=i[1],u=i[5],d=i[9],f=i[13],p=i[2],x=i[6],_=i[10],m=i[14],g=i[3],S=i[7],v=i[11],E=i[15],R=s[0],D=s[4],$=s[8],it=s[12],tt=s[1],N=s[5],T=s[9],A=s[13],W=s[2],V=s[6],k=s[10],U=s[14],ct=s[3],xt=s[7],et=s[11],ot=s[15];return r[0]=o*R+a*tt+l*W+c*ct,r[4]=o*D+a*N+l*V+c*xt,r[8]=o*$+a*T+l*k+c*et,r[12]=o*it+a*A+l*U+c*ot,r[1]=h*R+u*tt+d*W+f*ct,r[5]=h*D+u*N+d*V+f*xt,r[9]=h*$+u*T+d*k+f*et,r[13]=h*it+u*A+d*U+f*ot,r[2]=p*R+x*tt+_*W+m*ct,r[6]=p*D+x*N+_*V+m*xt,r[10]=p*$+x*T+_*k+m*et,r[14]=p*it+x*A+_*U+m*ot,r[3]=g*R+S*tt+v*W+E*ct,r[7]=g*D+S*N+v*V+E*xt,r[11]=g*$+S*T+v*k+E*et,r[15]=g*it+S*A+v*U+E*ot,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],i=t[4],s=t[8],r=t[12],o=t[1],a=t[5],l=t[9],c=t[13],h=t[2],u=t[6],d=t[10],f=t[14],p=t[3],x=t[7],_=t[11],m=t[15];return p*(+r*l*u-s*c*u-r*a*d+i*c*d+s*a*f-i*l*f)+x*(+e*l*f-e*c*d+r*o*d-s*o*f+s*c*h-r*l*h)+_*(+e*c*u-e*a*f-r*o*u+i*o*f+r*a*h-i*c*h)+m*(-s*a*h-e*l*u+e*a*d+s*o*u-i*o*d+i*l*h)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,i){const s=this.elements;return t.isVector3?(s[12]=t.x,s[13]=t.y,s[14]=t.z):(s[12]=t,s[13]=e,s[14]=i),this}invert(){const t=this.elements,e=t[0],i=t[1],s=t[2],r=t[3],o=t[4],a=t[5],l=t[6],c=t[7],h=t[8],u=t[9],d=t[10],f=t[11],p=t[12],x=t[13],_=t[14],m=t[15],g=u*_*c-x*d*c+x*l*f-a*_*f-u*l*m+a*d*m,S=p*d*c-h*_*c-p*l*f+o*_*f+h*l*m-o*d*m,v=h*x*c-p*u*c+p*a*f-o*x*f-h*a*m+o*u*m,E=p*u*l-h*x*l-p*a*d+o*x*d+h*a*_-o*u*_,R=e*g+i*S+s*v+r*E;if(R===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const D=1/R;return t[0]=g*D,t[1]=(x*d*r-u*_*r-x*s*f+i*_*f+u*s*m-i*d*m)*D,t[2]=(a*_*r-x*l*r+x*s*c-i*_*c-a*s*m+i*l*m)*D,t[3]=(u*l*r-a*d*r-u*s*c+i*d*c+a*s*f-i*l*f)*D,t[4]=S*D,t[5]=(h*_*r-p*d*r+p*s*f-e*_*f-h*s*m+e*d*m)*D,t[6]=(p*l*r-o*_*r-p*s*c+e*_*c+o*s*m-e*l*m)*D,t[7]=(o*d*r-h*l*r+h*s*c-e*d*c-o*s*f+e*l*f)*D,t[8]=v*D,t[9]=(p*u*r-h*x*r-p*i*f+e*x*f+h*i*m-e*u*m)*D,t[10]=(o*x*r-p*a*r+p*i*c-e*x*c-o*i*m+e*a*m)*D,t[11]=(h*a*r-o*u*r-h*i*c+e*u*c+o*i*f-e*a*f)*D,t[12]=E*D,t[13]=(h*x*s-p*u*s+p*i*d-e*x*d-h*i*_+e*u*_)*D,t[14]=(p*a*s-o*x*s-p*i*l+e*x*l+o*i*_-e*a*_)*D,t[15]=(o*u*s-h*a*s+h*i*l-e*u*l-o*i*d+e*a*d)*D,this}scale(t){const e=this.elements,i=t.x,s=t.y,r=t.z;return e[0]*=i,e[4]*=s,e[8]*=r,e[1]*=i,e[5]*=s,e[9]*=r,e[2]*=i,e[6]*=s,e[10]*=r,e[3]*=i,e[7]*=s,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],s=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,i,s))}makeTranslation(t,e,i){return this.set(1,0,0,t,0,1,0,e,0,0,1,i,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,e,-i,0,0,i,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,0,i,0,0,1,0,0,-i,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),i=Math.sin(t);return this.set(e,-i,0,0,i,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const i=Math.cos(e),s=Math.sin(e),r=1-i,o=t.x,a=t.y,l=t.z,c=r*o,h=r*a;return this.set(c*o+i,c*a-s*l,c*l+s*a,0,c*a+s*l,h*a+i,h*l-s*o,0,c*l-s*a,h*l+s*o,r*l*l+i,0,0,0,0,1),this}makeScale(t,e,i){return this.set(t,0,0,0,0,e,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,e,i,s,r,o){return this.set(1,i,r,0,t,1,o,0,e,s,1,0,0,0,0,1),this}compose(t,e,i){const s=this.elements,r=e._x,o=e._y,a=e._z,l=e._w,c=r+r,h=o+o,u=a+a,d=r*c,f=r*h,p=r*u,x=o*h,_=o*u,m=a*u,g=l*c,S=l*h,v=l*u,E=i.x,R=i.y,D=i.z;return s[0]=(1-(x+m))*E,s[1]=(f+v)*E,s[2]=(p-S)*E,s[3]=0,s[4]=(f-v)*R,s[5]=(1-(d+m))*R,s[6]=(_+g)*R,s[7]=0,s[8]=(p+S)*D,s[9]=(_-g)*D,s[10]=(1-(d+x))*D,s[11]=0,s[12]=t.x,s[13]=t.y,s[14]=t.z,s[15]=1,this}decompose(t,e,i){const s=this.elements;let r=tr.set(s[0],s[1],s[2]).length();const o=tr.set(s[4],s[5],s[6]).length(),a=tr.set(s[8],s[9],s[10]).length();this.determinant()<0&&(r=-r),t.x=s[12],t.y=s[13],t.z=s[14],_n.copy(this);const c=1/r,h=1/o,u=1/a;return _n.elements[0]*=c,_n.elements[1]*=c,_n.elements[2]*=c,_n.elements[4]*=h,_n.elements[5]*=h,_n.elements[6]*=h,_n.elements[8]*=u,_n.elements[9]*=u,_n.elements[10]*=u,e.setFromRotationMatrix(_n),i.x=r,i.y=o,i.z=a,this}makePerspective(t,e,i,s,r,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*r/(e-t),c=2*r/(i-s),h=(e+t)/(e-t),u=(i+s)/(i-s),d=-(o+r)/(o-r),f=-2*o*r/(o-r);return a[0]=l,a[4]=0,a[8]=h,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=f,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,e,i,s,r,o){const a=this.elements,l=1/(e-t),c=1/(i-s),h=1/(o-r),u=(e+t)*l,d=(i+s)*c,f=(o+r)*h;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*h,a[14]=-f,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const e=this.elements,i=t.elements;for(let s=0;s<16;s++)if(e[s]!==i[s])return!1;return!0}fromArray(t,e=0){for(let i=0;i<16;i++)this.elements[i]=t[i+e];return this}toArray(t=[],e=0){const i=this.elements;return t[e]=i[0],t[e+1]=i[1],t[e+2]=i[2],t[e+3]=i[3],t[e+4]=i[4],t[e+5]=i[5],t[e+6]=i[6],t[e+7]=i[7],t[e+8]=i[8],t[e+9]=i[9],t[e+10]=i[10],t[e+11]=i[11],t[e+12]=i[12],t[e+13]=i[13],t[e+14]=i[14],t[e+15]=i[15],t}}Tt.prototype.isMatrix4=!0;const tr=new I,_n=new Tt,zT=new I(0,0,0),BT=new I(1,1,1),Mi=new I,gl=new I,Qe=new I,Kg=new Tt,Qg=new Ge;class er{constructor(t=0,e=0,i=0,s=er.DefaultOrder){this._x=t,this._y=e,this._z=i,this._order=s}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,e,i,s=this._order){return this._x=t,this._y=e,this._z=i,this._order=s,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,e=this._order,i=!0){const s=t.elements,r=s[0],o=s[4],a=s[8],l=s[1],c=s[5],h=s[9],u=s[2],d=s[6],f=s[10];switch(e){case"XYZ":this._y=Math.asin(Je(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-h,f),this._z=Math.atan2(-o,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Je(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(a,f),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-u,r),this._z=0);break;case"ZXY":this._x=Math.asin(Je(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-u,f),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-Je(u,-1,1)),Math.abs(u)<.9999999?(this._x=Math.atan2(d,f),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Je(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-u,r)):(this._x=0,this._y=Math.atan2(a,f));break;case"XZY":this._z=Math.asin(-Je(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,r)):(this._x=Math.atan2(-h,f),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+e)}return this._order=e,i===!0&&this._onChangeCallback(),this}setFromQuaternion(t,e,i){return Kg.makeRotationFromQuaternion(t),this.setFromRotationMatrix(Kg,e,i)}setFromVector3(t,e=this._order){return this.set(t.x,t.y,t.z,e)}reorder(t){return Qg.setFromEuler(this),this.setFromQuaternion(Qg,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],e=0){return t[e]=this._x,t[e+1]=this._y,t[e+2]=this._z,t[e+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new I(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}er.prototype.isEuler=!0;er.DefaultOrder="XYZ";er.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class tx{constructor(){this.mask=1|0}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=4294967295|0}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!=0}isEnabled(t){return(this.mask&(1<<t|0))!=0}}let HT=0;const ex=new I,nr=new Ge,Jn=new Tt,xl=new I,wo=new I,UT=new I,VT=new Ge,nx=new I(1,0,0),ix=new I(0,1,0),sx=new I(0,0,1),WT={type:"added"},rx={type:"removed"};class qt extends as{constructor(){super();Object.defineProperty(this,"id",{value:HT++}),this.uuid=Fn(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=qt.DefaultUp.clone();const t=new I,e=new er,i=new Ge,s=new I(1,1,1);function r(){i.setFromEuler(e,!1)}function o(){e.setFromQuaternion(i,void 0,!1)}e._onChange(r),i._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:t},rotation:{configurable:!0,enumerable:!0,value:e},quaternion:{configurable:!0,enumerable:!0,value:i},scale:{configurable:!0,enumerable:!0,value:s},modelViewMatrix:{value:new Tt},normalMatrix:{value:new ye}}),this.matrix=new Tt,this.matrixWorld=new Tt,this.matrixAutoUpdate=qt.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new tx,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(t){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(t),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(t){return this.quaternion.premultiply(t),this}setRotationFromAxisAngle(t,e){this.quaternion.setFromAxisAngle(t,e)}setRotationFromEuler(t){this.quaternion.setFromEuler(t,!0)}setRotationFromMatrix(t){this.quaternion.setFromRotationMatrix(t)}setRotationFromQuaternion(t){this.quaternion.copy(t)}rotateOnAxis(t,e){return nr.setFromAxisAngle(t,e),this.quaternion.multiply(nr),this}rotateOnWorldAxis(t,e){return nr.setFromAxisAngle(t,e),this.quaternion.premultiply(nr),this}rotateX(t){return this.rotateOnAxis(nx,t)}rotateY(t){return this.rotateOnAxis(ix,t)}rotateZ(t){return this.rotateOnAxis(sx,t)}translateOnAxis(t,e){return ex.copy(t).applyQuaternion(this.quaternion),this.position.add(ex.multiplyScalar(e)),this}translateX(t){return this.translateOnAxis(nx,t)}translateY(t){return this.translateOnAxis(ix,t)}translateZ(t){return this.translateOnAxis(sx,t)}localToWorld(t){return t.applyMatrix4(this.matrixWorld)}worldToLocal(t){return t.applyMatrix4(Jn.copy(this.matrixWorld).invert())}lookAt(t,e,i){t.isVector3?xl.copy(t):xl.set(t,e,i);const s=this.parent;this.updateWorldMatrix(!0,!1),wo.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Jn.lookAt(wo,xl,this.up):Jn.lookAt(xl,wo,this.up),this.quaternion.setFromRotationMatrix(Jn),s&&(Jn.extractRotation(s.matrixWorld),nr.setFromRotationMatrix(Jn),this.quaternion.premultiply(nr.invert()))}add(t){if(arguments.length>1){for(let e=0;e<arguments.length;e++)this.add(arguments[e]);return this}return t===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this):(t&&t.isObject3D?(t.parent!==null&&t.parent.remove(t),t.parent=this,this.children.push(t),t.dispatchEvent(WT)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t),this)}remove(t){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const e=this.children.indexOf(t);return e!==-1&&(t.parent=null,this.children.splice(e,1),t.dispatchEvent(rx)),this}removeFromParent(){const t=this.parent;return t!==null&&t.remove(this),this}clear(){for(let t=0;t<this.children.length;t++){const e=this.children[t];e.parent=null,e.dispatchEvent(rx)}return this.children.length=0,this}attach(t){return this.updateWorldMatrix(!0,!1),Jn.copy(this.matrixWorld).invert(),t.parent!==null&&(t.parent.updateWorldMatrix(!0,!1),Jn.multiply(t.parent.matrixWorld)),t.applyMatrix4(Jn),this.add(t),t.updateWorldMatrix(!1,!0),this}getObjectById(t){return this.getObjectByProperty("id",t)}getObjectByName(t){return this.getObjectByProperty("name",t)}getObjectByProperty(t,e){if(this[t]===e)return this;for(let i=0,s=this.children.length;i<s;i++){const o=this.children[i].getObjectByProperty(t,e);if(o!==void 0)return o}}getWorldPosition(t){return this.updateWorldMatrix(!0,!1),t.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wo,t,UT),t}getWorldScale(t){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(wo,VT,t),t}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(t){t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverse(t)}traverseVisible(t){if(this.visible===!1)return;t(this);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].traverseVisible(t)}traverseAncestors(t){const e=this.parent;e!==null&&(t(e),e.traverseAncestors(t))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(t){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||t)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,t=!0);const e=this.children;for(let i=0,s=e.length;i<s;i++)e[i].updateMatrixWorld(t)}updateWorldMatrix(t,e){const i=this.parent;if(t===!0&&i!==null&&i.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),e===!0){const s=this.children;for(let r=0,o=s.length;r<o;r++)s[r].updateWorldMatrix(!1,!0)}}toJSON(t){const e=t===void 0||typeof t=="string",i={};e&&(t={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},i.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const s={};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.castShadow===!0&&(s.castShadow=!0),this.receiveShadow===!0&&(s.receiveShadow=!0),this.visible===!1&&(s.visible=!1),this.frustumCulled===!1&&(s.frustumCulled=!1),this.renderOrder!==0&&(s.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),s.layers=this.layers.mask,s.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(s.matrixAutoUpdate=!1),this.isInstancedMesh&&(s.type="InstancedMesh",s.count=this.count,s.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(s.instanceColor=this.instanceColor.toJSON()));function r(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(t)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?s.background=this.background.toJSON():this.background.isTexture&&(s.background=this.background.toJSON(t).uuid)),this.environment&&this.environment.isTexture&&(s.environment=this.environment.toJSON(t).uuid);else if(this.isMesh||this.isLine||this.isPoints){s.geometry=r(t.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const u=l[c];r(t.shapes,u)}else r(t.shapes,l)}}if(this.isSkinnedMesh&&(s.bindMode=this.bindMode,s.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(t.skeletons,this.skeleton),s.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(r(t.materials,this.material[l]));s.material=a}else s.material=r(t.materials,this.material);if(this.children.length>0){s.children=[];for(let a=0;a<this.children.length;a++)s.children.push(this.children[a].toJSON(t).object)}if(this.animations.length>0){s.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];s.animations.push(r(t.animations,l))}}if(e){const a=o(t.geometries),l=o(t.materials),c=o(t.textures),h=o(t.images),u=o(t.shapes),d=o(t.skeletons),f=o(t.animations);a.length>0&&(i.geometries=a),l.length>0&&(i.materials=l),c.length>0&&(i.textures=c),h.length>0&&(i.images=h),u.length>0&&(i.shapes=u),d.length>0&&(i.skeletons=d),f.length>0&&(i.animations=f)}return i.object=s,i;function o(a){const l=[];for(const c in a){const h=a[c];delete h.metadata,l.push(h)}return l}}clone(t){return new this.constructor().copy(this,t)}copy(t,e=!0){if(this.name=t.name,this.up.copy(t.up),this.position.copy(t.position),this.rotation.order=t.rotation.order,this.quaternion.copy(t.quaternion),this.scale.copy(t.scale),this.matrix.copy(t.matrix),this.matrixWorld.copy(t.matrixWorld),this.matrixAutoUpdate=t.matrixAutoUpdate,this.matrixWorldNeedsUpdate=t.matrixWorldNeedsUpdate,this.layers.mask=t.layers.mask,this.visible=t.visible,this.castShadow=t.castShadow,this.receiveShadow=t.receiveShadow,this.frustumCulled=t.frustumCulled,this.renderOrder=t.renderOrder,this.userData=JSON.parse(JSON.stringify(t.userData)),e===!0)for(let i=0;i<t.children.length;i++){const s=t.children[i];this.add(s.clone())}return this}}qt.DefaultUp=new I(0,1,0);qt.DefaultMatrixAutoUpdate=!0;qt.prototype.isObject3D=!0;const yn=new I,Kn=new I,fu=new I,Qn=new I,ir=new I,sr=new I,ox=new I,pu=new I,mu=new I,gu=new I;class pe{constructor(t=new I,e=new I,i=new I){this.a=t,this.b=e,this.c=i}static getNormal(t,e,i,s){s.subVectors(i,e),yn.subVectors(t,e),s.cross(yn);const r=s.lengthSq();return r>0?s.multiplyScalar(1/Math.sqrt(r)):s.set(0,0,0)}static getBarycoord(t,e,i,s,r){yn.subVectors(s,e),Kn.subVectors(i,e),fu.subVectors(t,e);const o=yn.dot(yn),a=yn.dot(Kn),l=yn.dot(fu),c=Kn.dot(Kn),h=Kn.dot(fu),u=o*c-a*a;if(u===0)return r.set(-2,-1,-1);const d=1/u,f=(c*l-a*h)*d,p=(o*h-a*l)*d;return r.set(1-f-p,p,f)}static containsPoint(t,e,i,s){return this.getBarycoord(t,e,i,s,Qn),Qn.x>=0&&Qn.y>=0&&Qn.x+Qn.y<=1}static getUV(t,e,i,s,r,o,a,l){return this.getBarycoord(t,e,i,s,Qn),l.set(0,0),l.addScaledVector(r,Qn.x),l.addScaledVector(o,Qn.y),l.addScaledVector(a,Qn.z),l}static isFrontFacing(t,e,i,s){return yn.subVectors(i,e),Kn.subVectors(t,e),yn.cross(Kn).dot(s)<0}set(t,e,i){return this.a.copy(t),this.b.copy(e),this.c.copy(i),this}setFromPointsAndIndices(t,e,i,s){return this.a.copy(t[e]),this.b.copy(t[i]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,i,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,i),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return yn.subVectors(this.c,this.b),Kn.subVectors(this.a,this.b),yn.cross(Kn).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return pe.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return pe.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,i,s,r){return pe.getUV(t,this.a,this.b,this.c,e,i,s,r)}containsPoint(t){return pe.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return pe.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const i=this.a,s=this.b,r=this.c;let o,a;ir.subVectors(s,i),sr.subVectors(r,i),pu.subVectors(t,i);const l=ir.dot(pu),c=sr.dot(pu);if(l<=0&&c<=0)return e.copy(i);mu.subVectors(t,s);const h=ir.dot(mu),u=sr.dot(mu);if(h>=0&&u<=h)return e.copy(s);const d=l*u-h*c;if(d<=0&&l>=0&&h<=0)return o=l/(l-h),e.copy(i).addScaledVector(ir,o);gu.subVectors(t,r);const f=ir.dot(gu),p=sr.dot(gu);if(p>=0&&f<=p)return e.copy(r);const x=f*c-l*p;if(x<=0&&c>=0&&p<=0)return a=c/(c-p),e.copy(i).addScaledVector(sr,a);const _=h*p-f*u;if(_<=0&&u-h>=0&&f-p>=0)return ox.subVectors(r,s),a=(u-h)/(u-h+(f-p)),e.copy(s).addScaledVector(ox,a);const m=1/(_+x+d);return o=x*m,a=d*m,e.copy(i).addScaledVector(ir,o).addScaledVector(sr,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}let GT=0;class Ie extends as{constructor(){super();Object.defineProperty(this,"id",{value:GT++}),this.uuid=Fn(),this.name="",this.type="Material",this.fog=!0,this.blending=go,this.side=mo,this.vertexColors=!1,this.opacity=1,this.format=be,this.transparent=!1,this.blendSrc=Pg,this.blendDst=Dg,this.blendEquation=Hs,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=qh,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=DT,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=tu,this.stencilZFail=tu,this.stencilZPass=tu,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(t){this._alphaTest>0!=t>0&&this.version++,this._alphaTest=t}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(t){if(t!==void 0)for(const e in t){const i=t[e];if(i===void 0){console.warn("THREE.Material: '"+e+"' parameter is undefined.");continue}if(e==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=i===Eg;continue}const s=this[e];if(s===void 0){console.warn("THREE."+this.type+": '"+e+"' is not a property of this material.");continue}s&&s.isColor?s.set(i):s&&s.isVector3&&i&&i.isVector3?s.copy(i):this[e]=i}}toJSON(t){const e=t===void 0||typeof t=="string";e&&(t={textures:{},images:{}});const i={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.color&&this.color.isColor&&(i.color=this.color.getHex()),this.roughness!==void 0&&(i.roughness=this.roughness),this.metalness!==void 0&&(i.metalness=this.metalness),this.sheen!==void 0&&(i.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(i.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(i.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(i.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(i.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(i.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(i.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(i.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(i.shininess=this.shininess),this.clearcoat!==void 0&&(i.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(i.clearcoatMap=this.clearcoatMap.toJSON(t).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(i.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(t).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(i.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(t).uuid,i.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(i.map=this.map.toJSON(t).uuid),this.matcap&&this.matcap.isTexture&&(i.matcap=this.matcap.toJSON(t).uuid),this.alphaMap&&this.alphaMap.isTexture&&(i.alphaMap=this.alphaMap.toJSON(t).uuid),this.lightMap&&this.lightMap.isTexture&&(i.lightMap=this.lightMap.toJSON(t).uuid,i.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(i.aoMap=this.aoMap.toJSON(t).uuid,i.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(i.bumpMap=this.bumpMap.toJSON(t).uuid,i.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(i.normalMap=this.normalMap.toJSON(t).uuid,i.normalMapType=this.normalMapType,i.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(i.displacementMap=this.displacementMap.toJSON(t).uuid,i.displacementScale=this.displacementScale,i.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(i.roughnessMap=this.roughnessMap.toJSON(t).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(i.metalnessMap=this.metalnessMap.toJSON(t).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(i.emissiveMap=this.emissiveMap.toJSON(t).uuid),this.specularMap&&this.specularMap.isTexture&&(i.specularMap=this.specularMap.toJSON(t).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(i.specularIntensityMap=this.specularIntensityMap.toJSON(t).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(i.specularColorMap=this.specularColorMap.toJSON(t).uuid),this.envMap&&this.envMap.isTexture&&(i.envMap=this.envMap.toJSON(t).uuid,this.combine!==void 0&&(i.combine=this.combine)),this.envMapIntensity!==void 0&&(i.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(i.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(i.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(i.gradientMap=this.gradientMap.toJSON(t).uuid),this.transmission!==void 0&&(i.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(i.transmissionMap=this.transmissionMap.toJSON(t).uuid),this.thickness!==void 0&&(i.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(i.thicknessMap=this.thicknessMap.toJSON(t).uuid),this.attenuationDistance!==void 0&&(i.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(i.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(i.size=this.size),this.shadowSide!==null&&(i.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(i.sizeAttenuation=this.sizeAttenuation),this.blending!==go&&(i.blending=this.blending),this.side!==mo&&(i.side=this.side),this.vertexColors&&(i.vertexColors=!0),this.opacity<1&&(i.opacity=this.opacity),this.format!==be&&(i.format=this.format),this.transparent===!0&&(i.transparent=this.transparent),i.depthFunc=this.depthFunc,i.depthTest=this.depthTest,i.depthWrite=this.depthWrite,i.colorWrite=this.colorWrite,i.stencilWrite=this.stencilWrite,i.stencilWriteMask=this.stencilWriteMask,i.stencilFunc=this.stencilFunc,i.stencilRef=this.stencilRef,i.stencilFuncMask=this.stencilFuncMask,i.stencilFail=this.stencilFail,i.stencilZFail=this.stencilZFail,i.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(i.rotation=this.rotation),this.polygonOffset===!0&&(i.polygonOffset=!0),this.polygonOffsetFactor!==0&&(i.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(i.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(i.linewidth=this.linewidth),this.dashSize!==void 0&&(i.dashSize=this.dashSize),this.gapSize!==void 0&&(i.gapSize=this.gapSize),this.scale!==void 0&&(i.scale=this.scale),this.dithering===!0&&(i.dithering=!0),this.alphaTest>0&&(i.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(i.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(i.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(i.wireframe=this.wireframe),this.wireframeLinewidth>1&&(i.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(i.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(i.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(i.flatShading=this.flatShading),this.visible===!1&&(i.visible=!1),this.toneMapped===!1&&(i.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData);function s(r){const o=[];for(const a in r){const l=r[a];delete l.metadata,o.push(l)}return o}if(e){const r=s(t.textures),o=s(t.images);r.length>0&&(i.textures=r),o.length>0&&(i.images=o)}return i}clone(){return new this.constructor().copy(this)}copy(t){this.name=t.name,this.fog=t.fog,this.blending=t.blending,this.side=t.side,this.vertexColors=t.vertexColors,this.opacity=t.opacity,this.format=t.format,this.transparent=t.transparent,this.blendSrc=t.blendSrc,this.blendDst=t.blendDst,this.blendEquation=t.blendEquation,this.blendSrcAlpha=t.blendSrcAlpha,this.blendDstAlpha=t.blendDstAlpha,this.blendEquationAlpha=t.blendEquationAlpha,this.depthFunc=t.depthFunc,this.depthTest=t.depthTest,this.depthWrite=t.depthWrite,this.stencilWriteMask=t.stencilWriteMask,this.stencilFunc=t.stencilFunc,this.stencilRef=t.stencilRef,this.stencilFuncMask=t.stencilFuncMask,this.stencilFail=t.stencilFail,this.stencilZFail=t.stencilZFail,this.stencilZPass=t.stencilZPass,this.stencilWrite=t.stencilWrite;const e=t.clippingPlanes;let i=null;if(e!==null){const s=e.length;i=new Array(s);for(let r=0;r!==s;++r)i[r]=e[r].clone()}return this.clippingPlanes=i,this.clipIntersection=t.clipIntersection,this.clipShadows=t.clipShadows,this.shadowSide=t.shadowSide,this.colorWrite=t.colorWrite,this.precision=t.precision,this.polygonOffset=t.polygonOffset,this.polygonOffsetFactor=t.polygonOffsetFactor,this.polygonOffsetUnits=t.polygonOffsetUnits,this.dithering=t.dithering,this.alphaTest=t.alphaTest,this.alphaToCoverage=t.alphaToCoverage,this.premultipliedAlpha=t.premultipliedAlpha,this.visible=t.visible,this.toneMapped=t.toneMapped,this.userData=JSON.parse(JSON.stringify(t.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(t){t===!0&&this.version++}}Ie.prototype.isMaterial=!0;const ax={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},vn={h:0,s:0,l:0},_l={h:0,s:0,l:0};function xu(n,t,e){return e<0&&(e+=1),e>1&&(e-=1),e<1/6?n+(t-n)*6*e:e<1/2?t:e<2/3?n+(t-n)*6*(2/3-e):n}function _u(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function yu(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Et{constructor(t,e,i){return e===void 0&&i===void 0?this.set(t):this.setRGB(t,e,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,e,i){return this.r=t,this.g=e,this.b=i,this}setHSL(t,e,i){if(t=IT(t,1),e=Je(e,0,1),i=Je(i,0,1),e===0)this.r=this.g=this.b=i;else{const s=i<=.5?i*(1+e):i+e-i*e,r=2*i-s;this.r=xu(r,s,t+1/3),this.g=xu(r,s,t),this.b=xu(r,s,t-1/3)}return this}setStyle(t){function e(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)){let s;const r=i[1],o=i[2];switch(r){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(s[1],10))/255,this.g=Math.min(255,parseInt(s[2],10))/255,this.b=Math.min(255,parseInt(s[3],10))/255,e(s[4]),this;if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(s[1],10))/100,this.g=Math.min(100,parseInt(s[2],10))/100,this.b=Math.min(100,parseInt(s[3],10))/100,e(s[4]),this;break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(s[1])/360,l=parseInt(s[2],10)/100,c=parseInt(s[3],10)/100;return e(s[4]),this.setHSL(a,l,c)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const s=i[1],r=s.length;if(r===3)return this.r=parseInt(s.charAt(0)+s.charAt(0),16)/255,this.g=parseInt(s.charAt(1)+s.charAt(1),16)/255,this.b=parseInt(s.charAt(2)+s.charAt(2),16)/255,this;if(r===6)return this.r=parseInt(s.charAt(0)+s.charAt(1),16)/255,this.g=parseInt(s.charAt(2)+s.charAt(3),16)/255,this.b=parseInt(s.charAt(4)+s.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const e=ax[t.toLowerCase()];return e!==void 0?this.setHex(e):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copySRGBToLinear(t){return this.r=_u(t.r),this.g=_u(t.g),this.b=_u(t.b),this}copyLinearToSRGB(t){return this.r=yu(t.r),this.g=yu(t.g),this.b=yu(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){const e=this.r,i=this.g,s=this.b,r=Math.max(e,i,s),o=Math.min(e,i,s);let a,l;const c=(o+r)/2;if(o===r)a=0,l=0;else{const h=r-o;switch(l=c<=.5?h/(r+o):h/(2-r-o),r){case e:a=(i-s)/h+(i<s?6:0);break;case i:a=(s-e)/h+2;break;case s:a=(e-i)/h+4;break}a/=6}return t.h=a,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,e,i){return this.getHSL(vn),vn.h+=t,vn.s+=e,vn.l+=i,this.setHSL(vn.h,vn.s,vn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,e){return this.r=t.r+e.r,this.g=t.g+e.g,this.b=t.b+e.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,e){return this.r+=(t.r-this.r)*e,this.g+=(t.g-this.g)*e,this.b+=(t.b-this.b)*e,this}lerpColors(t,e,i){return this.r=t.r+(e.r-t.r)*i,this.g=t.g+(e.g-t.g)*i,this.b=t.b+(e.b-t.b)*i,this}lerpHSL(t,e){this.getHSL(vn),t.getHSL(_l);const i=iu(vn.h,_l.h,e),s=iu(vn.s,_l.s,e),r=iu(vn.l,_l.l,e);return this.setHSL(i,s,r),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,e=0){return this.r=t[e],this.g=t[e+1],this.b=t[e+2],this}toArray(t=[],e=0){return t[e]=this.r,t[e+1]=this.g,t[e+2]=this.b,t}fromBufferAttribute(t,e){return this.r=t.getX(e),this.g=t.getY(e),this.b=t.getZ(e),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Et.NAMES=ax;Et.prototype.isColor=!0;Et.prototype.r=1;Et.prototype.g=1;Et.prototype.b=1;class yl extends Ie{constructor(t){super();this.type="MeshBasicMaterial",this.color=new Et(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=nl,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}yl.prototype.isMeshBasicMaterial=!0;const se=new I,vl=new mt;class ve{constructor(t,e,i){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=t!==void 0?t.length/e:0,this.normalized=i===!0,this.usage=vo,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,i){t*=this.itemSize,i*=e.itemSize;for(let s=0,r=this.itemSize;s<r;s++)this.array[t+s]=e.array[i+s];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let o=t[s];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",s),o=new Et),e[i++]=o.r,e[i++]=o.g,e[i++]=o.b}return this}copyVector2sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let o=t[s];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",s),o=new mt),e[i++]=o.x,e[i++]=o.y}return this}copyVector3sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let o=t[s];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",s),o=new I),e[i++]=o.x,e[i++]=o.y,e[i++]=o.z}return this}copyVector4sArray(t){const e=this.array;let i=0;for(let s=0,r=t.length;s<r;s++){let o=t[s];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),o=new Zt),e[i++]=o.x,e[i++]=o.y,e[i++]=o.z,e[i++]=o.w}return this}applyMatrix3(t){if(this.itemSize===2)for(let e=0,i=this.count;e<i;e++)vl.fromBufferAttribute(this,e),vl.applyMatrix3(t),this.setXY(e,vl.x,vl.y);else if(this.itemSize===3)for(let e=0,i=this.count;e<i;e++)se.fromBufferAttribute(this,e),se.applyMatrix3(t),this.setXYZ(e,se.x,se.y,se.z);return this}applyMatrix4(t){for(let e=0,i=this.count;e<i;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.applyMatrix4(t),this.setXYZ(e,se.x,se.y,se.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.applyNormalMatrix(t),this.setXYZ(e,se.x,se.y,se.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)se.x=this.getX(e),se.y=this.getY(e),se.z=this.getZ(e),se.transformDirection(t),this.setXYZ(e,se.x,se.y,se.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this}setXYZ(t,e,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this}setXYZW(t,e,i,s,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=i,this.array[t+2]=s,this.array[t+3]=r,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(t.name=this.name),this.usage!==vo&&(t.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(t.updateRange=this.updateRange),t}}ve.prototype.isBufferAttribute=!0;class lx extends ve{constructor(t,e,i){super(new Uint16Array(t),e,i)}}class cx extends ve{constructor(t,e,i){super(new Uint32Array(t),e,i)}}class jT extends ve{constructor(t,e,i){super(new Uint16Array(t),e,i)}}jT.prototype.isFloat16BufferAttribute=!0;class we extends ve{constructor(t,e,i){super(new Float32Array(t),e,i)}}let qT=0;const ln=new Tt,vu=new qt,rr=new I,tn=new Ke,So=new Ke,Se=new I;class ae extends as{constructor(){super();Object.defineProperty(this,"id",{value:qT++}),this.uuid=Fn(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(Yg(t)>65535?cx:lx)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,i=0){this.groups.push({start:t,count:e,materialIndex:i})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const i=this.attributes.normal;if(i!==void 0){const r=new ye().getNormalMatrix(t);i.applyNormalMatrix(r),i.needsUpdate=!0}const s=this.attributes.tangent;return s!==void 0&&(s.transformDirection(t),s.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return ln.makeRotationFromQuaternion(t),this.applyMatrix4(ln),this}rotateX(t){return ln.makeRotationX(t),this.applyMatrix4(ln),this}rotateY(t){return ln.makeRotationY(t),this.applyMatrix4(ln),this}rotateZ(t){return ln.makeRotationZ(t),this.applyMatrix4(ln),this}translate(t,e,i){return ln.makeTranslation(t,e,i),this.applyMatrix4(ln),this}scale(t,e,i){return ln.makeScale(t,e,i),this.applyMatrix4(ln),this}lookAt(t){return vu.lookAt(t),vu.updateMatrix(),this.applyMatrix4(vu.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(rr).negate(),this.translate(rr.x,rr.y,rr.z),this}setFromPoints(t){const e=[];for(let i=0,s=t.length;i<s;i++){const r=t[i];e.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new we(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Ke);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new I(-1/0,-1/0,-1/0),new I(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let i=0,s=e.length;i<s;i++){const r=e[i];tn.setFromBufferAttribute(r),this.morphTargetsRelative?(Se.addVectors(this.boundingBox.min,tn.min),this.boundingBox.expandByPoint(Se),Se.addVectors(this.boundingBox.max,tn.max),this.boundingBox.expandByPoint(Se)):(this.boundingBox.expandByPoint(tn.min),this.boundingBox.expandByPoint(tn.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Ks);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new I,1/0);return}if(t){const i=this.boundingSphere.center;if(tn.setFromBufferAttribute(t),e)for(let r=0,o=e.length;r<o;r++){const a=e[r];So.setFromBufferAttribute(a),this.morphTargetsRelative?(Se.addVectors(tn.min,So.min),tn.expandByPoint(Se),Se.addVectors(tn.max,So.max),tn.expandByPoint(Se)):(tn.expandByPoint(So.min),tn.expandByPoint(So.max))}tn.getCenter(i);let s=0;for(let r=0,o=t.count;r<o;r++)Se.fromBufferAttribute(t,r),s=Math.max(s,i.distanceToSquared(Se));if(e)for(let r=0,o=e.length;r<o;r++){const a=e[r],l=this.morphTargetsRelative;for(let c=0,h=a.count;c<h;c++)Se.fromBufferAttribute(a,c),l&&(rr.fromBufferAttribute(t,c),Se.add(rr)),s=Math.max(s,i.distanceToSquared(Se))}this.boundingSphere.radius=Math.sqrt(s),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const i=t.array,s=e.position.array,r=e.normal.array,o=e.uv.array,a=s.length/3;e.tangent===void 0&&this.setAttribute("tangent",new ve(new Float32Array(4*a),4));const l=e.tangent.array,c=[],h=[];for(let tt=0;tt<a;tt++)c[tt]=new I,h[tt]=new I;const u=new I,d=new I,f=new I,p=new mt,x=new mt,_=new mt,m=new I,g=new I;function S(tt,N,T){u.fromArray(s,tt*3),d.fromArray(s,N*3),f.fromArray(s,T*3),p.fromArray(o,tt*2),x.fromArray(o,N*2),_.fromArray(o,T*2),d.sub(u),f.sub(u),x.sub(p),_.sub(p);const A=1/(x.x*_.y-_.x*x.y);!isFinite(A)||(m.copy(d).multiplyScalar(_.y).addScaledVector(f,-x.y).multiplyScalar(A),g.copy(f).multiplyScalar(x.x).addScaledVector(d,-_.x).multiplyScalar(A),c[tt].add(m),c[N].add(m),c[T].add(m),h[tt].add(g),h[N].add(g),h[T].add(g))}let v=this.groups;v.length===0&&(v=[{start:0,count:i.length}]);for(let tt=0,N=v.length;tt<N;++tt){const T=v[tt],A=T.start,W=T.count;for(let V=A,k=A+W;V<k;V+=3)S(i[V+0],i[V+1],i[V+2])}const E=new I,R=new I,D=new I,$=new I;function it(tt){D.fromArray(r,tt*3),$.copy(D);const N=c[tt];E.copy(N),E.sub(D.multiplyScalar(D.dot(N))).normalize(),R.crossVectors($,N);const A=R.dot(h[tt])<0?-1:1;l[tt*4]=E.x,l[tt*4+1]=E.y,l[tt*4+2]=E.z,l[tt*4+3]=A}for(let tt=0,N=v.length;tt<N;++tt){const T=v[tt],A=T.start,W=T.count;for(let V=A,k=A+W;V<k;V+=3)it(i[V+0]),it(i[V+1]),it(i[V+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let i=this.getAttribute("normal");if(i===void 0)i=new ve(new Float32Array(e.count*3),3),this.setAttribute("normal",i);else for(let d=0,f=i.count;d<f;d++)i.setXYZ(d,0,0,0);const s=new I,r=new I,o=new I,a=new I,l=new I,c=new I,h=new I,u=new I;if(t)for(let d=0,f=t.count;d<f;d+=3){const p=t.getX(d+0),x=t.getX(d+1),_=t.getX(d+2);s.fromBufferAttribute(e,p),r.fromBufferAttribute(e,x),o.fromBufferAttribute(e,_),h.subVectors(o,r),u.subVectors(s,r),h.cross(u),a.fromBufferAttribute(i,p),l.fromBufferAttribute(i,x),c.fromBufferAttribute(i,_),a.add(h),l.add(h),c.add(h),i.setXYZ(p,a.x,a.y,a.z),i.setXYZ(x,l.x,l.y,l.z),i.setXYZ(_,c.x,c.y,c.z)}else for(let d=0,f=e.count;d<f;d+=3)s.fromBufferAttribute(e,d+0),r.fromBufferAttribute(e,d+1),o.fromBufferAttribute(e,d+2),h.subVectors(o,r),u.subVectors(s,r),h.cross(u),i.setXYZ(d+0,h.x,h.y,h.z),i.setXYZ(d+1,h.x,h.y,h.z),i.setXYZ(d+2,h.x,h.y,h.z);this.normalizeNormals(),i.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const i=this.attributes;for(const s in i){if(t.attributes[s]===void 0)continue;const o=i[s].array,a=t.attributes[s],l=a.array,c=a.itemSize*e,h=Math.min(l.length,o.length-c);for(let u=0,d=c;u<h;u++,d++)o[d]=l[u]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,i=t.count;e<i;e++)Se.fromBufferAttribute(t,e),Se.normalize(),t.setXYZ(e,Se.x,Se.y,Se.z)}toNonIndexed(){function t(a,l){const c=a.array,h=a.itemSize,u=a.normalized,d=new c.constructor(l.length*h);let f=0,p=0;for(let x=0,_=l.length;x<_;x++){a.isInterleavedBufferAttribute?f=l[x]*a.data.stride+a.offset:f=l[x]*h;for(let m=0;m<h;m++)d[p++]=c[f++]}return new ve(d,h,u)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new ae,i=this.index.array,s=this.attributes;for(const a in s){const l=s[a],c=t(l,i);e.setAttribute(a,c)}const r=this.morphAttributes;for(const a in r){const l=[],c=r[a];for(let h=0,u=c.length;h<u;h++){const d=c[h],f=t(d,i);l.push(f)}e.morphAttributes[a]=l}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];e.addGroup(c.start,c.count,c.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(t[c]=l[c]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const i=this.attributes;for(const l in i){const c=i[l];t.data.attributes[l]=c.toJSON(t.data)}const s={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let u=0,d=c.length;u<d;u++){const f=c[u];h.push(f.toJSON(t.data))}h.length>0&&(s[l]=h,r=!0)}r&&(t.data.morphAttributes=s,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(t.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const i=t.index;i!==null&&this.setIndex(i.clone(e));const s=t.attributes;for(const c in s){const h=s[c];this.setAttribute(c,h.clone(e))}const r=t.morphAttributes;for(const c in r){const h=[],u=r[c];for(let d=0,f=u.length;d<f;d++)h.push(u[d].clone(e));this.morphAttributes[c]=h}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let c=0,h=o.length;c<h;c++){const u=o[c];this.addGroup(u.start,u.count,u.materialIndex)}const a=t.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=t.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}ae.prototype.isBufferGeometry=!0;const hx=new Tt,or=new Qs,bu=new Ks,wi=new I,Si=new I,Ei=new I,Mu=new I,wu=new I,Su=new I,bl=new I,Ml=new I,wl=new I,Sl=new mt,El=new mt,Tl=new mt,Eu=new I,Al=new I;class He extends qt{constructor(t=new ae,e=new yl){super();this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const i=this.geometry,s=this.material,r=this.matrixWorld;if(s===void 0||(i.boundingSphere===null&&i.computeBoundingSphere(),bu.copy(i.boundingSphere),bu.applyMatrix4(r),t.ray.intersectsSphere(bu)===!1)||(hx.copy(r).invert(),or.copy(t.ray).applyMatrix4(hx),i.boundingBox!==null&&or.intersectsBox(i.boundingBox)===!1))return;let o;if(i.isBufferGeometry){const a=i.index,l=i.attributes.position,c=i.morphAttributes.position,h=i.morphTargetsRelative,u=i.attributes.uv,d=i.attributes.uv2,f=i.groups,p=i.drawRange;if(a!==null)if(Array.isArray(s))for(let x=0,_=f.length;x<_;x++){const m=f[x],g=s[m.materialIndex],S=Math.max(m.start,p.start),v=Math.min(a.count,Math.min(m.start+m.count,p.start+p.count));for(let E=S,R=v;E<R;E+=3){const D=a.getX(E),$=a.getX(E+1),it=a.getX(E+2);o=Cl(this,g,t,or,l,c,h,u,d,D,$,it),o&&(o.faceIndex=Math.floor(E/3),o.face.materialIndex=m.materialIndex,e.push(o))}}else{const x=Math.max(0,p.start),_=Math.min(a.count,p.start+p.count);for(let m=x,g=_;m<g;m+=3){const S=a.getX(m),v=a.getX(m+1),E=a.getX(m+2);o=Cl(this,s,t,or,l,c,h,u,d,S,v,E),o&&(o.faceIndex=Math.floor(m/3),e.push(o))}}else if(l!==void 0)if(Array.isArray(s))for(let x=0,_=f.length;x<_;x++){const m=f[x],g=s[m.materialIndex],S=Math.max(m.start,p.start),v=Math.min(l.count,Math.min(m.start+m.count,p.start+p.count));for(let E=S,R=v;E<R;E+=3){const D=E,$=E+1,it=E+2;o=Cl(this,g,t,or,l,c,h,u,d,D,$,it),o&&(o.faceIndex=Math.floor(E/3),o.face.materialIndex=m.materialIndex,e.push(o))}}else{const x=Math.max(0,p.start),_=Math.min(l.count,p.start+p.count);for(let m=x,g=_;m<g;m+=3){const S=m,v=m+1,E=m+2;o=Cl(this,s,t,or,l,c,h,u,d,S,v,E),o&&(o.faceIndex=Math.floor(m/3),e.push(o))}}}else i.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}He.prototype.isMesh=!0;function XT(n,t,e,i,s,r,o,a){let l;if(t.side===xe?l=i.intersectTriangle(o,r,s,!0,a):l=i.intersectTriangle(s,r,o,t.side!==is,a),l===null)return null;Al.copy(a),Al.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(Al);return c<e.near||c>e.far?null:{distance:c,point:Al.clone(),object:n}}function Cl(n,t,e,i,s,r,o,a,l,c,h,u){wi.fromBufferAttribute(s,c),Si.fromBufferAttribute(s,h),Ei.fromBufferAttribute(s,u);const d=n.morphTargetInfluences;if(r&&d){bl.set(0,0,0),Ml.set(0,0,0),wl.set(0,0,0);for(let p=0,x=r.length;p<x;p++){const _=d[p],m=r[p];_!==0&&(Mu.fromBufferAttribute(m,c),wu.fromBufferAttribute(m,h),Su.fromBufferAttribute(m,u),o?(bl.addScaledVector(Mu,_),Ml.addScaledVector(wu,_),wl.addScaledVector(Su,_)):(bl.addScaledVector(Mu.sub(wi),_),Ml.addScaledVector(wu.sub(Si),_),wl.addScaledVector(Su.sub(Ei),_)))}wi.add(bl),Si.add(Ml),Ei.add(wl)}n.isSkinnedMesh&&(n.boneTransform(c,wi),n.boneTransform(h,Si),n.boneTransform(u,Ei));const f=XT(n,t,e,i,wi,Si,Ei,Eu);if(f){a&&(Sl.fromBufferAttribute(a,c),El.fromBufferAttribute(a,h),Tl.fromBufferAttribute(a,u),f.uv=pe.getUV(Eu,wi,Si,Ei,Sl,El,Tl,new mt)),l&&(Sl.fromBufferAttribute(l,c),El.fromBufferAttribute(l,h),Tl.fromBufferAttribute(l,u),f.uv2=pe.getUV(Eu,wi,Si,Ei,Sl,El,Tl,new mt));const p={a:c,b:h,c:u,normal:new I,materialIndex:0};pe.getNormal(wi,Si,Ei,p.normal),f.face=p}return f}class Eo extends ae{constructor(t=1,e=1,i=1,s=1,r=1,o=1){super();this.type="BoxGeometry",this.parameters={width:t,height:e,depth:i,widthSegments:s,heightSegments:r,depthSegments:o};const a=this;s=Math.floor(s),r=Math.floor(r),o=Math.floor(o);const l=[],c=[],h=[],u=[];let d=0,f=0;p("z","y","x",-1,-1,i,e,t,o,r,0),p("z","y","x",1,-1,i,e,-t,o,r,1),p("x","z","y",1,1,t,i,e,s,o,2),p("x","z","y",1,-1,t,i,-e,s,o,3),p("x","y","z",1,-1,t,e,i,s,r,4),p("x","y","z",-1,-1,t,e,-i,s,r,5),this.setIndex(l),this.setAttribute("position",new we(c,3)),this.setAttribute("normal",new we(h,3)),this.setAttribute("uv",new we(u,2));function p(x,_,m,g,S,v,E,R,D,$,it){const tt=v/D,N=E/$,T=v/2,A=E/2,W=R/2,V=D+1,k=$+1;let U=0,ct=0;const xt=new I;for(let et=0;et<k;et++){const ot=et*N-A;for(let yt=0;yt<V;yt++){const gt=yt*tt-T;xt[x]=gt*g,xt[_]=ot*S,xt[m]=W,c.push(xt.x,xt.y,xt.z),xt[x]=0,xt[_]=0,xt[m]=R>0?1:-1,h.push(xt.x,xt.y,xt.z),u.push(yt/D),u.push(1-et/$),U+=1}}for(let et=0;et<$;et++)for(let ot=0;ot<D;ot++){const yt=d+ot+V*et,gt=d+ot+V*(et+1),wt=d+(ot+1)+V*(et+1),J=d+(ot+1)+V*et;l.push(yt,gt,J),l.push(gt,wt,J),ct+=6}a.addGroup(f,ct,it),f+=ct,d+=U}}static fromJSON(t){return new Eo(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments)}}function ar(n){const t={};for(const e in n){t[e]={};for(const i in n[e]){const s=n[e][i];s&&(s.isColor||s.isMatrix3||s.isMatrix4||s.isVector2||s.isVector3||s.isVector4||s.isTexture||s.isQuaternion)?t[e][i]=s.clone():Array.isArray(s)?t[e][i]=s.slice():t[e][i]=s}}return t}function Fe(n){const t={};for(let e=0;e<n.length;e++){const i=ar(n[e]);for(const s in i)t[s]=i[s]}return t}const $T={clone:ar,merge:Fe};var YT=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,ZT=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class hs extends Ie{constructor(t){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=YT,this.fragmentShader=ZT,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,t!==void 0&&(t.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(t))}copy(t){return super.copy(t),this.fragmentShader=t.fragmentShader,this.vertexShader=t.vertexShader,this.uniforms=ar(t.uniforms),this.defines=Object.assign({},t.defines),this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.lights=t.lights,this.clipping=t.clipping,this.extensions=Object.assign({},t.extensions),this.glslVersion=t.glslVersion,this}toJSON(t){const e=super.toJSON(t);e.glslVersion=this.glslVersion,e.uniforms={};for(const s in this.uniforms){const o=this.uniforms[s].value;o&&o.isTexture?e.uniforms[s]={type:"t",value:o.toJSON(t).uuid}:o&&o.isColor?e.uniforms[s]={type:"c",value:o.getHex()}:o&&o.isVector2?e.uniforms[s]={type:"v2",value:o.toArray()}:o&&o.isVector3?e.uniforms[s]={type:"v3",value:o.toArray()}:o&&o.isVector4?e.uniforms[s]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?e.uniforms[s]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?e.uniforms[s]={type:"m4",value:o.toArray()}:e.uniforms[s]={value:o}}Object.keys(this.defines).length>0&&(e.defines=this.defines),e.vertexShader=this.vertexShader,e.fragmentShader=this.fragmentShader;const i={};for(const s in this.extensions)this.extensions[s]===!0&&(i[s]=!0);return Object.keys(i).length>0&&(e.extensions=i),e}}hs.prototype.isShaderMaterial=!0;class Ll extends qt{constructor(){super();this.type="Camera",this.matrixWorldInverse=new Tt,this.projectionMatrix=new Tt,this.projectionMatrixInverse=new Tt}copy(t,e){return super.copy(t,e),this.matrixWorldInverse.copy(t.matrixWorldInverse),this.projectionMatrix.copy(t.projectionMatrix),this.projectionMatrixInverse.copy(t.projectionMatrixInverse),this}getWorldDirection(t){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return t.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(t){super.updateMatrixWorld(t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(t,e){super.updateWorldMatrix(t,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}Ll.prototype.isCamera=!0;class je extends Ll{constructor(t=50,e=1,i=.1,s=2e3){super();this.type="PerspectiveCamera",this.fov=t,this.zoom=1,this.near=i,this.far=s,this.focus=10,this.aspect=e,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.fov=t.fov,this.zoom=t.zoom,this.near=t.near,this.far=t.far,this.focus=t.focus,this.aspect=t.aspect,this.view=t.view===null?null:Object.assign({},t.view),this.filmGauge=t.filmGauge,this.filmOffset=t.filmOffset,this}setFocalLength(t){const e=.5*this.getFilmHeight()/t;this.fov=nu*2*Math.atan(e),this.updateProjectionMatrix()}getFocalLength(){const t=Math.tan(eu*.5*this.fov);return .5*this.getFilmHeight()/t}getEffectiveFOV(){return nu*2*Math.atan(Math.tan(eu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(t,e,i,s,r,o){this.aspect=t/e,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=this.near;let e=t*Math.tan(eu*.5*this.fov)/this.zoom,i=2*e,s=this.aspect*i,r=-.5*s;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;r+=o.offsetX*s/l,e-=o.offsetY*i/c,s*=o.width/l,i*=o.height/c}const a=this.filmOffset;a!==0&&(r+=t*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+s,e,e-i,t,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.fov=this.fov,e.object.zoom=this.zoom,e.object.near=this.near,e.object.far=this.far,e.object.focus=this.focus,e.object.aspect=this.aspect,this.view!==null&&(e.object.view=Object.assign({},this.view)),e.object.filmGauge=this.filmGauge,e.object.filmOffset=this.filmOffset,e}}je.prototype.isPerspectiveCamera=!0;const lr=90,cr=1;class Tu extends qt{constructor(t,e,i){super();if(this.type="CubeCamera",i.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=i;const s=new je(lr,cr,t,e);s.layers=this.layers,s.up.set(0,-1,0),s.lookAt(new I(1,0,0)),this.add(s);const r=new je(lr,cr,t,e);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new I(-1,0,0)),this.add(r);const o=new je(lr,cr,t,e);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new I(0,1,0)),this.add(o);const a=new je(lr,cr,t,e);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new I(0,-1,0)),this.add(a);const l=new je(lr,cr,t,e);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new I(0,0,1)),this.add(l);const c=new je(lr,cr,t,e);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new I(0,0,-1)),this.add(c)}update(t,e){this.parent===null&&this.updateMatrixWorld();const i=this.renderTarget,[s,r,o,a,l,c]=this.children,h=t.xr.enabled,u=t.getRenderTarget();t.xr.enabled=!1;const d=i.texture.generateMipmaps;i.texture.generateMipmaps=!1,t.setRenderTarget(i,0),t.render(e,s),t.setRenderTarget(i,1),t.render(e,r),t.setRenderTarget(i,2),t.render(e,o),t.setRenderTarget(i,3),t.render(e,a),t.setRenderTarget(i,4),t.render(e,l),i.texture.generateMipmaps=d,t.setRenderTarget(i,5),t.render(e,c),t.setRenderTarget(u),t.xr.enabled=h}}class Rl extends Me{constructor(t,e,i,s,r,o,a,l,c,h){t=t!==void 0?t:[],e=e!==void 0?e:xo;super(t,e,i,s,r,o,a,l,c,h);this.flipY=!1}get images(){return this.image}set images(t){this.image=t}}Rl.prototype.isCubeTexture=!0;class ux extends an{constructor(t,e,i){Number.isInteger(e)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),e=i);super(t,t,e);e=e||{},this.texture=new Rl(void 0,e.mapping,e.wrapS,e.wrapT,e.magFilter,e.minFilter,e.format,e.type,e.anisotropy,e.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=e.generateMipmaps!==void 0?e.generateMipmaps:!1,this.texture.minFilter=e.minFilter!==void 0?e.minFilter:Be,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(t,e){this.texture.type=e.type,this.texture.format=be,this.texture.encoding=e.encoding,this.texture.generateMipmaps=e.generateMipmaps,this.texture.minFilter=e.minFilter,this.texture.magFilter=e.magFilter;const i={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},s=new Eo(5,5,5),r=new hs({name:"CubemapFromEquirect",uniforms:ar(i.uniforms),vertexShader:i.vertexShader,fragmentShader:i.fragmentShader,side:xe,blending:gi});r.uniforms.tEquirect.value=e;const o=new He(s,r),a=e.minFilter;return e.minFilter===sl&&(e.minFilter=Be),new Tu(1,10,this).update(t,o),e.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(t,e,i,s){const r=t.getRenderTarget();for(let o=0;o<6;o++)t.setRenderTarget(this,o),t.clear(e,i,s);t.setRenderTarget(r)}}ux.prototype.isWebGLCubeRenderTarget=!0;const Au=new I,JT=new I,KT=new ye;class ti{constructor(t=new I(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,i,s){return this.normal.set(t,e,i),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,i){const s=Au.subVectors(i,e).cross(JT.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const i=t.delta(Au),s=this.normal.dot(i);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:e.copy(i).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return e<0&&i>0||i<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const i=e||KT.getNormalMatrix(t),s=this.coplanarPoint(Au).applyMatrix4(t),r=this.normal.applyMatrix3(i).normalize();return this.constant=-s.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}ti.prototype.isPlane=!0;const hr=new Ks,Pl=new I;class To{constructor(t=new ti,e=new ti,i=new ti,s=new ti,r=new ti,o=new ti){this.planes=[t,e,i,s,r,o]}set(t,e,i,s,r,o){const a=this.planes;return a[0].copy(t),a[1].copy(e),a[2].copy(i),a[3].copy(s),a[4].copy(r),a[5].copy(o),this}copy(t){const e=this.planes;for(let i=0;i<6;i++)e[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const e=this.planes,i=t.elements,s=i[0],r=i[1],o=i[2],a=i[3],l=i[4],c=i[5],h=i[6],u=i[7],d=i[8],f=i[9],p=i[10],x=i[11],_=i[12],m=i[13],g=i[14],S=i[15];return e[0].setComponents(a-s,u-l,x-d,S-_).normalize(),e[1].setComponents(a+s,u+l,x+d,S+_).normalize(),e[2].setComponents(a+r,u+c,x+f,S+m).normalize(),e[3].setComponents(a-r,u-c,x-f,S-m).normalize(),e[4].setComponents(a-o,u-h,x-p,S-g).normalize(),e[5].setComponents(a+o,u+h,x+p,S+g).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),hr.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(hr)}intersectsSprite(t){return hr.center.set(0,0,0),hr.radius=.7071067811865476,hr.applyMatrix4(t.matrixWorld),this.intersectsSphere(hr)}intersectsSphere(t){const e=this.planes,i=t.center,s=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(i)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let i=0;i<6;i++){const s=e[i];if(Pl.x=s.normal.x>0?t.max.x:t.min.x,Pl.y=s.normal.y>0?t.max.y:t.min.y,Pl.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(Pl)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let i=0;i<6;i++)if(e[i].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function dx(){let n=null,t=!1,e=null,i=null;function s(r,o){e(r,o),i=n.requestAnimationFrame(s)}return{start:function(){t!==!0&&e!==null&&(i=n.requestAnimationFrame(s),t=!0)},stop:function(){n.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(r){e=r},setContext:function(r){n=r}}}function QT(n,t){const e=t.isWebGL2,i=new WeakMap;function s(c,h){const u=c.array,d=c.usage,f=n.createBuffer();n.bindBuffer(h,f),n.bufferData(h,u,d),c.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?e?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:(u instanceof Uint8Array||u instanceof Uint8ClampedArray)&&(p=5121),{buffer:f,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function r(c,h,u){const d=h.array,f=h.updateRange;n.bindBuffer(u,c),f.count===-1?n.bufferSubData(u,0,d):(e?n.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d,f.offset,f.count):n.bufferSubData(u,f.offset*d.BYTES_PER_ELEMENT,d.subarray(f.offset,f.offset+f.count)),f.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const h=i.get(c);h&&(n.deleteBuffer(h.buffer),i.delete(c))}function l(c,h){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u===void 0?i.set(c,s(c,h)):u.version<c.version&&(r(u.buffer,c,h),u.version=c.version)}return{get:o,remove:a,update:l}}class Cu extends ae{constructor(t=1,e=1,i=1,s=1){super();this.type="PlaneGeometry",this.parameters={width:t,height:e,widthSegments:i,heightSegments:s};const r=t/2,o=e/2,a=Math.floor(i),l=Math.floor(s),c=a+1,h=l+1,u=t/a,d=e/l,f=[],p=[],x=[],_=[];for(let m=0;m<h;m++){const g=m*d-o;for(let S=0;S<c;S++){const v=S*u-r;p.push(v,-g,0),x.push(0,0,1),_.push(S/a),_.push(1-m/l)}}for(let m=0;m<l;m++)for(let g=0;g<a;g++){const S=g+c*m,v=g+c*(m+1),E=g+1+c*(m+1),R=g+1+c*m;f.push(S,v,R),f.push(v,E,R)}this.setIndex(f),this.setAttribute("position",new we(p,3)),this.setAttribute("normal",new we(x,3)),this.setAttribute("uv",new we(_,2))}static fromJSON(t){return new Cu(t.width,t.height,t.widthSegments,t.heightSegments)}}var tA=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,eA=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,nA=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,iA=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,sA=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,rA=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,oA="vec3 transformed = vec3( position );",aA=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,lA=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,cA=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,hA=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,uA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,dA=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,fA=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,pA=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,mA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,gA=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,xA=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,_A=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,yA=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		return texture2D( envMap, uv ).rgb;
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,vA=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,bA=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,MA=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,wA=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,SA=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,EA="gl_FragColor = linearToOutputTexel( gl_FragColor );",TA=`vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,AA=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,CA=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,LA=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,RA=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,PA=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,DA=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,IA=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,FA=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,OA=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,kA=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,NA=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,zA=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,BA=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,HA=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,UA=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,VA=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,WA=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,GA=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,jA=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,qA=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,XA=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,$A=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,YA=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,ZA=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,JA=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,KA=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,QA=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,tC=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,eC=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,nC=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,iC=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,sC=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,rC=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,oC=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,aC=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,lC=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,cC=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,hC=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,uC=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,dC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,fC=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,pC=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,mC=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,gC=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,xC=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,_C=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,yC=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,vC=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,bC=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,MC=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,wC=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,SC=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,EC=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,TC=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,AC=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,CC=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,LC=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,RC=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,PC=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,DC=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,IC=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,FC=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,OC=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,kC=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,NC=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,zC=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,BC=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,HC=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,UC=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,VC=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,WC=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,GC=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,jC=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,qC=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,XC=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const $C=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,YC=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,ZC=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,JC=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,KC=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,QC=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,tL=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,eL=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,nL=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,iL=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,sL=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,rL=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,oL=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,aL=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,lL=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,cL=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hL=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,uL=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dL=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fL=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,pL=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,mL=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gL=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,xL=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_L=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,yL=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vL=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,bL=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,ML=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,wL=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,SL=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,EL=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,zt={alphamap_fragment:tA,alphamap_pars_fragment:eA,alphatest_fragment:nA,alphatest_pars_fragment:iA,aomap_fragment:sA,aomap_pars_fragment:rA,begin_vertex:oA,beginnormal_vertex:aA,bsdfs:lA,bumpmap_pars_fragment:cA,clipping_planes_fragment:hA,clipping_planes_pars_fragment:uA,clipping_planes_pars_vertex:dA,clipping_planes_vertex:fA,color_fragment:pA,color_pars_fragment:mA,color_pars_vertex:gA,color_vertex:xA,common:_A,cube_uv_reflection_fragment:yA,defaultnormal_vertex:vA,displacementmap_pars_vertex:bA,displacementmap_vertex:MA,emissivemap_fragment:wA,emissivemap_pars_fragment:SA,encodings_fragment:EA,encodings_pars_fragment:TA,envmap_fragment:AA,envmap_common_pars_fragment:CA,envmap_pars_fragment:LA,envmap_pars_vertex:RA,envmap_physical_pars_fragment:UA,envmap_vertex:PA,fog_vertex:DA,fog_pars_vertex:IA,fog_fragment:FA,fog_pars_fragment:OA,gradientmap_pars_fragment:kA,lightmap_fragment:NA,lightmap_pars_fragment:zA,lights_lambert_vertex:BA,lights_pars_begin:HA,lights_toon_fragment:VA,lights_toon_pars_fragment:WA,lights_phong_fragment:GA,lights_phong_pars_fragment:jA,lights_physical_fragment:qA,lights_physical_pars_fragment:XA,lights_fragment_begin:$A,lights_fragment_maps:YA,lights_fragment_end:ZA,logdepthbuf_fragment:JA,logdepthbuf_pars_fragment:KA,logdepthbuf_pars_vertex:QA,logdepthbuf_vertex:tC,map_fragment:eC,map_pars_fragment:nC,map_particle_fragment:iC,map_particle_pars_fragment:sC,metalnessmap_fragment:rC,metalnessmap_pars_fragment:oC,morphnormal_vertex:aC,morphtarget_pars_vertex:lC,morphtarget_vertex:cC,normal_fragment_begin:hC,normal_fragment_maps:uC,normal_pars_fragment:dC,normal_pars_vertex:fC,normal_vertex:pC,normalmap_pars_fragment:mC,clearcoat_normal_fragment_begin:gC,clearcoat_normal_fragment_maps:xC,clearcoat_pars_fragment:_C,output_fragment:yC,packing:vC,premultiplied_alpha_fragment:bC,project_vertex:MC,dithering_fragment:wC,dithering_pars_fragment:SC,roughnessmap_fragment:EC,roughnessmap_pars_fragment:TC,shadowmap_pars_fragment:AC,shadowmap_pars_vertex:CC,shadowmap_vertex:LC,shadowmask_pars_fragment:RC,skinbase_vertex:PC,skinning_pars_vertex:DC,skinning_vertex:IC,skinnormal_vertex:FC,specularmap_fragment:OC,specularmap_pars_fragment:kC,tonemapping_fragment:NC,tonemapping_pars_fragment:zC,transmission_fragment:BC,transmission_pars_fragment:HC,uv_pars_fragment:UC,uv_pars_vertex:VC,uv_vertex:WC,uv2_pars_fragment:GC,uv2_pars_vertex:jC,uv2_vertex:qC,worldpos_vertex:XC,background_vert:$C,background_frag:YC,cube_vert:ZC,cube_frag:JC,depth_vert:KC,depth_frag:QC,distanceRGBA_vert:tL,distanceRGBA_frag:eL,equirect_vert:nL,equirect_frag:iL,linedashed_vert:sL,linedashed_frag:rL,meshbasic_vert:oL,meshbasic_frag:aL,meshlambert_vert:lL,meshlambert_frag:cL,meshmatcap_vert:hL,meshmatcap_frag:uL,meshnormal_vert:dL,meshnormal_frag:fL,meshphong_vert:pL,meshphong_frag:mL,meshphysical_vert:gL,meshphysical_frag:xL,meshtoon_vert:_L,meshtoon_frag:yL,points_vert:vL,points_frag:bL,shadow_vert:ML,shadow_frag:wL,sprite_vert:SL,sprite_frag:EL},Mt={common:{diffuse:{value:new Et(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new ye},uv2Transform:{value:new ye},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new mt(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Et(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Et(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ye}},sprite:{diffuse:{value:new Et(16777215)},opacity:{value:1},center:{value:new mt(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new ye}}},On={basic:{uniforms:Fe([Mt.common,Mt.specularmap,Mt.envmap,Mt.aomap,Mt.lightmap,Mt.fog]),vertexShader:zt.meshbasic_vert,fragmentShader:zt.meshbasic_frag},lambert:{uniforms:Fe([Mt.common,Mt.specularmap,Mt.envmap,Mt.aomap,Mt.lightmap,Mt.emissivemap,Mt.fog,Mt.lights,{emissive:{value:new Et(0)}}]),vertexShader:zt.meshlambert_vert,fragmentShader:zt.meshlambert_frag},phong:{uniforms:Fe([Mt.common,Mt.specularmap,Mt.envmap,Mt.aomap,Mt.lightmap,Mt.emissivemap,Mt.bumpmap,Mt.normalmap,Mt.displacementmap,Mt.fog,Mt.lights,{emissive:{value:new Et(0)},specular:{value:new Et(1118481)},shininess:{value:30}}]),vertexShader:zt.meshphong_vert,fragmentShader:zt.meshphong_frag},standard:{uniforms:Fe([Mt.common,Mt.envmap,Mt.aomap,Mt.lightmap,Mt.emissivemap,Mt.bumpmap,Mt.normalmap,Mt.displacementmap,Mt.roughnessmap,Mt.metalnessmap,Mt.fog,Mt.lights,{emissive:{value:new Et(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:zt.meshphysical_vert,fragmentShader:zt.meshphysical_frag},toon:{uniforms:Fe([Mt.common,Mt.aomap,Mt.lightmap,Mt.emissivemap,Mt.bumpmap,Mt.normalmap,Mt.displacementmap,Mt.gradientmap,Mt.fog,Mt.lights,{emissive:{value:new Et(0)}}]),vertexShader:zt.meshtoon_vert,fragmentShader:zt.meshtoon_frag},matcap:{uniforms:Fe([Mt.common,Mt.bumpmap,Mt.normalmap,Mt.displacementmap,Mt.fog,{matcap:{value:null}}]),vertexShader:zt.meshmatcap_vert,fragmentShader:zt.meshmatcap_frag},points:{uniforms:Fe([Mt.points,Mt.fog]),vertexShader:zt.points_vert,fragmentShader:zt.points_frag},dashed:{uniforms:Fe([Mt.common,Mt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:zt.linedashed_vert,fragmentShader:zt.linedashed_frag},depth:{uniforms:Fe([Mt.common,Mt.displacementmap]),vertexShader:zt.depth_vert,fragmentShader:zt.depth_frag},normal:{uniforms:Fe([Mt.common,Mt.bumpmap,Mt.normalmap,Mt.displacementmap,{opacity:{value:1}}]),vertexShader:zt.meshnormal_vert,fragmentShader:zt.meshnormal_frag},sprite:{uniforms:Fe([Mt.sprite,Mt.fog]),vertexShader:zt.sprite_vert,fragmentShader:zt.sprite_frag},background:{uniforms:{uvTransform:{value:new ye},t2D:{value:null}},vertexShader:zt.background_vert,fragmentShader:zt.background_frag},cube:{uniforms:Fe([Mt.envmap,{opacity:{value:1}}]),vertexShader:zt.cube_vert,fragmentShader:zt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:zt.equirect_vert,fragmentShader:zt.equirect_frag},distanceRGBA:{uniforms:Fe([Mt.common,Mt.displacementmap,{referencePosition:{value:new I},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:zt.distanceRGBA_vert,fragmentShader:zt.distanceRGBA_frag},shadow:{uniforms:Fe([Mt.lights,Mt.fog,{color:{value:new Et(0)},opacity:{value:1}}]),vertexShader:zt.shadow_vert,fragmentShader:zt.shadow_frag}};On.physical={uniforms:Fe([On.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new mt(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Et(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new mt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Et(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Et(1,1,1)},specularColorMap:{value:null}}]),vertexShader:zt.meshphysical_vert,fragmentShader:zt.meshphysical_frag};function TL(n,t,e,i,s){const r=new Et(0);let o=0,a,l,c=null,h=0,u=null;function d(p,x){let _=!1,m=x.isScene===!0?x.background:null;m&&m.isTexture&&(m=t.get(m));const g=n.xr,S=g.getSession&&g.getSession();S&&S.environmentBlendMode==="additive"&&(m=null),m===null?f(r,o):m&&m.isColor&&(f(m,1),_=!0),(n.autoClear||_)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),m&&(m.isCubeTexture||m.mapping===il)?(l===void 0&&(l=new He(new Eo(1,1,1),new hs({name:"BackgroundCubeMaterial",uniforms:ar(On.cube.uniforms),vertexShader:On.cube.vertexShader,fragmentShader:On.cube.fragmentShader,side:xe,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(v,E,R){this.matrixWorld.copyPosition(R.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),l.material.uniforms.envMap.value=m,l.material.uniforms.flipEnvMap.value=m.isCubeTexture&&m.isRenderTargetTexture===!1?-1:1,(c!==m||h!==m.version||u!==n.toneMapping)&&(l.material.needsUpdate=!0,c=m,h=m.version,u=n.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):m&&m.isTexture&&(a===void 0&&(a=new He(new Cu(2,2),new hs({name:"BackgroundMaterial",uniforms:ar(On.background.uniforms),vertexShader:On.background.vertexShader,fragmentShader:On.background.fragmentShader,side:mo,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=m,m.matrixAutoUpdate===!0&&m.updateMatrix(),a.material.uniforms.uvTransform.value.copy(m.matrix),(c!==m||h!==m.version||u!==n.toneMapping)&&(a.material.needsUpdate=!0,c=m,h=m.version,u=n.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function f(p,x){e.buffers.color.setClear(p.r,p.g,p.b,x,s)}return{getClearColor:function(){return r},setClearColor:function(p,x=1){r.set(p),o=x,f(r,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,f(r,o)},render:d}}function AL(n,t,e,i){const s=n.getParameter(34921),r=i.isWebGL2?null:t.get("OES_vertex_array_object"),o=i.isWebGL2||r!==null,a={},l=x(null);let c=l;function h(A,W,V,k,U){let ct=!1;if(o){const xt=p(k,V,W);c!==xt&&(c=xt,d(c.object)),ct=_(k,U),ct&&m(k,U)}else{const xt=W.wireframe===!0;(c.geometry!==k.id||c.program!==V.id||c.wireframe!==xt)&&(c.geometry=k.id,c.program=V.id,c.wireframe=xt,ct=!0)}A.isInstancedMesh===!0&&(ct=!0),U!==null&&e.update(U,34963),ct&&(D(A,W,V,k),U!==null&&n.bindBuffer(34963,e.get(U).buffer))}function u(){return i.isWebGL2?n.createVertexArray():r.createVertexArrayOES()}function d(A){return i.isWebGL2?n.bindVertexArray(A):r.bindVertexArrayOES(A)}function f(A){return i.isWebGL2?n.deleteVertexArray(A):r.deleteVertexArrayOES(A)}function p(A,W,V){const k=V.wireframe===!0;let U=a[A.id];U===void 0&&(U={},a[A.id]=U);let ct=U[W.id];ct===void 0&&(ct={},U[W.id]=ct);let xt=ct[k];return xt===void 0&&(xt=x(u()),ct[k]=xt),xt}function x(A){const W=[],V=[],k=[];for(let U=0;U<s;U++)W[U]=0,V[U]=0,k[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:W,enabledAttributes:V,attributeDivisors:k,object:A,attributes:{},index:null}}function _(A,W){const V=c.attributes,k=A.attributes;let U=0;for(const ct in k){const xt=V[ct],et=k[ct];if(xt===void 0||xt.attribute!==et||xt.data!==et.data)return!0;U++}return c.attributesNum!==U||c.index!==W}function m(A,W){const V={},k=A.attributes;let U=0;for(const ct in k){const xt=k[ct],et={};et.attribute=xt,xt.data&&(et.data=xt.data),V[ct]=et,U++}c.attributes=V,c.attributesNum=U,c.index=W}function g(){const A=c.newAttributes;for(let W=0,V=A.length;W<V;W++)A[W]=0}function S(A){v(A,0)}function v(A,W){const V=c.newAttributes,k=c.enabledAttributes,U=c.attributeDivisors;V[A]=1,k[A]===0&&(n.enableVertexAttribArray(A),k[A]=1),U[A]!==W&&((i.isWebGL2?n:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](A,W),U[A]=W)}function E(){const A=c.newAttributes,W=c.enabledAttributes;for(let V=0,k=W.length;V<k;V++)W[V]!==A[V]&&(n.disableVertexAttribArray(V),W[V]=0)}function R(A,W,V,k,U,ct){i.isWebGL2===!0&&(V===5124||V===5125)?n.vertexAttribIPointer(A,W,V,U,ct):n.vertexAttribPointer(A,W,V,k,U,ct)}function D(A,W,V,k){if(i.isWebGL2===!1&&(A.isInstancedMesh||k.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;g();const U=k.attributes,ct=V.getAttributes(),xt=W.defaultAttributeValues;for(const et in ct){const ot=ct[et];if(ot.location>=0){let yt=U[et];if(yt===void 0&&(et==="instanceMatrix"&&A.instanceMatrix&&(yt=A.instanceMatrix),et==="instanceColor"&&A.instanceColor&&(yt=A.instanceColor)),yt!==void 0){const gt=yt.normalized,wt=yt.itemSize,J=e.get(yt);if(J===void 0)continue;const j=J.buffer,ht=J.type,H=J.bytesPerElement;if(yt.isInterleavedBufferAttribute){const rt=yt.data,K=rt.stride,at=yt.offset;if(rt&&rt.isInstancedInterleavedBuffer){for(let z=0;z<ot.locationSize;z++)v(ot.location+z,rt.meshPerAttribute);A.isInstancedMesh!==!0&&k._maxInstanceCount===void 0&&(k._maxInstanceCount=rt.meshPerAttribute*rt.count)}else for(let z=0;z<ot.locationSize;z++)S(ot.location+z);n.bindBuffer(34962,j);for(let z=0;z<ot.locationSize;z++)R(ot.location+z,wt/ot.locationSize,ht,gt,K*H,(at+wt/ot.locationSize*z)*H)}else{if(yt.isInstancedBufferAttribute){for(let rt=0;rt<ot.locationSize;rt++)v(ot.location+rt,yt.meshPerAttribute);A.isInstancedMesh!==!0&&k._maxInstanceCount===void 0&&(k._maxInstanceCount=yt.meshPerAttribute*yt.count)}else for(let rt=0;rt<ot.locationSize;rt++)S(ot.location+rt);n.bindBuffer(34962,j);for(let rt=0;rt<ot.locationSize;rt++)R(ot.location+rt,wt/ot.locationSize,ht,gt,wt*H,wt/ot.locationSize*rt*H)}}else if(xt!==void 0){const gt=xt[et];if(gt!==void 0)switch(gt.length){case 2:n.vertexAttrib2fv(ot.location,gt);break;case 3:n.vertexAttrib3fv(ot.location,gt);break;case 4:n.vertexAttrib4fv(ot.location,gt);break;default:n.vertexAttrib1fv(ot.location,gt)}}}}E()}function $(){N();for(const A in a){const W=a[A];for(const V in W){const k=W[V];for(const U in k)f(k[U].object),delete k[U];delete W[V]}delete a[A]}}function it(A){if(a[A.id]===void 0)return;const W=a[A.id];for(const V in W){const k=W[V];for(const U in k)f(k[U].object),delete k[U];delete W[V]}delete a[A.id]}function tt(A){for(const W in a){const V=a[W];if(V[A.id]===void 0)continue;const k=V[A.id];for(const U in k)f(k[U].object),delete k[U];delete V[A.id]}}function N(){T(),c!==l&&(c=l,d(c.object))}function T(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:N,resetDefaultState:T,dispose:$,releaseStatesOfGeometry:it,releaseStatesOfProgram:tt,initAttributes:g,enableAttribute:S,disableUnusedAttributes:E}}function CL(n,t,e,i){const s=i.isWebGL2;let r;function o(c){r=c}function a(c,h){n.drawArrays(r,c,h),e.update(h,r,1)}function l(c,h,u){if(u===0)return;let d,f;if(s)d=n,f="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),f="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[f](r,c,h,u),e.update(h,r,u)}this.setMode=o,this.render=a,this.renderInstances=l}function LL(n,t,e){let i;function s(){if(i!==void 0)return i;if(t.has("EXT_texture_filter_anisotropic")===!0){const D=t.get("EXT_texture_filter_anisotropic");i=n.getParameter(D.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function r(D){if(D==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";D="mediump"}return D==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=e.precision!==void 0?e.precision:"highp";const l=r(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||t.has("WEBGL_draw_buffers"),h=e.logarithmicDepthBuffer===!0,u=n.getParameter(34930),d=n.getParameter(35660),f=n.getParameter(3379),p=n.getParameter(34076),x=n.getParameter(34921),_=n.getParameter(36347),m=n.getParameter(36348),g=n.getParameter(36349),S=d>0,v=o||t.has("OES_texture_float"),E=S&&v,R=o?n.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:s,getMaxPrecision:r,precision:a,logarithmicDepthBuffer:h,maxTextures:u,maxVertexTextures:d,maxTextureSize:f,maxCubemapSize:p,maxAttributes:x,maxVertexUniforms:_,maxVaryings:m,maxFragmentUniforms:g,vertexTextures:S,floatFragmentTextures:v,floatVertexTextures:E,maxSamples:R}}function RL(n){const t=this;let e=null,i=0,s=!1,r=!1;const o=new ti,a=new ye,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,f){const p=u.length!==0||d||i!==0||s;return s=d,e=h(u,f,0),i=u.length,p},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1,c()},this.setState=function(u,d,f){const p=u.clippingPlanes,x=u.clipIntersection,_=u.clipShadows,m=n.get(u);if(!s||p===null||p.length===0||r&&!_)r?h(null):c();else{const g=r?0:i,S=g*4;let v=m.clippingState||null;l.value=v,v=h(p,d,S,f);for(let E=0;E!==S;++E)v[E]=e[E];m.clippingState=v,this.numIntersection=x?this.numPlanes:0,this.numPlanes+=g}};function c(){l.value!==e&&(l.value=e,l.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function h(u,d,f,p){const x=u!==null?u.length:0;let _=null;if(x!==0){if(_=l.value,p!==!0||_===null){const m=f+x*4,g=d.matrixWorldInverse;a.getNormalMatrix(g),(_===null||_.length<m)&&(_=new Float32Array(m));for(let S=0,v=f;S!==x;++S,v+=4)o.copy(u[S]).applyMatrix4(g,a),o.normal.toArray(_,v),_[v+3]=o.constant}l.value=_,l.needsUpdate=!0}return t.numPlanes=x,t.numIntersection=0,_}}function PL(n){let t=new WeakMap;function e(o,a){return a===Xh?o.mapping=xo:a===$h&&(o.mapping=_o),o}function i(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Xh||a===$h)if(t.has(o)){const l=t.get(o).texture;return e(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderTarget(),h=new ux(l.height/2);return h.fromEquirectangularTexture(n,o),t.set(o,h),n.setRenderTarget(c),o.addEventListener("dispose",s),e(h.texture,o.mapping)}else return null}}return o}function s(o){const a=o.target;a.removeEventListener("dispose",s);const l=t.get(a);l!==void 0&&(t.delete(a),l.dispose())}function r(){t=new WeakMap}return{get:i,dispose:r}}class Lu extends Ll{constructor(t=-1,e=1,i=1,s=-1,r=.1,o=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=t,this.right=e,this.top=i,this.bottom=s,this.near=r,this.far=o,this.updateProjectionMatrix()}copy(t,e){return super.copy(t,e),this.left=t.left,this.right=t.right,this.top=t.top,this.bottom=t.bottom,this.near=t.near,this.far=t.far,this.zoom=t.zoom,this.view=t.view===null?null:Object.assign({},t.view),this}setViewOffset(t,e,i,s,r,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=t,this.view.fullHeight=e,this.view.offsetX=i,this.view.offsetY=s,this.view.width=r,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const t=(this.right-this.left)/(2*this.zoom),e=(this.top-this.bottom)/(2*this.zoom),i=(this.right+this.left)/2,s=(this.top+this.bottom)/2;let r=i-t,o=i+t,a=s+e,l=s-e;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,o=r+c*this.view.width,a-=h*this.view.offsetY,l=a-h*this.view.height}this.projectionMatrix.makeOrthographic(r,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(t){const e=super.toJSON(t);return e.object.zoom=this.zoom,e.object.left=this.left,e.object.right=this.right,e.object.top=this.top,e.object.bottom=this.bottom,e.object.near=this.near,e.object.far=this.far,this.view!==null&&(e.object.view=Object.assign({},this.view)),e}}Lu.prototype.isOrthographicCamera=!0;class Dl extends hs{constructor(t){super(t);this.type="RawShaderMaterial"}}Dl.prototype.isRawShaderMaterial=!0;const ur=4,Ti=8,kn=Math.pow(2,Ti),fx=[.125,.215,.35,.446,.526,.582],px=Ti-ur+1+fx.length,dr=20,Il={[xn]:0,[js]:1},Ru=new Lu,{_lodPlanes:Ao,_sizeLods:mx,_sigmas:Fl}=IL(),gx=new Et;let Pu=null;const us=(1+Math.sqrt(5))/2,fr=1/us,xx=[new I(1,1,1),new I(-1,1,1),new I(1,1,-1),new I(-1,1,-1),new I(0,us,fr),new I(0,us,-fr),new I(fr,0,us),new I(-fr,0,us),new I(us,fr,0),new I(-us,fr,0)];class DL{constructor(t){this._renderer=t,this._pingPongRenderTarget=null,this._blurMaterial=FL(dr),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(t,e=0,i=.1,s=100){Pu=this._renderer.getRenderTarget();const r=this._allocateTargets();return this._sceneToCubeUV(t,i,s,r),e>0&&this._blur(r,0,0,e),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(t){return this._fromTexture(t)}fromCubemap(t){return this._fromTexture(t)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=vx(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=yx(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let t=0;t<Ao.length;t++)Ao[t].dispose()}_cleanup(t){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Pu),t.scissorTest=!1,Ol(t,0,0,t.width,t.height)}_fromTexture(t){Pu=this._renderer.getRenderTarget();const e=this._allocateTargets(t);return this._textureToCubeUV(t,e),this._applyPMREM(e),this._cleanup(e),e}_allocateTargets(t){const e={magFilter:Be,minFilter:Be,generateMipmaps:!1,type:ss,format:be,encoding:xn,depthBuffer:!1},i=_x(e);return i.depthBuffer=!t,this._pingPongRenderTarget=_x(e),i}_compileMaterial(t){const e=new He(Ao[0],t);this._renderer.compile(e,Ru)}_sceneToCubeUV(t,e,i,s){const r=90,o=1,a=new je(r,o,e,i),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,u=h.autoClear,d=h.toneMapping;h.getClearColor(gx),h.toneMapping=xi,h.autoClear=!1;const f=new yl({name:"PMREM.Background",side:xe,depthWrite:!1,depthTest:!1}),p=new He(new Eo,f);let x=!1;const _=t.background;_?_.isColor&&(f.color.copy(_),t.background=null,x=!0):(f.color.copy(gx),x=!0);for(let m=0;m<6;m++){const g=m%3;g==0?(a.up.set(0,l[m],0),a.lookAt(c[m],0,0)):g==1?(a.up.set(0,0,l[m]),a.lookAt(0,c[m],0)):(a.up.set(0,l[m],0),a.lookAt(0,0,c[m])),Ol(s,g*kn,m>2?kn:0,kn,kn),h.setRenderTarget(s),x&&h.render(p,a),h.render(t,a)}p.geometry.dispose(),p.material.dispose(),h.toneMapping=d,h.autoClear=u,t.background=_}_setEncoding(t,e){this._renderer.capabilities.isWebGL2===!0&&e.format===be&&e.type===$n&&e.encoding===js?t.value=Il[xn]:t.value=Il[e.encoding]}_textureToCubeUV(t,e){const i=this._renderer,s=t.mapping===xo||t.mapping===_o;s?this._cubemapShader==null&&(this._cubemapShader=vx()):this._equirectShader==null&&(this._equirectShader=yx());const r=s?this._cubemapShader:this._equirectShader,o=new He(Ao[0],r),a=r.uniforms;a.envMap.value=t,s||a.texelSize.value.set(1/t.image.width,1/t.image.height),this._setEncoding(a.inputEncoding,t),Ol(e,0,0,3*kn,2*kn),i.setRenderTarget(e),i.render(o,Ru)}_applyPMREM(t){const e=this._renderer,i=e.autoClear;e.autoClear=!1;for(let s=1;s<px;s++){const r=Math.sqrt(Fl[s]*Fl[s]-Fl[s-1]*Fl[s-1]),o=xx[(s-1)%xx.length];this._blur(t,s-1,s,r,o)}e.autoClear=i}_blur(t,e,i,s,r){const o=this._pingPongRenderTarget;this._halfBlur(t,o,e,i,s,"latitudinal",r),this._halfBlur(o,t,i,i,s,"longitudinal",r)}_halfBlur(t,e,i,s,r,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,u=new He(Ao[s],c),d=c.uniforms,f=mx[i]-1,p=isFinite(r)?Math.PI/(2*f):2*Math.PI/(2*dr-1),x=r/p,_=isFinite(r)?1+Math.floor(h*x):dr;_>dr&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${dr}`);const m=[];let g=0;for(let R=0;R<dr;++R){const D=R/x,$=Math.exp(-D*D/2);m.push($),R==0?g+=$:R<_&&(g+=2*$)}for(let R=0;R<m.length;R++)m[R]=m[R]/g;d.envMap.value=t.texture,d.samples.value=_,d.weights.value=m,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a),d.dTheta.value=p,d.mipInt.value=Ti-i;const S=mx[s],v=3*Math.max(0,kn-2*S),E=(s===0?0:2*kn)+2*S*(s>Ti-ur?s-Ti+ur:0);Ol(e,v,E,3*S,2*S),l.setRenderTarget(e),l.render(u,Ru)}}function IL(){const n=[],t=[],e=[];let i=Ti;for(let s=0;s<px;s++){const r=Math.pow(2,i);t.push(r);let o=1/r;s>Ti-ur?o=fx[s-Ti+ur-1]:s==0&&(o=0),e.push(o);const a=1/(r-1),l=-a/2,c=1+a/2,h=[l,l,c,l,c,c,l,l,c,c,l,c],u=6,d=6,f=3,p=2,x=1,_=new Float32Array(f*d*u),m=new Float32Array(p*d*u),g=new Float32Array(x*d*u);for(let v=0;v<u;v++){const E=v%3*2/3-1,R=v>2?0:-1,D=[E,R,0,E+2/3,R,0,E+2/3,R+1,0,E,R,0,E+2/3,R+1,0,E,R+1,0];_.set(D,f*d*v),m.set(h,p*d*v);const $=[v,v,v,v,v,v];g.set($,x*d*v)}const S=new ae;S.setAttribute("position",new ve(_,f)),S.setAttribute("uv",new ve(m,p)),S.setAttribute("faceIndex",new ve(g,x)),n.push(S),i>ur&&i--}return{_lodPlanes:n,_sizeLods:t,_sigmas:e}}function _x(n){const t=new an(3*kn,3*kn,n);return t.texture.mapping=il,t.texture.name="PMREM.cubeUv",t.scissorTest=!0,t}function Ol(n,t,e,i,s){n.viewport.set(t,e,i,s),n.scissor.set(t,e,i,s)}function FL(n){const t=new Float32Array(n),e=new I(0,1,0);return new Dl({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:t},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:e}},vertexShader:Du(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Iu()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:gi,depthTest:!1,depthWrite:!1})}function yx(){const n=new mt(1,1);return new Dl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:Il[xn]}},vertexShader:Du(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Iu()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

			}
		`,blending:gi,depthTest:!1,depthWrite:!1})}function vx(){return new Dl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Il[xn]}},vertexShader:Du(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Iu()}

			void main() {

				gl_FragColor = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) );

			}
		`,blending:gi,depthTest:!1,depthWrite:!1})}function Du(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Iu(){return`

		uniform int inputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else {

				return sRGBToLinear( value );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function OL(n){let t=new WeakMap,e=null;function i(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const l=a.mapping,c=l===Xh||l===$h,h=l===xo||l===_o;if(c||h){if(t.has(a))return t.get(a).texture;{const u=a.image;if(c&&u&&u.height>0||h&&u&&s(u)){const d=n.getRenderTarget();e===null&&(e=new DL(n));const f=c?e.fromEquirectangular(a):e.fromCubemap(a);return t.set(a,f),n.setRenderTarget(d),a.addEventListener("dispose",r),f.texture}else return null}}}return a}function s(a){let l=0;const c=6;for(let h=0;h<c;h++)a[h]!==void 0&&l++;return l===c}function r(a){const l=a.target;l.removeEventListener("dispose",r);const c=t.get(l);c!==void 0&&(t.delete(l),c.dispose())}function o(){t=new WeakMap,e!==null&&(e.dispose(),e=null)}return{get:i,dispose:o}}function kL(n){const t={};function e(i){if(t[i]!==void 0)return t[i];let s;switch(i){case"WEBGL_depth_texture":s=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":s=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":s=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:s=n.getExtension(i)}return t[i]=s,s}return{has:function(i){return e(i)!==null},init:function(i){i.isWebGL2?e("EXT_color_buffer_float"):(e("WEBGL_depth_texture"),e("OES_texture_float"),e("OES_texture_half_float"),e("OES_texture_half_float_linear"),e("OES_standard_derivatives"),e("OES_element_index_uint"),e("OES_vertex_array_object"),e("ANGLE_instanced_arrays")),e("OES_texture_float_linear"),e("EXT_color_buffer_half_float"),e("WEBGL_multisampled_render_to_texture")},get:function(i){const s=e(i);return s===null&&console.warn("THREE.WebGLRenderer: "+i+" extension not supported."),s}}}function NL(n,t,e,i){const s={},r=new WeakMap;function o(u){const d=u.target;d.index!==null&&t.remove(d.index);for(const p in d.attributes)t.remove(d.attributes[p]);d.removeEventListener("dispose",o),delete s[d.id];const f=r.get(d);f&&(t.remove(f),r.delete(d)),i.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,e.memory.geometries--}function a(u,d){return s[d.id]===!0||(d.addEventListener("dispose",o),s[d.id]=!0,e.memory.geometries++),d}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],34962);const f=u.morphAttributes;for(const p in f){const x=f[p];for(let _=0,m=x.length;_<m;_++)t.update(x[_],34962)}}function c(u){const d=[],f=u.index,p=u.attributes.position;let x=0;if(f!==null){const g=f.array;x=f.version;for(let S=0,v=g.length;S<v;S+=3){const E=g[S+0],R=g[S+1],D=g[S+2];d.push(E,R,R,D,D,E)}}else{const g=p.array;x=p.version;for(let S=0,v=g.length/3-1;S<v;S+=3){const E=S+0,R=S+1,D=S+2;d.push(E,R,R,D,D,E)}}const _=new(Yg(d)>65535?cx:lx)(d,1);_.version=x;const m=r.get(u);m&&t.remove(m),r.set(u,_)}function h(u){const d=r.get(u);if(d){const f=u.index;f!==null&&d.version<f.version&&c(u)}else c(u);return r.get(u)}return{get:a,update:l,getWireframeAttribute:h}}function zL(n,t,e,i){const s=i.isWebGL2;let r;function o(d){r=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function h(d,f){n.drawElements(r,f,a,d*l),e.update(f,r,1)}function u(d,f,p){if(p===0)return;let x,_;if(s)x=n,_="drawElementsInstanced";else if(x=t.get("ANGLE_instanced_arrays"),_="drawElementsInstancedANGLE",x===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}x[_](r,f,a,d*l,p),e.update(f,r,p)}this.setMode=o,this.setIndex=c,this.render=h,this.renderInstances=u}function BL(n){const t={geometries:0,textures:0},e={frame:0,calls:0,triangles:0,points:0,lines:0};function i(r,o,a){switch(e.calls++,o){case 4:e.triangles+=a*(r/3);break;case 1:e.lines+=a*(r/2);break;case 3:e.lines+=a*(r-1);break;case 2:e.lines+=a*r;break;case 0:e.points+=a*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function s(){e.frame++,e.calls=0,e.triangles=0,e.points=0,e.lines=0}return{memory:t,render:e,programs:null,autoReset:!0,reset:s,update:i}}class Fu extends Me{constructor(t=null,e=1,i=1,s=1){super(null);this.image={data:t,width:e,height:i,depth:s},this.magFilter=_e,this.minFilter=_e,this.wrapR=Ze,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Fu.prototype.isDataTexture2DArray=!0;function HL(n,t){return n[0]-t[0]}function UL(n,t){return Math.abs(t[1])-Math.abs(n[1])}function bx(n,t){let e=1;const i=t.isInterleavedBufferAttribute?t.data.array:t.array;i instanceof Int8Array?e=127:i instanceof Int16Array?e=32767:i instanceof Int32Array?e=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",i),n.divideScalar(e)}function VL(n,t,e){const i={},s=new Float32Array(8),r=new WeakMap,o=new I,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,h,u,d){const f=c.morphTargetInfluences;if(t.isWebGL2===!0){const p=h.morphAttributes.position.length;let x=r.get(h);if(x===void 0||x.count!==p){x!==void 0&&x.texture.dispose();const g=h.morphAttributes.normal!==void 0,S=h.morphAttributes.position,v=h.morphAttributes.normal||[],E=h.attributes.position.count,R=g===!0?2:1;let D=E*R,$=1;D>t.maxTextureSize&&($=Math.ceil(D/t.maxTextureSize),D=t.maxTextureSize);const it=new Float32Array(D*$*4*p),tt=new Fu(it,D,$,p);tt.format=be,tt.type=_i,tt.needsUpdate=!0;const N=R*4;for(let T=0;T<p;T++){const A=S[T],W=v[T],V=D*$*4*T;for(let k=0;k<A.count;k++){o.fromBufferAttribute(A,k),A.normalized===!0&&bx(o,A);const U=k*N;it[V+U+0]=o.x,it[V+U+1]=o.y,it[V+U+2]=o.z,it[V+U+3]=0,g===!0&&(o.fromBufferAttribute(W,k),W.normalized===!0&&bx(o,W),it[V+U+4]=o.x,it[V+U+5]=o.y,it[V+U+6]=o.z,it[V+U+7]=0)}}x={count:p,texture:tt,size:new mt(D,$)},r.set(h,x)}let _=0;for(let g=0;g<f.length;g++)_+=f[g];const m=h.morphTargetsRelative?1:1-_;d.getUniforms().setValue(n,"morphTargetBaseInfluence",m),d.getUniforms().setValue(n,"morphTargetInfluences",f),d.getUniforms().setValue(n,"morphTargetsTexture",x.texture,e),d.getUniforms().setValue(n,"morphTargetsTextureSize",x.size)}else{const p=f===void 0?0:f.length;let x=i[h.id];if(x===void 0||x.length!==p){x=[];for(let v=0;v<p;v++)x[v]=[v,0];i[h.id]=x}for(let v=0;v<p;v++){const E=x[v];E[0]=v,E[1]=f[v]}x.sort(UL);for(let v=0;v<8;v++)v<p&&x[v][1]?(a[v][0]=x[v][0],a[v][1]=x[v][1]):(a[v][0]=Number.MAX_SAFE_INTEGER,a[v][1]=0);a.sort(HL);const _=h.morphAttributes.position,m=h.morphAttributes.normal;let g=0;for(let v=0;v<8;v++){const E=a[v],R=E[0],D=E[1];R!==Number.MAX_SAFE_INTEGER&&D?(_&&h.getAttribute("morphTarget"+v)!==_[R]&&h.setAttribute("morphTarget"+v,_[R]),m&&h.getAttribute("morphNormal"+v)!==m[R]&&h.setAttribute("morphNormal"+v,m[R]),s[v]=D,g+=D):(_&&h.hasAttribute("morphTarget"+v)===!0&&h.deleteAttribute("morphTarget"+v),m&&h.hasAttribute("morphNormal"+v)===!0&&h.deleteAttribute("morphNormal"+v),s[v]=0)}const S=h.morphTargetsRelative?1:1-g;d.getUniforms().setValue(n,"morphTargetBaseInfluence",S),d.getUniforms().setValue(n,"morphTargetInfluences",s)}}return{update:l}}function WL(n,t,e,i){let s=new WeakMap;function r(l){const c=i.render.frame,h=l.geometry,u=t.get(l,h);return s.get(u)!==c&&(t.update(u),s.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),e.update(l.instanceMatrix,34962),l.instanceColor!==null&&e.update(l.instanceColor,34962)),u}function o(){s=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),e.remove(c.instanceMatrix),c.instanceColor!==null&&e.remove(c.instanceColor)}return{update:r,dispose:o}}class Mx extends Me{constructor(t=null,e=1,i=1,s=1){super(null);this.image={data:t,width:e,height:i,depth:s},this.magFilter=_e,this.minFilter=_e,this.wrapR=Ze,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}Mx.prototype.isDataTexture3D=!0;const wx=new Me,Sx=new Fu,Ex=new Mx,Tx=new Rl,Ax=[],Cx=[],Lx=new Float32Array(16),Rx=new Float32Array(9),Px=new Float32Array(4);function pr(n,t,e){const i=n[0];if(i<=0||i>0)return n;const s=t*e;let r=Ax[s];if(r===void 0&&(r=new Float32Array(s),Ax[s]=r),t!==0){i.toArray(r,0);for(let o=1,a=0;o!==t;++o)a+=e,n[o].toArray(r,a)}return r}function Ue(n,t){if(n.length!==t.length)return!1;for(let e=0,i=n.length;e<i;e++)if(n[e]!==t[e])return!1;return!0}function Oe(n,t){for(let e=0,i=t.length;e<i;e++)n[e]=t[e]}function kl(n,t){let e=Cx[t];e===void 0&&(e=new Int32Array(t),Cx[t]=e);for(let i=0;i!==t;++i)e[i]=n.allocateTextureUnit();return e}function GL(n,t){const e=this.cache;e[0]!==t&&(n.uniform1f(this.addr,t),e[0]=t)}function jL(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y)&&(n.uniform2f(this.addr,t.x,t.y),e[0]=t.x,e[1]=t.y);else{if(Ue(e,t))return;n.uniform2fv(this.addr,t),Oe(e,t)}}function qL(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z)&&(n.uniform3f(this.addr,t.x,t.y,t.z),e[0]=t.x,e[1]=t.y,e[2]=t.z);else if(t.r!==void 0)(e[0]!==t.r||e[1]!==t.g||e[2]!==t.b)&&(n.uniform3f(this.addr,t.r,t.g,t.b),e[0]=t.r,e[1]=t.g,e[2]=t.b);else{if(Ue(e,t))return;n.uniform3fv(this.addr,t),Oe(e,t)}}function XL(n,t){const e=this.cache;if(t.x!==void 0)(e[0]!==t.x||e[1]!==t.y||e[2]!==t.z||e[3]!==t.w)&&(n.uniform4f(this.addr,t.x,t.y,t.z,t.w),e[0]=t.x,e[1]=t.y,e[2]=t.z,e[3]=t.w);else{if(Ue(e,t))return;n.uniform4fv(this.addr,t),Oe(e,t)}}function $L(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(Ue(e,t))return;n.uniformMatrix2fv(this.addr,!1,t),Oe(e,t)}else{if(Ue(e,i))return;Px.set(i),n.uniformMatrix2fv(this.addr,!1,Px),Oe(e,i)}}function YL(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(Ue(e,t))return;n.uniformMatrix3fv(this.addr,!1,t),Oe(e,t)}else{if(Ue(e,i))return;Rx.set(i),n.uniformMatrix3fv(this.addr,!1,Rx),Oe(e,i)}}function ZL(n,t){const e=this.cache,i=t.elements;if(i===void 0){if(Ue(e,t))return;n.uniformMatrix4fv(this.addr,!1,t),Oe(e,t)}else{if(Ue(e,i))return;Lx.set(i),n.uniformMatrix4fv(this.addr,!1,Lx),Oe(e,i)}}function JL(n,t){const e=this.cache;e[0]!==t&&(n.uniform1i(this.addr,t),e[0]=t)}function KL(n,t){const e=this.cache;Ue(e,t)||(n.uniform2iv(this.addr,t),Oe(e,t))}function QL(n,t){const e=this.cache;Ue(e,t)||(n.uniform3iv(this.addr,t),Oe(e,t))}function tR(n,t){const e=this.cache;Ue(e,t)||(n.uniform4iv(this.addr,t),Oe(e,t))}function eR(n,t){const e=this.cache;e[0]!==t&&(n.uniform1ui(this.addr,t),e[0]=t)}function nR(n,t){const e=this.cache;Ue(e,t)||(n.uniform2uiv(this.addr,t),Oe(e,t))}function iR(n,t){const e=this.cache;Ue(e,t)||(n.uniform3uiv(this.addr,t),Oe(e,t))}function sR(n,t){const e=this.cache;Ue(e,t)||(n.uniform4uiv(this.addr,t),Oe(e,t))}function rR(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.safeSetTexture2D(t||wx,s)}function oR(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTexture3D(t||Ex,s)}function aR(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.safeSetTextureCube(t||Tx,s)}function lR(n,t,e){const i=this.cache,s=e.allocateTextureUnit();i[0]!==s&&(n.uniform1i(this.addr,s),i[0]=s),e.setTexture2DArray(t||Sx,s)}function cR(n){switch(n){case 5126:return GL;case 35664:return jL;case 35665:return qL;case 35666:return XL;case 35674:return $L;case 35675:return YL;case 35676:return ZL;case 5124:case 35670:return JL;case 35667:case 35671:return KL;case 35668:case 35672:return QL;case 35669:case 35673:return tR;case 5125:return eR;case 36294:return nR;case 36295:return iR;case 36296:return sR;case 35678:case 36198:case 36298:case 36306:case 35682:return rR;case 35679:case 36299:case 36307:return oR;case 35680:case 36300:case 36308:case 36293:return aR;case 36289:case 36303:case 36311:case 36292:return lR}}function hR(n,t){n.uniform1fv(this.addr,t)}function uR(n,t){const e=pr(t,this.size,2);n.uniform2fv(this.addr,e)}function dR(n,t){const e=pr(t,this.size,3);n.uniform3fv(this.addr,e)}function fR(n,t){const e=pr(t,this.size,4);n.uniform4fv(this.addr,e)}function pR(n,t){const e=pr(t,this.size,4);n.uniformMatrix2fv(this.addr,!1,e)}function mR(n,t){const e=pr(t,this.size,9);n.uniformMatrix3fv(this.addr,!1,e)}function gR(n,t){const e=pr(t,this.size,16);n.uniformMatrix4fv(this.addr,!1,e)}function xR(n,t){n.uniform1iv(this.addr,t)}function _R(n,t){n.uniform2iv(this.addr,t)}function yR(n,t){n.uniform3iv(this.addr,t)}function vR(n,t){n.uniform4iv(this.addr,t)}function bR(n,t){n.uniform1uiv(this.addr,t)}function MR(n,t){n.uniform2uiv(this.addr,t)}function wR(n,t){n.uniform3uiv(this.addr,t)}function SR(n,t){n.uniform4uiv(this.addr,t)}function ER(n,t,e){const i=t.length,s=kl(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.safeSetTexture2D(t[r]||wx,s[r])}function TR(n,t,e){const i=t.length,s=kl(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTexture3D(t[r]||Ex,s[r])}function AR(n,t,e){const i=t.length,s=kl(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.safeSetTextureCube(t[r]||Tx,s[r])}function CR(n,t,e){const i=t.length,s=kl(e,i);n.uniform1iv(this.addr,s);for(let r=0;r!==i;++r)e.setTexture2DArray(t[r]||Sx,s[r])}function LR(n){switch(n){case 5126:return hR;case 35664:return uR;case 35665:return dR;case 35666:return fR;case 35674:return pR;case 35675:return mR;case 35676:return gR;case 5124:case 35670:return xR;case 35667:case 35671:return _R;case 35668:case 35672:return yR;case 35669:case 35673:return vR;case 5125:return bR;case 36294:return MR;case 36295:return wR;case 36296:return SR;case 35678:case 36198:case 36298:case 36306:case 35682:return ER;case 35679:case 36299:case 36307:return TR;case 35680:case 36300:case 36308:case 36293:return AR;case 36289:case 36303:case 36311:case 36292:return CR}}function RR(n,t,e){this.id=n,this.addr=e,this.cache=[],this.setValue=cR(t.type)}function Dx(n,t,e){this.id=n,this.addr=e,this.cache=[],this.size=t.size,this.setValue=LR(t.type)}Dx.prototype.updateCache=function(n){const t=this.cache;n instanceof Float32Array&&t.length!==n.length&&(this.cache=new Float32Array(n.length)),Oe(t,n)};function Ix(n){this.id=n,this.seq=[],this.map={}}Ix.prototype.setValue=function(n,t,e){const i=this.seq;for(let s=0,r=i.length;s!==r;++s){const o=i[s];o.setValue(n,t[o.id],e)}};const Ou=/(\w+)(\])?(\[|\.)?/g;function Fx(n,t){n.seq.push(t),n.map[t.id]=t}function PR(n,t,e){const i=n.name,s=i.length;for(Ou.lastIndex=0;;){const r=Ou.exec(i),o=Ou.lastIndex;let a=r[1];const l=r[2]==="]",c=r[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===s){Fx(e,c===void 0?new RR(a,n,t):new Dx(a,n,t));break}else{let u=e.map[a];u===void 0&&(u=new Ix(a),Fx(e,u)),e=u}}}function Ai(n,t){this.seq=[],this.map={};const e=n.getProgramParameter(t,35718);for(let i=0;i<e;++i){const s=n.getActiveUniform(t,i),r=n.getUniformLocation(t,s.name);PR(s,r,this)}}Ai.prototype.setValue=function(n,t,e,i){const s=this.map[t];s!==void 0&&s.setValue(n,e,i)};Ai.prototype.setOptional=function(n,t,e){const i=t[e];i!==void 0&&this.setValue(n,e,i)};Ai.upload=function(n,t,e,i){for(let s=0,r=t.length;s!==r;++s){const o=t[s],a=e[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,i)}};Ai.seqWithValue=function(n,t){const e=[];for(let i=0,s=n.length;i!==s;++i){const r=n[i];r.id in t&&e.push(r)}return e};function Ox(n,t,e){const i=n.createShader(t);return n.shaderSource(i,e),n.compileShader(i),i}let DR=0;function IR(n){const t=n.split(`
`);for(let e=0;e<t.length;e++)t[e]=e+1+": "+t[e];return t.join(`
`)}function kx(n){switch(n){case xn:return["Linear","( value )"];case js:return["sRGB","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function Nx(n,t,e){const i=n.getShaderParameter(t,35713),s=n.getShaderInfoLog(t).trim();return i&&s===""?"":e.toUpperCase()+`

`+s+`

`+IR(n.getShaderSource(t))}function ds(n,t){const e=kx(t);return"vec4 "+n+"( vec4 value ) { return "+e[0]+"ToLinear"+e[1]+"; }"}function FR(n,t){const e=kx(t);return"vec4 "+n+"( vec4 value ) { return LinearTo"+e[0]+e[1]+"; }"}function OR(n,t){let e;switch(t){case CE:e="Linear";break;case LE:e="Reinhard";break;case RE:e="OptimizedCineon";break;case PE:e="ACESFilmic";break;case DE:e="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),e="Linear"}return"vec3 "+n+"( vec3 color ) { return "+e+"ToneMapping( color ); }"}function kR(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Co).join(`
`)}function NR(n){const t=[];for(const e in n){const i=n[e];i!==!1&&t.push("#define "+e+" "+i)}return t.join(`
`)}function zR(n,t){const e={},i=n.getProgramParameter(t,35721);for(let s=0;s<i;s++){const r=n.getActiveAttrib(t,s),o=r.name;let a=1;r.type===35674&&(a=2),r.type===35675&&(a=3),r.type===35676&&(a=4),e[o]={type:r.type,location:n.getAttribLocation(t,o),locationSize:a}}return e}function Co(n){return n!==""}function zx(n,t){return n.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Bx(n,t){return n.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const BR=/^[ \t]*#include +<([\w\d./]+)>/gm;function ku(n){return n.replace(BR,HR)}function HR(n,t){const e=zt[t];if(e===void 0)throw new Error("Can not resolve #include <"+t+">");return ku(e)}const UR=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,VR=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Hx(n){return n.replace(VR,Ux).replace(UR,WR)}function WR(n,t,e,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),Ux(n,t,e,i)}function Ux(n,t,e,i){let s="";for(let r=parseInt(t);r<parseInt(e);r++)s+=i.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return s}function Vx(n){let t="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?t+=`
#define HIGH_PRECISION`:n.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function GR(n){let t="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===Sg?t="SHADOWMAP_TYPE_PCF":n.shadowMapType===oE?t="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===po&&(t="SHADOWMAP_TYPE_VSM"),t}function jR(n){let t="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case xo:case _o:t="ENVMAP_TYPE_CUBE";break;case il:case Yh:t="ENVMAP_TYPE_CUBE_UV";break}return t}function qR(n){let t="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case _o:case Yh:t="ENVMAP_MODE_REFRACTION";break}return t}function XR(n){let t="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case nl:t="ENVMAP_BLENDING_MULTIPLY";break;case TE:t="ENVMAP_BLENDING_MIX";break;case AE:t="ENVMAP_BLENDING_ADD";break}return t}function $R(n,t,e,i){const s=n.getContext(),r=e.defines;let o=e.vertexShader,a=e.fragmentShader;const l=GR(e),c=jR(e),h=qR(e),u=XR(e),d=e.isWebGL2?"":kR(e),f=NR(r),p=s.createProgram();let x,_,m=e.glslVersion?"#version "+e.glslVersion+`
`:"";e.isRawShaderMaterial?(x=[f].filter(Co).join(`
`),x.length>0&&(x+=`
`),_=[d,f].filter(Co).join(`
`),_.length>0&&(_+=`
`)):(x=[Vx(e),"#define SHADER_NAME "+e.shaderName,f,e.instancing?"#define USE_INSTANCING":"",e.instancingColor?"#define USE_INSTANCING_COLOR":"",e.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define MAX_BONES "+e.maxBones,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+h:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.displacementMap&&e.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.flatShading?"#define FLAT_SHADED":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals&&e.flatShading===!1?"#define USE_MORPHNORMALS":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",e.morphTargets&&e.isWebGL2?"#define MORPHTARGETS_COUNT "+e.morphTargetsCount:"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Co).join(`
`),_=[d,Vx(e),"#define SHADER_NAME "+e.shaderName,f,e.useFog&&e.fog?"#define USE_FOG":"",e.useFog&&e.fogExp2?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.matcap?"#define USE_MATCAP":"",e.envMap?"#define USE_ENVMAP":"",e.envMap?"#define "+c:"",e.envMap?"#define "+h:"",e.envMap?"#define "+u:"",e.lightMap?"#define USE_LIGHTMAP":"",e.aoMap?"#define USE_AOMAP":"",e.emissiveMap?"#define USE_EMISSIVEMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.normalMap&&e.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",e.normalMap&&e.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",e.clearcoat?"#define USE_CLEARCOAT":"",e.clearcoatMap?"#define USE_CLEARCOATMAP":"",e.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",e.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",e.specularColorMap?"#define USE_SPECULARCOLORMAP":"",e.roughnessMap?"#define USE_ROUGHNESSMAP":"",e.metalnessMap?"#define USE_METALNESSMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.alphaTest?"#define USE_ALPHATEST":"",e.sheen?"#define USE_SHEEN":"",e.sheenColorMap?"#define USE_SHEENCOLORMAP":"",e.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",e.transmission?"#define USE_TRANSMISSION":"",e.transmissionMap?"#define USE_TRANSMISSIONMAP":"",e.thicknessMap?"#define USE_THICKNESSMAP":"",e.vertexTangents?"#define USE_TANGENT":"",e.vertexColors||e.instancingColor?"#define USE_COLOR":"",e.vertexAlphas?"#define USE_COLOR_ALPHA":"",e.vertexUvs?"#define USE_UV":"",e.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",e.gradientMap?"#define USE_GRADIENTMAP":"",e.flatShading?"#define FLAT_SHADED":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+l:"",e.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",e.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",e.logarithmicDepthBuffer&&e.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",e.toneMapping!==xi?"#define TONE_MAPPING":"",e.toneMapping!==xi?zt.tonemapping_pars_fragment:"",e.toneMapping!==xi?OR("toneMapping",e.toneMapping):"",e.dithering?"#define DITHERING":"",e.format===rs?"#define OPAQUE":"",zt.encodings_pars_fragment,e.map?ds("mapTexelToLinear",e.mapEncoding):"",e.matcap?ds("matcapTexelToLinear",e.matcapEncoding):"",e.envMap?ds("envMapTexelToLinear",e.envMapEncoding):"",e.emissiveMap?ds("emissiveMapTexelToLinear",e.emissiveMapEncoding):"",e.specularColorMap?ds("specularColorMapTexelToLinear",e.specularColorMapEncoding):"",e.sheenColorMap?ds("sheenColorMapTexelToLinear",e.sheenColorMapEncoding):"",e.lightMap?ds("lightMapTexelToLinear",e.lightMapEncoding):"",FR("linearToOutputTexel",e.outputEncoding),e.depthPacking?"#define DEPTH_PACKING "+e.depthPacking:"",`
`].filter(Co).join(`
`)),o=ku(o),o=zx(o,e),o=Bx(o,e),a=ku(a),a=zx(a,e),a=Bx(a,e),o=Hx(o),a=Hx(a),e.isWebGL2&&e.isRawShaderMaterial!==!0&&(m=`#version 300 es
`,x=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+x,_=["#define varying in",e.glslVersion===Xg?"":"layout(location = 0) out highp vec4 pc_fragColor;",e.glslVersion===Xg?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+_);const g=m+x+o,S=m+_+a,v=Ox(s,35633,g),E=Ox(s,35632,S);if(s.attachShader(p,v),s.attachShader(p,E),e.index0AttributeName!==void 0?s.bindAttribLocation(p,0,e.index0AttributeName):e.morphTargets===!0&&s.bindAttribLocation(p,0,"position"),s.linkProgram(p),n.debug.checkShaderErrors){const $=s.getProgramInfoLog(p).trim(),it=s.getShaderInfoLog(v).trim(),tt=s.getShaderInfoLog(E).trim();let N=!0,T=!0;if(s.getProgramParameter(p,35714)===!1){N=!1;const A=Nx(s,v,"vertex"),W=Nx(s,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+s.getError()+" - VALIDATE_STATUS "+s.getProgramParameter(p,35715)+`

Program Info Log: `+$+`
`+A+`
`+W)}else $!==""?console.warn("THREE.WebGLProgram: Program Info Log:",$):(it===""||tt==="")&&(T=!1);T&&(this.diagnostics={runnable:N,programLog:$,vertexShader:{log:it,prefix:x},fragmentShader:{log:tt,prefix:_}})}s.deleteShader(v),s.deleteShader(E);let R;this.getUniforms=function(){return R===void 0&&(R=new Ai(s,p)),R};let D;return this.getAttributes=function(){return D===void 0&&(D=zR(s,p)),D},this.destroy=function(){i.releaseStatesOfProgram(this),s.deleteProgram(p),this.program=void 0},this.name=e.shaderName,this.id=DR++,this.cacheKey=t,this.usedTimes=1,this.program=p,this.vertexShader=v,this.fragmentShader=E,this}let YR=0;class ZR{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(t){const e=t.vertexShader,i=t.fragmentShader,s=this._getShaderStage(e),r=this._getShaderStage(i),o=this._getShaderCacheForMaterial(t);return o.has(s)===!1&&(o.add(s),s.usedTimes++),o.has(r)===!1&&(o.add(r),r.usedTimes++),this}remove(t){const e=this.materialCache.get(t);for(const i of e)i.usedTimes--,i.usedTimes===0&&this.shaderCache.delete(i);return this.materialCache.delete(t),this}getVertexShaderID(t){return this._getShaderStage(t.vertexShader).id}getFragmentShaderID(t){return this._getShaderStage(t.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(t){const e=this.materialCache;return e.has(t)===!1&&e.set(t,new Set),e.get(t)}_getShaderStage(t){const e=this.shaderCache;if(e.has(t)===!1){const i=new JR;e.set(t,i)}return e.get(t)}}class JR{constructor(){this.id=YR++,this.usedTimes=0}}function KR(n,t,e,i,s,r,o){const a=new tx,l=new ZR,c=[],h=s.isWebGL2,u=s.logarithmicDepthBuffer,d=s.floatVertexTextures,f=s.maxVertexUniforms,p=s.vertexTextures;let x=s.precision;const _={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(T){const W=T.skeleton.bones;if(d)return 1024;{const k=Math.floor((f-20)/4),U=Math.min(k,W.length);return U<W.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+W.length+" bones. This GPU supports "+U+"."),0):U}}function g(T){let A;return T&&T.isTexture?A=T.encoding:T&&T.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),A=T.texture.encoding):A=xn,h&&T&&T.isTexture&&T.format===be&&T.type===$n&&T.encoding===js&&(A=xn),A}function S(T,A,W,V,k){const U=V.fog,ct=T.isMeshStandardMaterial?V.environment:null,xt=(T.isMeshStandardMaterial?e:t).get(T.envMap||ct),et=_[T.type],ot=k.isSkinnedMesh?m(k):0;T.precision!==null&&(x=s.getMaxPrecision(T.precision),x!==T.precision&&console.warn("THREE.WebGLProgram.getParameters:",T.precision,"not supported, using",x,"instead."));let yt,gt,wt,J;if(et){const K=On[et];yt=K.vertexShader,gt=K.fragmentShader}else yt=T.vertexShader,gt=T.fragmentShader,l.update(T),wt=l.getVertexShaderID(T),J=l.getFragmentShaderID(T);const j=n.getRenderTarget(),ht=T.alphaTest>0,H=T.clearcoat>0;return{isWebGL2:h,shaderID:et,shaderName:T.type,vertexShader:yt,fragmentShader:gt,defines:T.defines,customVertexShaderID:wt,customFragmentShaderID:J,isRawShaderMaterial:T.isRawShaderMaterial===!0,glslVersion:T.glslVersion,precision:x,instancing:k.isInstancedMesh===!0,instancingColor:k.isInstancedMesh===!0&&k.instanceColor!==null,supportsVertexTextures:p,outputEncoding:j!==null?g(j.texture):n.outputEncoding,map:!!T.map,mapEncoding:g(T.map),matcap:!!T.matcap,matcapEncoding:g(T.matcap),envMap:!!xt,envMapMode:xt&&xt.mapping,envMapEncoding:g(xt),envMapCubeUV:!!xt&&(xt.mapping===il||xt.mapping===Yh),lightMap:!!T.lightMap,lightMapEncoding:g(T.lightMap),aoMap:!!T.aoMap,emissiveMap:!!T.emissiveMap,emissiveMapEncoding:g(T.emissiveMap),bumpMap:!!T.bumpMap,normalMap:!!T.normalMap,objectSpaceNormalMap:T.normalMapType===PT,tangentSpaceNormalMap:T.normalMapType===qs,clearcoat:H,clearcoatMap:H&&!!T.clearcoatMap,clearcoatRoughnessMap:H&&!!T.clearcoatRoughnessMap,clearcoatNormalMap:H&&!!T.clearcoatNormalMap,displacementMap:!!T.displacementMap,roughnessMap:!!T.roughnessMap,metalnessMap:!!T.metalnessMap,specularMap:!!T.specularMap,specularIntensityMap:!!T.specularIntensityMap,specularColorMap:!!T.specularColorMap,specularColorMapEncoding:g(T.specularColorMap),alphaMap:!!T.alphaMap,alphaTest:ht,gradientMap:!!T.gradientMap,sheen:T.sheen>0,sheenColorMap:!!T.sheenColorMap,sheenColorMapEncoding:g(T.sheenColorMap),sheenRoughnessMap:!!T.sheenRoughnessMap,transmission:T.transmission>0,transmissionMap:!!T.transmissionMap,thicknessMap:!!T.thicknessMap,combine:T.combine,vertexTangents:!!T.normalMap&&!!k.geometry&&!!k.geometry.attributes.tangent,vertexColors:T.vertexColors,vertexAlphas:T.vertexColors===!0&&!!k.geometry&&!!k.geometry.attributes.color&&k.geometry.attributes.color.itemSize===4,vertexUvs:!!T.map||!!T.bumpMap||!!T.normalMap||!!T.specularMap||!!T.alphaMap||!!T.emissiveMap||!!T.roughnessMap||!!T.metalnessMap||!!T.clearcoatMap||!!T.clearcoatRoughnessMap||!!T.clearcoatNormalMap||!!T.displacementMap||!!T.transmissionMap||!!T.thicknessMap||!!T.specularIntensityMap||!!T.specularColorMap||!!T.sheenColorMap||!!T.sheenRoughnessMap,uvsVertexOnly:!(!!T.map||!!T.bumpMap||!!T.normalMap||!!T.specularMap||!!T.alphaMap||!!T.emissiveMap||!!T.roughnessMap||!!T.metalnessMap||!!T.clearcoatNormalMap||T.transmission>0||!!T.transmissionMap||!!T.thicknessMap||!!T.specularIntensityMap||!!T.specularColorMap||T.sheen>0||!!T.sheenColorMap||!!T.sheenRoughnessMap)&&!!T.displacementMap,fog:!!U,useFog:T.fog,fogExp2:U&&U.isFogExp2,flatShading:!!T.flatShading,sizeAttenuation:T.sizeAttenuation,logarithmicDepthBuffer:u,skinning:k.isSkinnedMesh===!0&&ot>0,maxBones:ot,useVertexTexture:d,morphTargets:!!k.geometry&&!!k.geometry.morphAttributes.position,morphNormals:!!k.geometry&&!!k.geometry.morphAttributes.normal,morphTargetsCount:!!k.geometry&&!!k.geometry.morphAttributes.position?k.geometry.morphAttributes.position.length:0,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,format:T.format,dithering:T.dithering,shadowMapEnabled:n.shadowMap.enabled&&W.length>0,shadowMapType:n.shadowMap.type,toneMapping:T.toneMapped?n.toneMapping:xi,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:T.premultipliedAlpha,doubleSided:T.side===is,flipSided:T.side===xe,depthPacking:T.depthPacking!==void 0?T.depthPacking:!1,index0AttributeName:T.index0AttributeName,extensionDerivatives:T.extensions&&T.extensions.derivatives,extensionFragDepth:T.extensions&&T.extensions.fragDepth,extensionDrawBuffers:T.extensions&&T.extensions.drawBuffers,extensionShaderTextureLOD:T.extensions&&T.extensions.shaderTextureLOD,rendererExtensionFragDepth:h||i.has("EXT_frag_depth"),rendererExtensionDrawBuffers:h||i.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:h||i.has("EXT_shader_texture_lod"),customProgramCacheKey:T.customProgramCacheKey()}}function v(T){const A=[];if(T.shaderID?A.push(T.shaderID):(A.push(T.customVertexShaderID),A.push(T.customFragmentShaderID)),T.defines!==void 0)for(const W in T.defines)A.push(W),A.push(T.defines[W]);return T.isRawShaderMaterial===!1&&(E(A,T),R(A,T),A.push(n.outputEncoding)),A.push(T.customProgramCacheKey),A.join()}function E(T,A){T.push(A.precision),T.push(A.outputEncoding),T.push(A.mapEncoding),T.push(A.matcapEncoding),T.push(A.envMapMode),T.push(A.envMapEncoding),T.push(A.lightMapEncoding),T.push(A.emissiveMapEncoding),T.push(A.combine),T.push(A.vertexUvs),T.push(A.fogExp2),T.push(A.sizeAttenuation),T.push(A.maxBones),T.push(A.morphTargetsCount),T.push(A.numDirLights),T.push(A.numPointLights),T.push(A.numSpotLights),T.push(A.numHemiLights),T.push(A.numRectAreaLights),T.push(A.numDirLightShadows),T.push(A.numPointLightShadows),T.push(A.numSpotLightShadows),T.push(A.shadowMapType),T.push(A.toneMapping),T.push(A.numClippingPlanes),T.push(A.numClipIntersection),T.push(A.format),T.push(A.specularColorMapEncoding),T.push(A.sheenColorMapEncoding)}function R(T,A){a.disableAll(),A.isWebGL2&&a.enable(0),A.supportsVertexTextures&&a.enable(1),A.instancing&&a.enable(2),A.instancingColor&&a.enable(3),A.map&&a.enable(4),A.matcap&&a.enable(5),A.envMap&&a.enable(6),A.envMapCubeUV&&a.enable(7),A.lightMap&&a.enable(8),A.aoMap&&a.enable(9),A.emissiveMap&&a.enable(10),A.bumpMap&&a.enable(11),A.normalMap&&a.enable(12),A.objectSpaceNormalMap&&a.enable(13),A.tangentSpaceNormalMap&&a.enable(14),A.clearcoat&&a.enable(15),A.clearcoatMap&&a.enable(16),A.clearcoatRoughnessMap&&a.enable(17),A.clearcoatNormalMap&&a.enable(18),A.displacementMap&&a.enable(19),A.specularMap&&a.enable(20),A.roughnessMap&&a.enable(21),A.metalnessMap&&a.enable(22),A.gradientMap&&a.enable(23),A.alphaMap&&a.enable(24),A.alphaTest&&a.enable(25),A.vertexColors&&a.enable(26),A.vertexAlphas&&a.enable(27),A.vertexUvs&&a.enable(28),A.vertexTangents&&a.enable(29),A.uvsVertexOnly&&a.enable(30),A.fog&&a.enable(31),T.push(a.mask),a.disableAll(),A.useFog&&a.enable(0),A.flatShading&&a.enable(1),A.logarithmicDepthBuffer&&a.enable(2),A.skinning&&a.enable(3),A.useVertexTexture&&a.enable(4),A.morphTargets&&a.enable(5),A.morphNormals&&a.enable(6),A.premultipliedAlpha&&a.enable(7),A.shadowMapEnabled&&a.enable(8),A.physicallyCorrectLights&&a.enable(9),A.doubleSided&&a.enable(10),A.flipSided&&a.enable(11),A.depthPacking&&a.enable(12),A.dithering&&a.enable(13),A.specularIntensityMap&&a.enable(14),A.specularColorMap&&a.enable(15),A.transmission&&a.enable(16),A.transmissionMap&&a.enable(17),A.thicknessMap&&a.enable(18),A.sheen&&a.enable(19),A.sheenColorMap&&a.enable(20),A.sheenRoughnessMap&&a.enable(21),T.push(a.mask)}function D(T){const A=_[T.type];let W;if(A){const V=On[A];W=$T.clone(V.uniforms)}else W=T.uniforms;return W}function $(T,A){let W;for(let V=0,k=c.length;V<k;V++){const U=c[V];if(U.cacheKey===A){W=U,++W.usedTimes;break}}return W===void 0&&(W=new $R(n,A,T,r),c.push(W)),W}function it(T){if(--T.usedTimes==0){const A=c.indexOf(T);c[A]=c[c.length-1],c.pop(),T.destroy()}}function tt(T){l.remove(T)}function N(){l.dispose()}return{getParameters:S,getProgramCacheKey:v,getUniforms:D,acquireProgram:$,releaseProgram:it,releaseShaderCache:tt,programs:c,dispose:N}}function QR(){let n=new WeakMap;function t(r){let o=n.get(r);return o===void 0&&(o={},n.set(r,o)),o}function e(r){n.delete(r)}function i(r,o,a){n.get(r)[o]=a}function s(){n=new WeakMap}return{get:t,remove:e,update:i,dispose:s}}function tP(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.material.id!==t.material.id?n.material.id-t.material.id:n.z!==t.z?n.z-t.z:n.id-t.id}function Wx(n,t){return n.groupOrder!==t.groupOrder?n.groupOrder-t.groupOrder:n.renderOrder!==t.renderOrder?n.renderOrder-t.renderOrder:n.z!==t.z?t.z-n.z:n.id-t.id}function Gx(){const n=[];let t=0;const e=[],i=[],s=[];function r(){t=0,e.length=0,i.length=0,s.length=0}function o(u,d,f,p,x,_){let m=n[t];return m===void 0?(m={id:u.id,object:u,geometry:d,material:f,groupOrder:p,renderOrder:u.renderOrder,z:x,group:_},n[t]=m):(m.id=u.id,m.object=u,m.geometry=d,m.material=f,m.groupOrder=p,m.renderOrder=u.renderOrder,m.z=x,m.group=_),t++,m}function a(u,d,f,p,x,_){const m=o(u,d,f,p,x,_);f.transmission>0?i.push(m):f.transparent===!0?s.push(m):e.push(m)}function l(u,d,f,p,x,_){const m=o(u,d,f,p,x,_);f.transmission>0?i.unshift(m):f.transparent===!0?s.unshift(m):e.unshift(m)}function c(u,d){e.length>1&&e.sort(u||tP),i.length>1&&i.sort(d||Wx),s.length>1&&s.sort(d||Wx)}function h(){for(let u=t,d=n.length;u<d;u++){const f=n[u];if(f.id===null)break;f.id=null,f.object=null,f.geometry=null,f.material=null,f.group=null}}return{opaque:e,transmissive:i,transparent:s,init:r,push:a,unshift:l,finish:h,sort:c}}function eP(){let n=new WeakMap;function t(i,s){let r;return n.has(i)===!1?(r=new Gx,n.set(i,[r])):s>=n.get(i).length?(r=new Gx,n.get(i).push(r)):r=n.get(i)[s],r}function e(){n=new WeakMap}return{get:t,dispose:e}}function nP(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={direction:new I,color:new Et};break;case"SpotLight":e={position:new I,direction:new I,color:new Et,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":e={position:new I,color:new Et,distance:0,decay:0};break;case"HemisphereLight":e={direction:new I,skyColor:new Et,groundColor:new Et};break;case"RectAreaLight":e={color:new Et,position:new I,halfWidth:new I,halfHeight:new I};break}return n[t.id]=e,e}}}function iP(){const n={};return{get:function(t){if(n[t.id]!==void 0)return n[t.id];let e;switch(t.type){case"DirectionalLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"SpotLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt};break;case"PointLight":e={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new mt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[t.id]=e,e}}}let sP=0;function rP(n,t){return(t.castShadow?1:0)-(n.castShadow?1:0)}function oP(n,t){const e=new nP,i=iP(),s={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let h=0;h<9;h++)s.probe.push(new I);const r=new I,o=new Tt,a=new Tt;function l(h,u){let d=0,f=0,p=0;for(let it=0;it<9;it++)s.probe[it].set(0,0,0);let x=0,_=0,m=0,g=0,S=0,v=0,E=0,R=0;h.sort(rP);const D=u!==!0?Math.PI:1;for(let it=0,tt=h.length;it<tt;it++){const N=h[it],T=N.color,A=N.intensity,W=N.distance,V=N.shadow&&N.shadow.map?N.shadow.map.texture:null;if(N.isAmbientLight)d+=T.r*A*D,f+=T.g*A*D,p+=T.b*A*D;else if(N.isLightProbe)for(let k=0;k<9;k++)s.probe[k].addScaledVector(N.sh.coefficients[k],A);else if(N.isDirectionalLight){const k=e.get(N);if(k.color.copy(N.color).multiplyScalar(N.intensity*D),N.castShadow){const U=N.shadow,ct=i.get(N);ct.shadowBias=U.bias,ct.shadowNormalBias=U.normalBias,ct.shadowRadius=U.radius,ct.shadowMapSize=U.mapSize,s.directionalShadow[x]=ct,s.directionalShadowMap[x]=V,s.directionalShadowMatrix[x]=N.shadow.matrix,v++}s.directional[x]=k,x++}else if(N.isSpotLight){const k=e.get(N);if(k.position.setFromMatrixPosition(N.matrixWorld),k.color.copy(T).multiplyScalar(A*D),k.distance=W,k.coneCos=Math.cos(N.angle),k.penumbraCos=Math.cos(N.angle*(1-N.penumbra)),k.decay=N.decay,N.castShadow){const U=N.shadow,ct=i.get(N);ct.shadowBias=U.bias,ct.shadowNormalBias=U.normalBias,ct.shadowRadius=U.radius,ct.shadowMapSize=U.mapSize,s.spotShadow[m]=ct,s.spotShadowMap[m]=V,s.spotShadowMatrix[m]=N.shadow.matrix,R++}s.spot[m]=k,m++}else if(N.isRectAreaLight){const k=e.get(N);k.color.copy(T).multiplyScalar(A),k.halfWidth.set(N.width*.5,0,0),k.halfHeight.set(0,N.height*.5,0),s.rectArea[g]=k,g++}else if(N.isPointLight){const k=e.get(N);if(k.color.copy(N.color).multiplyScalar(N.intensity*D),k.distance=N.distance,k.decay=N.decay,N.castShadow){const U=N.shadow,ct=i.get(N);ct.shadowBias=U.bias,ct.shadowNormalBias=U.normalBias,ct.shadowRadius=U.radius,ct.shadowMapSize=U.mapSize,ct.shadowCameraNear=U.camera.near,ct.shadowCameraFar=U.camera.far,s.pointShadow[_]=ct,s.pointShadowMap[_]=V,s.pointShadowMatrix[_]=N.shadow.matrix,E++}s.point[_]=k,_++}else if(N.isHemisphereLight){const k=e.get(N);k.skyColor.copy(N.color).multiplyScalar(A*D),k.groundColor.copy(N.groundColor).multiplyScalar(A*D),s.hemi[S]=k,S++}}g>0&&(t.isWebGL2||n.has("OES_texture_float_linear")===!0?(s.rectAreaLTC1=Mt.LTC_FLOAT_1,s.rectAreaLTC2=Mt.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(s.rectAreaLTC1=Mt.LTC_HALF_1,s.rectAreaLTC2=Mt.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),s.ambient[0]=d,s.ambient[1]=f,s.ambient[2]=p;const $=s.hash;($.directionalLength!==x||$.pointLength!==_||$.spotLength!==m||$.rectAreaLength!==g||$.hemiLength!==S||$.numDirectionalShadows!==v||$.numPointShadows!==E||$.numSpotShadows!==R)&&(s.directional.length=x,s.spot.length=m,s.rectArea.length=g,s.point.length=_,s.hemi.length=S,s.directionalShadow.length=v,s.directionalShadowMap.length=v,s.pointShadow.length=E,s.pointShadowMap.length=E,s.spotShadow.length=R,s.spotShadowMap.length=R,s.directionalShadowMatrix.length=v,s.pointShadowMatrix.length=E,s.spotShadowMatrix.length=R,$.directionalLength=x,$.pointLength=_,$.spotLength=m,$.rectAreaLength=g,$.hemiLength=S,$.numDirectionalShadows=v,$.numPointShadows=E,$.numSpotShadows=R,s.version=sP++)}function c(h,u){let d=0,f=0,p=0,x=0,_=0;const m=u.matrixWorldInverse;for(let g=0,S=h.length;g<S;g++){const v=h[g];if(v.isDirectionalLight){const E=s.directional[d];E.direction.setFromMatrixPosition(v.matrixWorld),r.setFromMatrixPosition(v.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(m),d++}else if(v.isSpotLight){const E=s.spot[p];E.position.setFromMatrixPosition(v.matrixWorld),E.position.applyMatrix4(m),E.direction.setFromMatrixPosition(v.matrixWorld),r.setFromMatrixPosition(v.target.matrixWorld),E.direction.sub(r),E.direction.transformDirection(m),p++}else if(v.isRectAreaLight){const E=s.rectArea[x];E.position.setFromMatrixPosition(v.matrixWorld),E.position.applyMatrix4(m),a.identity(),o.copy(v.matrixWorld),o.premultiply(m),a.extractRotation(o),E.halfWidth.set(v.width*.5,0,0),E.halfHeight.set(0,v.height*.5,0),E.halfWidth.applyMatrix4(a),E.halfHeight.applyMatrix4(a),x++}else if(v.isPointLight){const E=s.point[f];E.position.setFromMatrixPosition(v.matrixWorld),E.position.applyMatrix4(m),f++}else if(v.isHemisphereLight){const E=s.hemi[_];E.direction.setFromMatrixPosition(v.matrixWorld),E.direction.transformDirection(m),E.direction.normalize(),_++}}}return{setup:l,setupView:c,state:s}}function jx(n,t){const e=new oP(n,t),i=[],s=[];function r(){i.length=0,s.length=0}function o(u){i.push(u)}function a(u){s.push(u)}function l(u){e.setup(i,u)}function c(u){e.setupView(i,u)}return{init:r,state:{lightsArray:i,shadowsArray:s,lights:e},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function aP(n,t){let e=new WeakMap;function i(r,o=0){let a;return e.has(r)===!1?(a=new jx(n,t),e.set(r,[a])):o>=e.get(r).length?(a=new jx(n,t),e.get(r).push(a)):a=e.get(r)[o],a}function s(){e=new WeakMap}return{get:i,dispose:s}}class qx extends Ie{constructor(t){super();this.type="MeshDepthMaterial",this.depthPacking=LT,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.depthPacking=t.depthPacking,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this}}qx.prototype.isMeshDepthMaterial=!0;class Xx extends Ie{constructor(t){super();this.type="MeshDistanceMaterial",this.referencePosition=new I,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(t)}copy(t){return super.copy(t),this.referencePosition.copy(t.referencePosition),this.nearDistance=t.nearDistance,this.farDistance=t.farDistance,this.map=t.map,this.alphaMap=t.alphaMap,this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this}}Xx.prototype.isMeshDistanceMaterial=!0;const lP=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,cP=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function $x(n,t,e){let i=new To;const s=new mt,r=new mt,o=new Zt,a=new qx({depthPacking:RT}),l=new Xx,c={},h=e.maxTextureSize,u={0:xe,1:mo,2:is},d=new hs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new mt},radius:{value:4}},vertexShader:lP,fragmentShader:cP}),f=d.clone();f.defines.HORIZONTAL_PASS=1;const p=new ae;p.setAttribute("position",new ve(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new He(p,d),_=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Sg,this.render=function(v,E,R){if(_.enabled===!1||_.autoUpdate===!1&&_.needsUpdate===!1||v.length===0)return;const D=n.getRenderTarget(),$=n.getActiveCubeFace(),it=n.getActiveMipmapLevel(),tt=n.state;tt.setBlending(gi),tt.buffers.color.setClear(1,1,1,1),tt.buffers.depth.setTest(!0),tt.setScissorTest(!1);for(let N=0,T=v.length;N<T;N++){const A=v[N],W=A.shadow;if(W===void 0){console.warn("THREE.WebGLShadowMap:",A,"has no shadow.");continue}if(W.autoUpdate===!1&&W.needsUpdate===!1)continue;s.copy(W.mapSize);const V=W.getFrameExtents();if(s.multiply(V),r.copy(W.mapSize),(s.x>h||s.y>h)&&(s.x>h&&(r.x=Math.floor(h/V.x),s.x=r.x*V.x,W.mapSize.x=r.x),s.y>h&&(r.y=Math.floor(h/V.y),s.y=r.y*V.y,W.mapSize.y=r.y)),W.map===null&&!W.isPointLightShadow&&this.type===po){const U={minFilter:Be,magFilter:Be,format:be};W.map=new an(s.x,s.y,U),W.map.texture.name=A.name+".shadowMap",W.mapPass=new an(s.x,s.y,U),W.camera.updateProjectionMatrix()}if(W.map===null){const U={minFilter:_e,magFilter:_e,format:be};W.map=new an(s.x,s.y,U),W.map.texture.name=A.name+".shadowMap",W.camera.updateProjectionMatrix()}n.setRenderTarget(W.map),n.clear();const k=W.getViewportCount();for(let U=0;U<k;U++){const ct=W.getViewport(U);o.set(r.x*ct.x,r.y*ct.y,r.x*ct.z,r.y*ct.w),tt.viewport(o),W.updateMatrices(A,U),i=W.getFrustum(),S(E,R,W.camera,A,this.type)}!W.isPointLightShadow&&this.type===po&&m(W,R),W.needsUpdate=!1}_.needsUpdate=!1,n.setRenderTarget(D,$,it)};function m(v,E){const R=t.update(x);d.defines.VSM_SAMPLES!==v.blurSamples&&(d.defines.VSM_SAMPLES=v.blurSamples,f.defines.VSM_SAMPLES=v.blurSamples,d.needsUpdate=!0,f.needsUpdate=!0),d.uniforms.shadow_pass.value=v.map.texture,d.uniforms.resolution.value=v.mapSize,d.uniforms.radius.value=v.radius,n.setRenderTarget(v.mapPass),n.clear(),n.renderBufferDirect(E,null,R,d,x,null),f.uniforms.shadow_pass.value=v.mapPass.texture,f.uniforms.resolution.value=v.mapSize,f.uniforms.radius.value=v.radius,n.setRenderTarget(v.map),n.clear(),n.renderBufferDirect(E,null,R,f,x,null)}function g(v,E,R,D,$,it,tt){let N=null;const T=D.isPointLight===!0?v.customDistanceMaterial:v.customDepthMaterial;if(T!==void 0?N=T:N=D.isPointLight===!0?l:a,n.localClippingEnabled&&R.clipShadows===!0&&R.clippingPlanes.length!==0||R.displacementMap&&R.displacementScale!==0||R.alphaMap&&R.alphaTest>0){const A=N.uuid,W=R.uuid;let V=c[A];V===void 0&&(V={},c[A]=V);let k=V[W];k===void 0&&(k=N.clone(),V[W]=k),N=k}return N.visible=R.visible,N.wireframe=R.wireframe,tt===po?N.side=R.shadowSide!==null?R.shadowSide:R.side:N.side=R.shadowSide!==null?R.shadowSide:u[R.side],N.alphaMap=R.alphaMap,N.alphaTest=R.alphaTest,N.clipShadows=R.clipShadows,N.clippingPlanes=R.clippingPlanes,N.clipIntersection=R.clipIntersection,N.displacementMap=R.displacementMap,N.displacementScale=R.displacementScale,N.displacementBias=R.displacementBias,N.wireframeLinewidth=R.wireframeLinewidth,N.linewidth=R.linewidth,D.isPointLight===!0&&N.isMeshDistanceMaterial===!0&&(N.referencePosition.setFromMatrixPosition(D.matrixWorld),N.nearDistance=$,N.farDistance=it),N}function S(v,E,R,D,$){if(v.visible===!1)return;if(v.layers.test(E.layers)&&(v.isMesh||v.isLine||v.isPoints)&&(v.castShadow||v.receiveShadow&&$===po)&&(!v.frustumCulled||i.intersectsObject(v))){v.modelViewMatrix.multiplyMatrices(R.matrixWorldInverse,v.matrixWorld);const N=t.update(v),T=v.material;if(Array.isArray(T)){const A=N.groups;for(let W=0,V=A.length;W<V;W++){const k=A[W],U=T[k.materialIndex];if(U&&U.visible){const ct=g(v,N,U,D,R.near,R.far,$);n.renderBufferDirect(R,null,N,ct,v,k)}}}else if(T.visible){const A=g(v,N,T,D,R.near,R.far,$);n.renderBufferDirect(R,null,N,A,v,null)}}const tt=v.children;for(let N=0,T=tt.length;N<T;N++)S(tt[N],E,R,D,$)}}function hP(n,t,e){const i=e.isWebGL2;function s(){let P=!1;const pt=new Zt;let ft=null;const At=new Zt(0,0,0,0);return{setMask:function(St){ft!==St&&!P&&(n.colorMask(St,St,St,St),ft=St)},setLocked:function(St){P=St},setClear:function(St,It,vt,Ct,Xt){Xt===!0&&(St*=Ct,It*=Ct,vt*=Ct),pt.set(St,It,vt,Ct),At.equals(pt)===!1&&(n.clearColor(St,It,vt,Ct),At.copy(pt))},reset:function(){P=!1,ft=null,At.set(-1,0,0,0)}}}function r(){let P=!1,pt=null,ft=null,At=null;return{setTest:function(St){St?gt(2929):wt(2929)},setMask:function(St){pt!==St&&!P&&(n.depthMask(St),pt=St)},setFunc:function(St){if(ft!==St){if(St)switch(St){case yE:n.depthFunc(512);break;case vE:n.depthFunc(519);break;case bE:n.depthFunc(513);break;case qh:n.depthFunc(515);break;case ME:n.depthFunc(514);break;case wE:n.depthFunc(518);break;case SE:n.depthFunc(516);break;case EE:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);ft=St}},setLocked:function(St){P=St},setClear:function(St){At!==St&&(n.clearDepth(St),At=St)},reset:function(){P=!1,pt=null,ft=null,At=null}}}function o(){let P=!1,pt=null,ft=null,At=null,St=null,It=null,vt=null,Ct=null,Xt=null;return{setTest:function(Kt){P||(Kt?gt(2960):wt(2960))},setMask:function(Kt){pt!==Kt&&!P&&(n.stencilMask(Kt),pt=Kt)},setFunc:function(Kt,Mn,wn){(ft!==Kt||At!==Mn||St!==wn)&&(n.stencilFunc(Kt,Mn,wn),ft=Kt,At=Mn,St=wn)},setOp:function(Kt,Mn,wn){(It!==Kt||vt!==Mn||Ct!==wn)&&(n.stencilOp(Kt,Mn,wn),It=Kt,vt=Mn,Ct=wn)},setLocked:function(Kt){P=Kt},setClear:function(Kt){Xt!==Kt&&(n.clearStencil(Kt),Xt=Kt)},reset:function(){P=!1,pt=null,ft=null,At=null,St=null,It=null,vt=null,Ct=null,Xt=null}}}const a=new s,l=new r,c=new o;let h={},u={},d=null,f=!1,p=null,x=null,_=null,m=null,g=null,S=null,v=null,E=!1,R=null,D=null,$=null,it=null,tt=null;const N=n.getParameter(35661);let T=!1,A=0;const W=n.getParameter(7938);W.indexOf("WebGL")!==-1?(A=parseFloat(/^WebGL (\d)/.exec(W)[1]),T=A>=1):W.indexOf("OpenGL ES")!==-1&&(A=parseFloat(/^OpenGL ES (\d)/.exec(W)[1]),T=A>=2);let V=null,k={};const U=n.getParameter(3088),ct=n.getParameter(2978),xt=new Zt().fromArray(U),et=new Zt().fromArray(ct);function ot(P,pt,ft){const At=new Uint8Array(4),St=n.createTexture();n.bindTexture(P,St),n.texParameteri(P,10241,9728),n.texParameteri(P,10240,9728);for(let It=0;It<ft;It++)n.texImage2D(pt+It,0,6408,1,1,0,6408,5121,At);return St}const yt={};yt[3553]=ot(3553,3553,1),yt[34067]=ot(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),gt(2929),l.setFunc(qh),at(!1),z(wg),gt(2884),rt(gi);function gt(P){h[P]!==!0&&(n.enable(P),h[P]=!0)}function wt(P){h[P]!==!1&&(n.disable(P),h[P]=!1)}function J(P,pt){return u[P]!==pt?(n.bindFramebuffer(P,pt),u[P]=pt,i&&(P===36009&&(u[36160]=pt),P===36160&&(u[36009]=pt)),!0):!1}function j(P){return d!==P?(n.useProgram(P),d=P,!0):!1}const ht={[Hs]:32774,[lE]:32778,[cE]:32779};if(i)ht[Lg]=32775,ht[Rg]=32776;else{const P=t.get("EXT_blend_minmax");P!==null&&(ht[Lg]=P.MIN_EXT,ht[Rg]=P.MAX_EXT)}const H={[hE]:0,[uE]:1,[dE]:768,[Pg]:770,[_E]:776,[gE]:774,[pE]:772,[fE]:769,[Dg]:771,[xE]:775,[mE]:773};function rt(P,pt,ft,At,St,It,vt,Ct){if(P===gi){f===!0&&(wt(3042),f=!1);return}if(f===!1&&(gt(3042),f=!0),P!==aE){if(P!==p||Ct!==E){if((x!==Hs||g!==Hs)&&(n.blendEquation(32774),x=Hs,g=Hs),Ct)switch(P){case go:n.blendFuncSeparate(1,771,1,771);break;case Tg:n.blendFunc(1,1);break;case Ag:n.blendFuncSeparate(0,0,769,771);break;case Cg:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",P);break}else switch(P){case go:n.blendFuncSeparate(770,771,1,771);break;case Tg:n.blendFunc(770,1);break;case Ag:n.blendFunc(0,769);break;case Cg:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",P);break}_=null,m=null,S=null,v=null,p=P,E=Ct}return}St=St||pt,It=It||ft,vt=vt||At,(pt!==x||St!==g)&&(n.blendEquationSeparate(ht[pt],ht[St]),x=pt,g=St),(ft!==_||At!==m||It!==S||vt!==v)&&(n.blendFuncSeparate(H[ft],H[At],H[It],H[vt]),_=ft,m=At,S=It,v=vt),p=P,E=null}function K(P,pt){P.side===is?wt(2884):gt(2884);let ft=P.side===xe;pt&&(ft=!ft),at(ft),P.blending===go&&P.transparent===!1?rt(gi):rt(P.blending,P.blendEquation,P.blendSrc,P.blendDst,P.blendEquationAlpha,P.blendSrcAlpha,P.blendDstAlpha,P.premultipliedAlpha),l.setFunc(P.depthFunc),l.setTest(P.depthTest),l.setMask(P.depthWrite),a.setMask(P.colorWrite);const At=P.stencilWrite;c.setTest(At),At&&(c.setMask(P.stencilWriteMask),c.setFunc(P.stencilFunc,P.stencilRef,P.stencilFuncMask),c.setOp(P.stencilFail,P.stencilZFail,P.stencilZPass)),w(P.polygonOffset,P.polygonOffsetFactor,P.polygonOffsetUnits),P.alphaToCoverage===!0?gt(32926):wt(32926)}function at(P){R!==P&&(P?n.frontFace(2304):n.frontFace(2305),R=P)}function z(P){P!==sE?(gt(2884),P!==D&&(P===wg?n.cullFace(1029):P===rE?n.cullFace(1028):n.cullFace(1032))):wt(2884),D=P}function b(P){P!==$&&(T&&n.lineWidth(P),$=P)}function w(P,pt,ft){P?(gt(32823),(it!==pt||tt!==ft)&&(n.polygonOffset(pt,ft),it=pt,tt=ft)):wt(32823)}function L(P){P?gt(3089):wt(3089)}function F(P){P===void 0&&(P=33984+N-1),V!==P&&(n.activeTexture(P),V=P)}function G(P,pt){V===null&&F();let ft=k[V];ft===void 0&&(ft={type:void 0,texture:void 0},k[V]=ft),(ft.type!==P||ft.texture!==pt)&&(n.bindTexture(P,pt||yt[P]),ft.type=P,ft.texture=pt)}function Q(){const P=k[V];P!==void 0&&P.type!==void 0&&(n.bindTexture(P.type,null),P.type=void 0,P.texture=void 0)}function Y(){try{n.compressedTexImage2D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function nt(){try{n.texSubImage2D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function M(){try{n.texSubImage3D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function y(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function O(){try{n.texStorage2D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function B(){try{n.texStorage3D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function X(){try{n.texImage2D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function q(){try{n.texImage3D.apply(n,arguments)}catch(P){console.error("THREE.WebGLState:",P)}}function _t(P){xt.equals(P)===!1&&(n.scissor(P.x,P.y,P.z,P.w),xt.copy(P))}function bt(P){et.equals(P)===!1&&(n.viewport(P.x,P.y,P.z,P.w),et.copy(P))}function ut(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),i===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),h={},V=null,k={},u={},d=null,f=!1,p=null,x=null,_=null,m=null,g=null,S=null,v=null,E=!1,R=null,D=null,$=null,it=null,tt=null,xt.set(0,0,n.canvas.width,n.canvas.height),et.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:gt,disable:wt,bindFramebuffer:J,useProgram:j,setBlending:rt,setMaterial:K,setFlipSided:at,setCullFace:z,setLineWidth:b,setPolygonOffset:w,setScissorTest:L,activeTexture:F,bindTexture:G,unbindTexture:Q,compressedTexImage2D:Y,texImage2D:X,texImage3D:q,texStorage2D:O,texStorage3D:B,texSubImage2D:nt,texSubImage3D:M,compressedTexSubImage2D:y,scissor:_t,viewport:bt,reset:ut}}function uP(n,t,e,i,s,r,o){const a=s.isWebGL2,l=s.maxTextures,c=s.maxCubemapSize,h=s.maxTextureSize,u=s.maxSamples,f=t.has("WEBGL_multisampled_render_to_texture")?t.get("WEBGL_multisampled_render_to_texture"):void 0,p=new WeakMap;let x,_=!1;try{_=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function m(M,y){return _?new OffscreenCanvas(M,y):hl("canvas")}function g(M,y,O,B){let X=1;if((M.width>B||M.height>B)&&(X=B/Math.max(M.width,M.height)),X<1||y===!0)if(typeof HTMLImageElement!="undefined"&&M instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&M instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&M instanceof ImageBitmap){const q=y?FT:Math.floor,_t=q(X*M.width),bt=q(X*M.height);x===void 0&&(x=m(_t,bt));const ut=O?m(_t,bt):x;return ut.width=_t,ut.height=bt,ut.getContext("2d").drawImage(M,0,0,_t,bt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+M.width+"x"+M.height+") to ("+_t+"x"+bt+")."),ut}else return"data"in M&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+M.width+"x"+M.height+")."),M;return M}function S(M){return $g(M.width)&&$g(M.height)}function v(M){return a?!1:M.wrapS!==Ze||M.wrapT!==Ze||M.minFilter!==_e&&M.minFilter!==Be}function E(M,y){return M.generateMipmaps&&y&&M.minFilter!==_e&&M.minFilter!==Be}function R(M){n.generateMipmap(M)}function D(M,y,O,B){if(a===!1)return y;if(M!==null){if(n[M]!==void 0)return n[M];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+M+"'")}let X=y;return y===6403&&(O===5126&&(X=33326),O===5131&&(X=33325),O===5121&&(X=33321)),y===6407&&(O===5126&&(X=34837),O===5131&&(X=34843),O===5121&&(X=32849)),y===6408&&(O===5126&&(X=34836),O===5131&&(X=34842),O===5121&&(X=B===js?35907:32856)),(X===33325||X===33326||X===34842||X===34836)&&t.get("EXT_color_buffer_float"),X}function $(M,y,O){return E(M,O)===!0||M.isFramebufferTexture&&M.minFilter!==_e&&M.minFilter!==Be?Math.log2(Math.max(y.width,y.height))+1:M.mipmaps!==void 0&&M.mipmaps.length>0?M.mipmaps.length:M.isCompressedTexture&&Array.isArray(M.image)?y.mipmaps.length:1}function it(M){return M===_e||M===Fg||M===Og?9728:9729}function tt(M){const y=M.target;y.removeEventListener("dispose",tt),T(y),y.isVideoTexture&&p.delete(y),o.memory.textures--}function N(M){const y=M.target;y.removeEventListener("dispose",N),A(y)}function T(M){const y=i.get(M);y.__webglInit!==void 0&&(n.deleteTexture(y.__webglTexture),i.remove(M))}function A(M){const y=M.texture,O=i.get(M),B=i.get(y);if(!!M){if(B.__webglTexture!==void 0&&(n.deleteTexture(B.__webglTexture),o.memory.textures--),M.depthTexture&&M.depthTexture.dispose(),M.isWebGLCubeRenderTarget)for(let X=0;X<6;X++)n.deleteFramebuffer(O.__webglFramebuffer[X]),O.__webglDepthbuffer&&n.deleteRenderbuffer(O.__webglDepthbuffer[X]);else n.deleteFramebuffer(O.__webglFramebuffer),O.__webglDepthbuffer&&n.deleteRenderbuffer(O.__webglDepthbuffer),O.__webglMultisampledFramebuffer&&n.deleteFramebuffer(O.__webglMultisampledFramebuffer),O.__webglColorRenderbuffer&&n.deleteRenderbuffer(O.__webglColorRenderbuffer),O.__webglDepthRenderbuffer&&n.deleteRenderbuffer(O.__webglDepthRenderbuffer);if(M.isWebGLMultipleRenderTargets)for(let X=0,q=y.length;X<q;X++){const _t=i.get(y[X]);_t.__webglTexture&&(n.deleteTexture(_t.__webglTexture),o.memory.textures--),i.remove(y[X])}i.remove(y),i.remove(M)}}let W=0;function V(){W=0}function k(){const M=W;return M>=l&&console.warn("THREE.WebGLTextures: Trying to use "+M+" texture units while this GPU supports only "+l),W+=1,M}function U(M,y){const O=i.get(M);if(M.isVideoTexture&&F(M),M.version>0&&O.__version!==M.version){const B=M.image;if(B===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(B.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{J(O,M,y);return}}e.activeTexture(33984+y),e.bindTexture(3553,O.__webglTexture)}function ct(M,y){const O=i.get(M);if(M.version>0&&O.__version!==M.version){J(O,M,y);return}e.activeTexture(33984+y),e.bindTexture(35866,O.__webglTexture)}function xt(M,y){const O=i.get(M);if(M.version>0&&O.__version!==M.version){J(O,M,y);return}e.activeTexture(33984+y),e.bindTexture(32879,O.__webglTexture)}function et(M,y){const O=i.get(M);if(M.version>0&&O.__version!==M.version){j(O,M,y);return}e.activeTexture(33984+y),e.bindTexture(34067,O.__webglTexture)}const ot={[Zh]:10497,[Ze]:33071,[Jh]:33648},yt={[_e]:9728,[Fg]:9984,[Og]:9986,[Be]:9729,[IE]:9985,[sl]:9987};function gt(M,y,O){if(O?(n.texParameteri(M,10242,ot[y.wrapS]),n.texParameteri(M,10243,ot[y.wrapT]),(M===32879||M===35866)&&n.texParameteri(M,32882,ot[y.wrapR]),n.texParameteri(M,10240,yt[y.magFilter]),n.texParameteri(M,10241,yt[y.minFilter])):(n.texParameteri(M,10242,33071),n.texParameteri(M,10243,33071),(M===32879||M===35866)&&n.texParameteri(M,32882,33071),(y.wrapS!==Ze||y.wrapT!==Ze)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(M,10240,it(y.magFilter)),n.texParameteri(M,10241,it(y.minFilter)),y.minFilter!==_e&&y.minFilter!==Be&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),t.has("EXT_texture_filter_anisotropic")===!0){const B=t.get("EXT_texture_filter_anisotropic");if(y.type===_i&&t.has("OES_texture_float_linear")===!1||a===!1&&y.type===ss&&t.has("OES_texture_half_float_linear")===!1)return;(y.anisotropy>1||i.get(y).__currentAnisotropy)&&(n.texParameterf(M,B.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(y.anisotropy,s.getMaxAnisotropy())),i.get(y).__currentAnisotropy=y.anisotropy)}}function wt(M,y){M.__webglInit===void 0&&(M.__webglInit=!0,y.addEventListener("dispose",tt),M.__webglTexture=n.createTexture(),o.memory.textures++)}function J(M,y,O){let B=3553;y.isDataTexture2DArray&&(B=35866),y.isDataTexture3D&&(B=32879),wt(M,y),e.activeTexture(33984+O),e.bindTexture(B,M.__webglTexture),n.pixelStorei(37440,y.flipY),n.pixelStorei(37441,y.premultiplyAlpha),n.pixelStorei(3317,y.unpackAlignment),n.pixelStorei(37443,0);const X=v(y)&&S(y.image)===!1,q=g(y.image,X,!1,h),_t=S(q)||a,bt=r.convert(y.format);let ut=r.convert(y.type),P=D(y.internalFormat,bt,ut,y.encoding);gt(B,y,_t);let pt;const ft=y.mipmaps,At=a&&y.isVideoTexture!==!0,St=M.__version===void 0,It=$(y,q,_t);if(y.isDepthTexture)P=6402,a?y.type===_i?P=36012:y.type===rl?P=33190:y.type===Us?P=35056:P=33189:y.type===_i&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),y.format===os&&P===6402&&y.type!==yo&&y.type!==rl&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),y.type=yo,ut=r.convert(y.type)),y.format===Vs&&P===6402&&(P=34041,y.type!==Us&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),y.type=Us,ut=r.convert(y.type))),At&&St?e.texStorage2D(3553,1,P,q.width,q.height):e.texImage2D(3553,0,P,q.width,q.height,0,bt,ut,null);else if(y.isDataTexture)if(ft.length>0&&_t){At&&St&&e.texStorage2D(3553,It,P,ft[0].width,ft[0].height);for(let vt=0,Ct=ft.length;vt<Ct;vt++)pt=ft[vt],At?e.texSubImage2D(3553,0,0,0,pt.width,pt.height,bt,ut,pt.data):e.texImage2D(3553,vt,P,pt.width,pt.height,0,bt,ut,pt.data);y.generateMipmaps=!1}else At?(St&&e.texStorage2D(3553,It,P,q.width,q.height),e.texSubImage2D(3553,0,0,0,q.width,q.height,bt,ut,q.data)):e.texImage2D(3553,0,P,q.width,q.height,0,bt,ut,q.data);else if(y.isCompressedTexture){At&&St&&e.texStorage2D(3553,It,P,ft[0].width,ft[0].height);for(let vt=0,Ct=ft.length;vt<Ct;vt++)pt=ft[vt],y.format!==be&&y.format!==rs?bt!==null?At?e.compressedTexSubImage2D(3553,vt,0,0,pt.width,pt.height,bt,pt.data):e.compressedTexImage2D(3553,vt,P,pt.width,pt.height,0,pt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):At?e.texSubImage2D(3553,vt,0,0,pt.width,pt.height,bt,ut,pt.data):e.texImage2D(3553,vt,P,pt.width,pt.height,0,bt,ut,pt.data)}else if(y.isDataTexture2DArray)At?(St&&e.texStorage3D(35866,It,P,q.width,q.height,q.depth),e.texSubImage3D(35866,0,0,0,0,q.width,q.height,q.depth,bt,ut,q.data)):e.texImage3D(35866,0,P,q.width,q.height,q.depth,0,bt,ut,q.data);else if(y.isDataTexture3D)At?(St&&e.texStorage3D(32879,It,P,q.width,q.height,q.depth),e.texSubImage3D(32879,0,0,0,0,q.width,q.height,q.depth,bt,ut,q.data)):e.texImage3D(32879,0,P,q.width,q.height,q.depth,0,bt,ut,q.data);else if(y.isFramebufferTexture)At&&St?e.texStorage2D(3553,It,P,q.width,q.height):e.texImage2D(3553,0,P,q.width,q.height,0,bt,ut,null);else if(ft.length>0&&_t){At&&St&&e.texStorage2D(3553,It,P,ft[0].width,ft[0].height);for(let vt=0,Ct=ft.length;vt<Ct;vt++)pt=ft[vt],At?e.texSubImage2D(3553,vt,0,0,bt,ut,pt):e.texImage2D(3553,vt,P,bt,ut,pt);y.generateMipmaps=!1}else At?(St&&e.texStorage2D(3553,It,P,q.width,q.height),e.texSubImage2D(3553,0,0,0,bt,ut,q)):e.texImage2D(3553,0,P,bt,ut,q);E(y,_t)&&R(B),M.__version=y.version,y.onUpdate&&y.onUpdate(y)}function j(M,y,O){if(y.image.length!==6)return;wt(M,y),e.activeTexture(33984+O),e.bindTexture(34067,M.__webglTexture),n.pixelStorei(37440,y.flipY),n.pixelStorei(37441,y.premultiplyAlpha),n.pixelStorei(3317,y.unpackAlignment),n.pixelStorei(37443,0);const B=y&&(y.isCompressedTexture||y.image[0].isCompressedTexture),X=y.image[0]&&y.image[0].isDataTexture,q=[];for(let vt=0;vt<6;vt++)!B&&!X?q[vt]=g(y.image[vt],!1,!0,c):q[vt]=X?y.image[vt].image:y.image[vt];const _t=q[0],bt=S(_t)||a,ut=r.convert(y.format),P=r.convert(y.type),pt=D(y.internalFormat,ut,P,y.encoding),ft=a&&y.isVideoTexture!==!0,At=M.__version===void 0;let St=$(y,_t,bt);gt(34067,y,bt);let It;if(B){ft&&At&&e.texStorage2D(34067,St,pt,_t.width,_t.height);for(let vt=0;vt<6;vt++){It=q[vt].mipmaps;for(let Ct=0;Ct<It.length;Ct++){const Xt=It[Ct];y.format!==be&&y.format!==rs?ut!==null?ft?e.compressedTexSubImage2D(34069+vt,Ct,0,0,Xt.width,Xt.height,ut,Xt.data):e.compressedTexImage2D(34069+vt,Ct,pt,Xt.width,Xt.height,0,Xt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):ft?e.texSubImage2D(34069+vt,Ct,0,0,Xt.width,Xt.height,ut,P,Xt.data):e.texImage2D(34069+vt,Ct,pt,Xt.width,Xt.height,0,ut,P,Xt.data)}}}else{It=y.mipmaps,ft&&At&&(It.length>0&&St++,e.texStorage2D(34067,St,pt,q[0].width,q[0].height));for(let vt=0;vt<6;vt++)if(X){ft?e.texSubImage2D(34069+vt,0,0,0,q[vt].width,q[vt].height,ut,P,q[vt].data):e.texImage2D(34069+vt,0,pt,q[vt].width,q[vt].height,0,ut,P,q[vt].data);for(let Ct=0;Ct<It.length;Ct++){const Kt=It[Ct].image[vt].image;ft?e.texSubImage2D(34069+vt,Ct+1,0,0,Kt.width,Kt.height,ut,P,Kt.data):e.texImage2D(34069+vt,Ct+1,pt,Kt.width,Kt.height,0,ut,P,Kt.data)}}else{ft?e.texSubImage2D(34069+vt,0,0,0,ut,P,q[vt]):e.texImage2D(34069+vt,0,pt,ut,P,q[vt]);for(let Ct=0;Ct<It.length;Ct++){const Xt=It[Ct];ft?e.texSubImage2D(34069+vt,Ct+1,0,0,ut,P,Xt.image[vt]):e.texImage2D(34069+vt,Ct+1,pt,ut,P,Xt.image[vt])}}}E(y,bt)&&R(34067),M.__version=y.version,y.onUpdate&&y.onUpdate(y)}function ht(M,y,O,B,X){const q=r.convert(O.format),_t=r.convert(O.type),bt=D(O.internalFormat,q,_t,O.encoding);i.get(y).__hasExternalTextures||(X===32879||X===35866?e.texImage3D(X,0,bt,y.width,y.height,y.depth,0,q,_t,null):e.texImage2D(X,0,bt,y.width,y.height,0,q,_t,null)),e.bindFramebuffer(36160,M),y.useRenderToTexture?f.framebufferTexture2DMultisampleEXT(36160,B,X,i.get(O).__webglTexture,0,L(y)):n.framebufferTexture2D(36160,B,X,i.get(O).__webglTexture,0),e.bindFramebuffer(36160,null)}function H(M,y,O){if(n.bindRenderbuffer(36161,M),y.depthBuffer&&!y.stencilBuffer){let B=33189;if(O||y.useRenderToTexture){const X=y.depthTexture;X&&X.isDepthTexture&&(X.type===_i?B=36012:X.type===rl&&(B=33190));const q=L(y);y.useRenderToTexture?f.renderbufferStorageMultisampleEXT(36161,q,B,y.width,y.height):n.renderbufferStorageMultisample(36161,q,B,y.width,y.height)}else n.renderbufferStorage(36161,B,y.width,y.height);n.framebufferRenderbuffer(36160,36096,36161,M)}else if(y.depthBuffer&&y.stencilBuffer){const B=L(y);O&&y.useRenderbuffer?n.renderbufferStorageMultisample(36161,B,35056,y.width,y.height):y.useRenderToTexture?f.renderbufferStorageMultisampleEXT(36161,B,35056,y.width,y.height):n.renderbufferStorage(36161,34041,y.width,y.height),n.framebufferRenderbuffer(36160,33306,36161,M)}else{const B=y.isWebGLMultipleRenderTargets===!0?y.texture[0]:y.texture,X=r.convert(B.format),q=r.convert(B.type),_t=D(B.internalFormat,X,q,B.encoding),bt=L(y);O&&y.useRenderbuffer?n.renderbufferStorageMultisample(36161,bt,_t,y.width,y.height):y.useRenderToTexture?f.renderbufferStorageMultisampleEXT(36161,bt,_t,y.width,y.height):n.renderbufferStorage(36161,_t,y.width,y.height)}n.bindRenderbuffer(36161,null)}function rt(M,y){if(y&&y.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,M),!(y.depthTexture&&y.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(y.depthTexture).__webglTexture||y.depthTexture.image.width!==y.width||y.depthTexture.image.height!==y.height)&&(y.depthTexture.image.width=y.width,y.depthTexture.image.height=y.height,y.depthTexture.needsUpdate=!0),U(y.depthTexture,0);const B=i.get(y.depthTexture).__webglTexture,X=L(y);if(y.depthTexture.format===os)y.useRenderToTexture?f.framebufferTexture2DMultisampleEXT(36160,36096,3553,B,0,X):n.framebufferTexture2D(36160,36096,3553,B,0);else if(y.depthTexture.format===Vs)y.useRenderToTexture?f.framebufferTexture2DMultisampleEXT(36160,33306,3553,B,0,X):n.framebufferTexture2D(36160,33306,3553,B,0);else throw new Error("Unknown depthTexture format")}function K(M){const y=i.get(M),O=M.isWebGLCubeRenderTarget===!0;if(M.depthTexture&&!y.__autoAllocateDepthBuffer){if(O)throw new Error("target.depthTexture not supported in Cube render targets");rt(y.__webglFramebuffer,M)}else if(O){y.__webglDepthbuffer=[];for(let B=0;B<6;B++)e.bindFramebuffer(36160,y.__webglFramebuffer[B]),y.__webglDepthbuffer[B]=n.createRenderbuffer(),H(y.__webglDepthbuffer[B],M,!1)}else e.bindFramebuffer(36160,y.__webglFramebuffer),y.__webglDepthbuffer=n.createRenderbuffer(),H(y.__webglDepthbuffer,M,!1);e.bindFramebuffer(36160,null)}function at(M,y,O){const B=i.get(M);y!==void 0&&ht(B.__webglFramebuffer,M,M.texture,36064,3553),O!==void 0&&K(M)}function z(M){const y=M.texture,O=i.get(M),B=i.get(y);M.addEventListener("dispose",N),M.isWebGLMultipleRenderTargets!==!0&&(B.__webglTexture===void 0&&(B.__webglTexture=n.createTexture()),B.__version=y.version,o.memory.textures++);const X=M.isWebGLCubeRenderTarget===!0,q=M.isWebGLMultipleRenderTargets===!0,_t=y.isDataTexture3D||y.isDataTexture2DArray,bt=S(M)||a;if(a&&y.format===rs&&(y.type===_i||y.type===ss)&&(y.format=be,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),X){O.__webglFramebuffer=[];for(let ut=0;ut<6;ut++)O.__webglFramebuffer[ut]=n.createFramebuffer()}else if(O.__webglFramebuffer=n.createFramebuffer(),q)if(s.drawBuffers){const ut=M.texture;for(let P=0,pt=ut.length;P<pt;P++){const ft=i.get(ut[P]);ft.__webglTexture===void 0&&(ft.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(M.useRenderbuffer)if(a){O.__webglMultisampledFramebuffer=n.createFramebuffer(),O.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,O.__webglColorRenderbuffer);const ut=r.convert(y.format),P=r.convert(y.type),pt=D(y.internalFormat,ut,P,y.encoding),ft=L(M);n.renderbufferStorageMultisample(36161,ft,pt,M.width,M.height),e.bindFramebuffer(36160,O.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,O.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),M.depthBuffer&&(O.__webglDepthRenderbuffer=n.createRenderbuffer(),H(O.__webglDepthRenderbuffer,M,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(X){e.bindTexture(34067,B.__webglTexture),gt(34067,y,bt);for(let ut=0;ut<6;ut++)ht(O.__webglFramebuffer[ut],M,y,36064,34069+ut);E(y,bt)&&R(34067),e.unbindTexture()}else if(q){const ut=M.texture;for(let P=0,pt=ut.length;P<pt;P++){const ft=ut[P],At=i.get(ft);e.bindTexture(3553,At.__webglTexture),gt(3553,ft,bt),ht(O.__webglFramebuffer,M,ft,36064+P,3553),E(ft,bt)&&R(3553)}e.unbindTexture()}else{let ut=3553;_t&&(a?ut=y.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),e.bindTexture(ut,B.__webglTexture),gt(ut,y,bt),ht(O.__webglFramebuffer,M,y,36064,ut),E(y,bt)&&R(ut),e.unbindTexture()}M.depthBuffer&&K(M)}function b(M){const y=S(M)||a,O=M.isWebGLMultipleRenderTargets===!0?M.texture:[M.texture];for(let B=0,X=O.length;B<X;B++){const q=O[B];if(E(q,y)){const _t=M.isWebGLCubeRenderTarget?34067:3553,bt=i.get(q).__webglTexture;e.bindTexture(_t,bt),R(_t),e.unbindTexture()}}}function w(M){if(M.useRenderbuffer)if(a){const y=M.width,O=M.height;let B=16384;const X=[36064],q=M.stencilBuffer?33306:36096;M.depthBuffer&&X.push(q),M.ignoreDepthForMultisampleCopy||(M.depthBuffer&&(B|=256),M.stencilBuffer&&(B|=1024));const _t=i.get(M);e.bindFramebuffer(36008,_t.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,_t.__webglFramebuffer),M.ignoreDepthForMultisampleCopy&&(n.invalidateFramebuffer(36008,[q]),n.invalidateFramebuffer(36009,[q])),n.blitFramebuffer(0,0,y,O,0,0,y,O,B,9728),n.invalidateFramebuffer(36008,X),e.bindFramebuffer(36008,null),e.bindFramebuffer(36009,_t.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function L(M){return a&&(M.useRenderbuffer||M.useRenderToTexture)?Math.min(u,M.samples):0}function F(M){const y=o.render.frame;p.get(M)!==y&&(p.set(M,y),M.update())}let G=!1,Q=!1;function Y(M,y){M&&M.isWebGLRenderTarget&&(G===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),G=!0),M=M.texture),U(M,y)}function nt(M,y){M&&M.isWebGLCubeRenderTarget&&(Q===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Q=!0),M=M.texture),et(M,y)}this.allocateTextureUnit=k,this.resetTextureUnits=V,this.setTexture2D=U,this.setTexture2DArray=ct,this.setTexture3D=xt,this.setTextureCube=et,this.rebindTextures=at,this.setupRenderTarget=z,this.updateRenderTargetMipmap=b,this.updateMultisampleRenderTarget=w,this.setupDepthRenderbuffer=K,this.setupFrameBufferTexture=ht,this.safeSetTexture2D=Y,this.safeSetTextureCube=nt}function dP(n,t,e){const i=e.isWebGL2;function s(r){let o;if(r===$n)return 5121;if(r===NE)return 32819;if(r===zE)return 32820;if(r===BE)return 33635;if(r===FE)return 5120;if(r===OE)return 5122;if(r===yo)return 5123;if(r===kE)return 5124;if(r===rl)return 5125;if(r===_i)return 5126;if(r===ss)return i?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(r===HE)return 6406;if(r===rs)return 6407;if(r===be)return 6408;if(r===UE)return 6409;if(r===VE)return 6410;if(r===os)return 6402;if(r===Vs)return 34041;if(r===WE)return 6403;if(r===GE)return 36244;if(r===jE)return 33319;if(r===qE)return 33320;if(r===XE)return 36248;if(r===$E)return 36249;if(r===kg||r===Ng||r===zg||r===Bg)if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(r===kg)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Ng)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===zg)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Bg)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===Hg||r===Ug||r===Vg||r===Wg)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(r===Hg)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===Ug)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===Vg)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===Wg)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===YE)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((r===Gg||r===jg)&&(o=t.get("WEBGL_compressed_texture_etc"),o!==null)){if(r===Gg)return o.COMPRESSED_RGB8_ETC2;if(r===jg)return o.COMPRESSED_RGBA8_ETC2_EAC}if(r===ZE||r===JE||r===KE||r===QE||r===tT||r===eT||r===nT||r===iT||r===sT||r===rT||r===oT||r===aT||r===lT||r===cT||r===uT||r===dT||r===fT||r===pT||r===mT||r===gT||r===xT||r===_T||r===yT||r===vT||r===bT||r===MT||r===wT||r===ST)return o=t.get("WEBGL_compressed_texture_astc"),o!==null?r:null;if(r===hT)return o=t.get("EXT_texture_compression_bptc"),o!==null?r:null;if(r===Us)return i?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:s}}class Yx extends je{constructor(t=[]){super();this.cameras=t}}Yx.prototype.isArrayCamera=!0;class Lo extends qt{constructor(){super();this.type="Group"}}Lo.prototype.isGroup=!0;const fP={type:"move"};class Nu{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Lo,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Lo,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new I,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new I),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Lo,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new I,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new I),this._grip}dispatchEvent(t){return this._targetRay!==null&&this._targetRay.dispatchEvent(t),this._grip!==null&&this._grip.dispatchEvent(t),this._hand!==null&&this._hand.dispatchEvent(t),this}disconnect(t){return this.dispatchEvent({type:"disconnected",data:t}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(t,e,i){let s=null,r=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(t&&e.session.visibilityState!=="visible-blurred")if(a!==null&&(s=e.getPose(t.targetRaySpace,i),s!==null&&(a.matrix.fromArray(s.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),s.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(s.linearVelocity)):a.hasLinearVelocity=!1,s.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(s.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(fP))),c&&t.hand){o=!0;for(const x of t.hand.values()){const _=e.getJointPose(x,i);if(c.joints[x.jointName]===void 0){const g=new Lo;g.matrixAutoUpdate=!1,g.visible=!1,c.joints[x.jointName]=g,c.add(g)}const m=c.joints[x.jointName];_!==null&&(m.matrix.fromArray(_.transform.matrix),m.matrix.decompose(m.position,m.rotation,m.scale),m.jointRadius=_.radius),m.visible=_!==null}const h=c.joints["index-finger-tip"],u=c.joints["thumb-tip"],d=h.position.distanceTo(u.position),f=.02,p=.005;c.inputState.pinching&&d>f+p?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:t.handedness,target:this})):!c.inputState.pinching&&d<=f-p&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:t.handedness,target:this}))}else l!==null&&t.gripSpace&&(r=e.getPose(t.gripSpace,i),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));return a!==null&&(a.visible=s!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=o!==null),this}}class zu extends Me{constructor(t,e,i,s,r,o,a,l,c,h){if(h=h!==void 0?h:os,h!==os&&h!==Vs)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");i===void 0&&h===os&&(i=yo),i===void 0&&h===Vs&&(i=Us);super(null,s,r,o,a,l,h,i,c);this.image={width:t,height:e},this.magFilter=a!==void 0?a:_e,this.minFilter=l!==void 0?l:_e,this.flipY=!1,this.generateMipmaps=!1}}zu.prototype.isDepthTexture=!0;class pP extends as{constructor(t,e){super();const i=this;let s=null,r=1,o=null,a="local-floor";const l=t.extensions.has("WEBGL_multisampled_render_to_texture");let c=null,h=null,u=null,d=null,f=!1,p=null;const x=e.getContextAttributes();let _=null,m=null;const g=[],S=new Map,v=new je;v.layers.enable(1),v.viewport=new Zt;const E=new je;E.layers.enable(2),E.viewport=new Zt;const R=[v,E],D=new Yx;D.layers.enable(1),D.layers.enable(2);let $=null,it=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(et){let ot=g[et];return ot===void 0&&(ot=new Nu,g[et]=ot),ot.getTargetRaySpace()},this.getControllerGrip=function(et){let ot=g[et];return ot===void 0&&(ot=new Nu,g[et]=ot),ot.getGripSpace()},this.getHand=function(et){let ot=g[et];return ot===void 0&&(ot=new Nu,g[et]=ot),ot.getHandSpace()};function tt(et){const ot=S.get(et.inputSource);ot&&ot.dispatchEvent({type:et.type,data:et.inputSource})}function N(){S.forEach(function(et,ot){et.disconnect(ot)}),S.clear(),$=null,it=null,t.setRenderTarget(_),d=null,u=null,h=null,s=null,m=null,xt.stop(),i.isPresenting=!1,i.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(et){r=et,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(et){a=et,i.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getBaseLayer=function(){return u!==null?u:d},this.getBinding=function(){return h},this.getFrame=function(){return p},this.getSession=function(){return s},this.setSession=async function(et){if(s=et,s!==null){if(_=t.getRenderTarget(),s.addEventListener("select",tt),s.addEventListener("selectstart",tt),s.addEventListener("selectend",tt),s.addEventListener("squeeze",tt),s.addEventListener("squeezestart",tt),s.addEventListener("squeezeend",tt),s.addEventListener("end",N),s.addEventListener("inputsourceschange",T),x.xrCompatible!==!0&&await e.makeXRCompatible(),s.renderState.layers===void 0||t.capabilities.isWebGL2===!1){const ot={antialias:s.renderState.layers===void 0?x.antialias:!0,alpha:x.alpha,depth:x.depth,stencil:x.stencil,framebufferScaleFactor:r};d=new XRWebGLLayer(s,e,ot),s.updateRenderState({baseLayer:d}),m=new an(d.framebufferWidth,d.framebufferHeight,{format:be,type:$n,encoding:t.outputEncoding})}else{f=x.antialias;let ot=null,yt=null,gt=null;x.depth&&(gt=x.stencil?35056:33190,ot=x.stencil?Vs:os,yt=x.stencil?Us:yo);const wt={colorFormat:x.alpha||f?32856:32849,depthFormat:gt,scaleFactor:r};h=new XRWebGLBinding(s,e),u=h.createProjectionLayer(wt),s.updateRenderState({layers:[u]}),f?m=new ru(u.textureWidth,u.textureHeight,{format:be,type:$n,depthTexture:new zu(u.textureWidth,u.textureHeight,yt,void 0,void 0,void 0,void 0,void 0,void 0,ot),stencilBuffer:x.stencil,ignoreDepth:u.ignoreDepthValues,useRenderToTexture:l,encoding:t.outputEncoding}):m=new an(u.textureWidth,u.textureHeight,{format:x.alpha?be:rs,type:$n,depthTexture:new zu(u.textureWidth,u.textureHeight,yt,void 0,void 0,void 0,void 0,void 0,void 0,ot),stencilBuffer:x.stencil,ignoreDepth:u.ignoreDepthValues,encoding:t.outputEncoding})}this.setFoveation(1),o=await s.requestReferenceSpace(a),xt.setContext(s),xt.start(),i.isPresenting=!0,i.dispatchEvent({type:"sessionstart"})}};function T(et){const ot=s.inputSources;for(let yt=0;yt<g.length;yt++)S.set(ot[yt],g[yt]);for(let yt=0;yt<et.removed.length;yt++){const gt=et.removed[yt],wt=S.get(gt);wt&&(wt.dispatchEvent({type:"disconnected",data:gt}),S.delete(gt))}for(let yt=0;yt<et.added.length;yt++){const gt=et.added[yt],wt=S.get(gt);wt&&wt.dispatchEvent({type:"connected",data:gt})}}const A=new I,W=new I;function V(et,ot,yt){A.setFromMatrixPosition(ot.matrixWorld),W.setFromMatrixPosition(yt.matrixWorld);const gt=A.distanceTo(W),wt=ot.projectionMatrix.elements,J=yt.projectionMatrix.elements,j=wt[14]/(wt[10]-1),ht=wt[14]/(wt[10]+1),H=(wt[9]+1)/wt[5],rt=(wt[9]-1)/wt[5],K=(wt[8]-1)/wt[0],at=(J[8]+1)/J[0],z=j*K,b=j*at,w=gt/(-K+at),L=w*-K;ot.matrixWorld.decompose(et.position,et.quaternion,et.scale),et.translateX(L),et.translateZ(w),et.matrixWorld.compose(et.position,et.quaternion,et.scale),et.matrixWorldInverse.copy(et.matrixWorld).invert();const F=j+w,G=ht+w,Q=z-L,Y=b+(gt-L),nt=H*ht/G*F,M=rt*ht/G*F;et.projectionMatrix.makePerspective(Q,Y,nt,M,F,G)}function k(et,ot){ot===null?et.matrixWorld.copy(et.matrix):et.matrixWorld.multiplyMatrices(ot.matrixWorld,et.matrix),et.matrixWorldInverse.copy(et.matrixWorld).invert()}this.updateCamera=function(et){if(s===null)return;D.near=E.near=v.near=et.near,D.far=E.far=v.far=et.far,($!==D.near||it!==D.far)&&(s.updateRenderState({depthNear:D.near,depthFar:D.far}),$=D.near,it=D.far);const ot=et.parent,yt=D.cameras;k(D,ot);for(let wt=0;wt<yt.length;wt++)k(yt[wt],ot);D.matrixWorld.decompose(D.position,D.quaternion,D.scale),et.position.copy(D.position),et.quaternion.copy(D.quaternion),et.scale.copy(D.scale),et.matrix.copy(D.matrix),et.matrixWorld.copy(D.matrixWorld);const gt=et.children;for(let wt=0,J=gt.length;wt<J;wt++)gt[wt].updateMatrixWorld(!0);yt.length===2?V(D,v,E):D.projectionMatrix.copy(v.projectionMatrix)},this.getCamera=function(){return D},this.getFoveation=function(){if(u!==null)return u.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(et){u!==null&&(u.fixedFoveation=et),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=et)};let U=null;function ct(et,ot){if(c=ot.getViewerPose(o),p=ot,c!==null){const gt=c.views;d!==null&&(t.setRenderTargetFramebuffer(m,d.framebuffer),t.setRenderTarget(m));let wt=!1;gt.length!==D.cameras.length&&(D.cameras.length=0,wt=!0);for(let J=0;J<gt.length;J++){const j=gt[J];let ht=null;if(d!==null)ht=d.getViewport(j);else{const rt=h.getViewSubImage(u,j);ht=rt.viewport,J===0&&(t.setRenderTargetTextures(m,rt.colorTexture,u.ignoreDepthValues?void 0:rt.depthStencilTexture),t.setRenderTarget(m))}const H=R[J];H.matrix.fromArray(j.transform.matrix),H.projectionMatrix.fromArray(j.projectionMatrix),H.viewport.set(ht.x,ht.y,ht.width,ht.height),J===0&&D.matrix.copy(H.matrix),wt===!0&&D.cameras.push(H)}}const yt=s.inputSources;for(let gt=0;gt<g.length;gt++){const wt=g[gt],J=yt[gt];wt.update(J,ot,o)}U&&U(et,ot),p=null}const xt=new dx;xt.setAnimationLoop(ct),this.setAnimationLoop=function(et){U=et},this.dispose=function(){}}}function mP(n){function t(m,g){m.fogColor.value.copy(g.color),g.isFog?(m.fogNear.value=g.near,m.fogFar.value=g.far):g.isFogExp2&&(m.fogDensity.value=g.density)}function e(m,g,S,v,E){g.isMeshBasicMaterial?i(m,g):g.isMeshLambertMaterial?(i(m,g),l(m,g)):g.isMeshToonMaterial?(i(m,g),h(m,g)):g.isMeshPhongMaterial?(i(m,g),c(m,g)):g.isMeshStandardMaterial?(i(m,g),g.isMeshPhysicalMaterial?d(m,g,E):u(m,g)):g.isMeshMatcapMaterial?(i(m,g),f(m,g)):g.isMeshDepthMaterial?(i(m,g),p(m,g)):g.isMeshDistanceMaterial?(i(m,g),x(m,g)):g.isMeshNormalMaterial?(i(m,g),_(m,g)):g.isLineBasicMaterial?(s(m,g),g.isLineDashedMaterial&&r(m,g)):g.isPointsMaterial?o(m,g,S,v):g.isSpriteMaterial?a(m,g):g.isShadowMaterial?(m.color.value.copy(g.color),m.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function i(m,g){m.opacity.value=g.opacity,g.color&&m.diffuse.value.copy(g.color),g.emissive&&m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.specularMap&&(m.specularMap.value=g.specularMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);const S=n.get(g).envMap;S&&(m.envMap.value=S,m.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=g.reflectivity,m.ior.value=g.ior,m.refractionRatio.value=g.refractionRatio),g.lightMap&&(m.lightMap.value=g.lightMap,m.lightMapIntensity.value=g.lightMapIntensity),g.aoMap&&(m.aoMap.value=g.aoMap,m.aoMapIntensity.value=g.aoMapIntensity);let v;g.map?v=g.map:g.specularMap?v=g.specularMap:g.displacementMap?v=g.displacementMap:g.normalMap?v=g.normalMap:g.bumpMap?v=g.bumpMap:g.roughnessMap?v=g.roughnessMap:g.metalnessMap?v=g.metalnessMap:g.alphaMap?v=g.alphaMap:g.emissiveMap?v=g.emissiveMap:g.clearcoatMap?v=g.clearcoatMap:g.clearcoatNormalMap?v=g.clearcoatNormalMap:g.clearcoatRoughnessMap?v=g.clearcoatRoughnessMap:g.specularIntensityMap?v=g.specularIntensityMap:g.specularColorMap?v=g.specularColorMap:g.transmissionMap?v=g.transmissionMap:g.thicknessMap?v=g.thicknessMap:g.sheenColorMap?v=g.sheenColorMap:g.sheenRoughnessMap&&(v=g.sheenRoughnessMap),v!==void 0&&(v.isWebGLRenderTarget&&(v=v.texture),v.matrixAutoUpdate===!0&&v.updateMatrix(),m.uvTransform.value.copy(v.matrix));let E;g.aoMap?E=g.aoMap:g.lightMap&&(E=g.lightMap),E!==void 0&&(E.isWebGLRenderTarget&&(E=E.texture),E.matrixAutoUpdate===!0&&E.updateMatrix(),m.uv2Transform.value.copy(E.matrix))}function s(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity}function r(m,g){m.dashSize.value=g.dashSize,m.totalSize.value=g.dashSize+g.gapSize,m.scale.value=g.scale}function o(m,g,S,v){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.size.value=g.size*S,m.scale.value=v*.5,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);let E;g.map?E=g.map:g.alphaMap&&(E=g.alphaMap),E!==void 0&&(E.matrixAutoUpdate===!0&&E.updateMatrix(),m.uvTransform.value.copy(E.matrix))}function a(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.rotation.value=g.rotation,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);let S;g.map?S=g.map:g.alphaMap&&(S=g.alphaMap),S!==void 0&&(S.matrixAutoUpdate===!0&&S.updateMatrix(),m.uvTransform.value.copy(S.matrix))}function l(m,g){g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap)}function c(m,g){m.specular.value.copy(g.specular),m.shininess.value=Math.max(g.shininess,1e-4),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===xe&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===xe&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function h(m,g){g.gradientMap&&(m.gradientMap.value=g.gradientMap),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===xe&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===xe&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function u(m,g){m.roughness.value=g.roughness,m.metalness.value=g.metalness,g.roughnessMap&&(m.roughnessMap.value=g.roughnessMap),g.metalnessMap&&(m.metalnessMap.value=g.metalnessMap),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===xe&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===xe&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),n.get(g).envMap&&(m.envMapIntensity.value=g.envMapIntensity)}function d(m,g,S){u(m,g),m.ior.value=g.ior,g.sheen>0&&(m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),m.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(m.sheenColorMap.value=g.sheenColorMap),g.sheenRoughnessMap&&(m.sheenRoughnessMap.value=g.sheenRoughnessMap)),g.clearcoat>0&&(m.clearcoat.value=g.clearcoat,m.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(m.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),m.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===xe&&m.clearcoatNormalScale.value.negate())),g.transmission>0&&(m.transmission.value=g.transmission,m.transmissionSamplerMap.value=S.texture,m.transmissionSamplerSize.value.set(S.width,S.height),g.transmissionMap&&(m.transmissionMap.value=g.transmissionMap),m.thickness.value=g.thickness,g.thicknessMap&&(m.thicknessMap.value=g.thicknessMap),m.attenuationDistance.value=g.attenuationDistance,m.attenuationColor.value.copy(g.attenuationColor)),m.specularIntensity.value=g.specularIntensity,m.specularColor.value.copy(g.specularColor),g.specularIntensityMap&&(m.specularIntensityMap.value=g.specularIntensityMap),g.specularColorMap&&(m.specularColorMap.value=g.specularColorMap)}function f(m,g){g.matcap&&(m.matcap.value=g.matcap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===xe&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===xe&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function p(m,g){g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function x(m,g){g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),m.referencePosition.value.copy(g.referencePosition),m.nearDistance.value=g.nearDistance,m.farDistance.value=g.farDistance}function _(m,g){g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===xe&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===xe&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:e}}function gP(){const n=hl("canvas");return n.style.display="block",n}function Qt(n={}){const t=n.canvas!==void 0?n.canvas:gP(),e=n.context!==void 0?n.context:null,i=n.alpha!==void 0?n.alpha:!1,s=n.depth!==void 0?n.depth:!0,r=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",h=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const f=[],p=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.outputEncoding=xn,this.physicallyCorrectLights=!1,this.toneMapping=xi,this.toneMappingExposure=1;const x=this;let _=!1,m=0,g=0,S=null,v=-1,E=null;const R=new Zt,D=new Zt;let $=null,it=t.width,tt=t.height,N=1,T=null,A=null;const W=new Zt(0,0,it,tt),V=new Zt(0,0,it,tt);let k=!1;const U=[],ct=new To;let xt=!1,et=!1,ot=null;const yt=new Tt,gt=new I,wt={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function J(){return S===null?N:1}let j=e;function ht(C,Z){for(let lt=0;lt<C.length;lt++){const st=C[lt],dt=t.getContext(st,Z);if(dt!==null)return dt}return null}try{const C={alpha:i,depth:s,stencil:r,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${jh}`),t.addEventListener("webglcontextlost",At,!1),t.addEventListener("webglcontextrestored",St,!1),j===null){const Z=["webgl2","webgl","experimental-webgl"];if(x.isWebGL1Renderer===!0&&Z.shift(),j=ht(Z,C),j===null)throw ht(Z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}j.getShaderPrecisionFormat===void 0&&(j.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(C){throw console.error("THREE.WebGLRenderer: "+C.message),C}let H,rt,K,at,z,b,w,L,F,G,Q,Y,nt,M,y,O,B,X,q,_t,bt,ut,P;function pt(){H=new kL(j),rt=new LL(j,H,n),H.init(rt),ut=new dP(j,H,rt),K=new hP(j,H,rt),U[0]=1029,at=new BL(j),z=new QR,b=new uP(j,H,K,z,rt,ut,at),w=new PL(x),L=new OL(x),F=new QT(j,rt),P=new AL(j,H,F,rt),G=new NL(j,F,at,P),Q=new WL(j,G,F,at),q=new VL(j,rt,b),O=new RL(z),Y=new KR(x,w,L,H,rt,P,O),nt=new mP(z),M=new eP,y=new aP(H,rt),X=new TL(x,w,K,Q,a),B=new $x(x,Q,rt),_t=new CL(j,H,at,rt),bt=new zL(j,H,at,rt),at.programs=Y.programs,x.capabilities=rt,x.extensions=H,x.properties=z,x.renderLists=M,x.shadowMap=B,x.state=K,x.info=at}pt();const ft=new pP(x,j);this.xr=ft,this.getContext=function(){return j},this.getContextAttributes=function(){return j.getContextAttributes()},this.forceContextLoss=function(){const C=H.get("WEBGL_lose_context");C&&C.loseContext()},this.forceContextRestore=function(){const C=H.get("WEBGL_lose_context");C&&C.restoreContext()},this.getPixelRatio=function(){return N},this.setPixelRatio=function(C){C!==void 0&&(N=C,this.setSize(it,tt,!1))},this.getSize=function(C){return C.set(it,tt)},this.setSize=function(C,Z,lt){if(ft.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}it=C,tt=Z,t.width=Math.floor(C*N),t.height=Math.floor(Z*N),lt!==!1&&(t.style.width=C+"px",t.style.height=Z+"px"),this.setViewport(0,0,C,Z)},this.getDrawingBufferSize=function(C){return C.set(it*N,tt*N).floor()},this.setDrawingBufferSize=function(C,Z,lt){it=C,tt=Z,N=lt,t.width=Math.floor(C*lt),t.height=Math.floor(Z*lt),this.setViewport(0,0,C,Z)},this.getCurrentViewport=function(C){return C.copy(R)},this.getViewport=function(C){return C.copy(W)},this.setViewport=function(C,Z,lt,st){C.isVector4?W.set(C.x,C.y,C.z,C.w):W.set(C,Z,lt,st),K.viewport(R.copy(W).multiplyScalar(N).floor())},this.getScissor=function(C){return C.copy(V)},this.setScissor=function(C,Z,lt,st){C.isVector4?V.set(C.x,C.y,C.z,C.w):V.set(C,Z,lt,st),K.scissor(D.copy(V).multiplyScalar(N).floor())},this.getScissorTest=function(){return k},this.setScissorTest=function(C){K.setScissorTest(k=C)},this.setOpaqueSort=function(C){T=C},this.setTransparentSort=function(C){A=C},this.getClearColor=function(C){return C.copy(X.getClearColor())},this.setClearColor=function(){X.setClearColor.apply(X,arguments)},this.getClearAlpha=function(){return X.getClearAlpha()},this.setClearAlpha=function(){X.setClearAlpha.apply(X,arguments)},this.clear=function(C,Z,lt){let st=0;(C===void 0||C)&&(st|=16384),(Z===void 0||Z)&&(st|=256),(lt===void 0||lt)&&(st|=1024),j.clear(st)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",At,!1),t.removeEventListener("webglcontextrestored",St,!1),M.dispose(),y.dispose(),z.dispose(),w.dispose(),L.dispose(),Q.dispose(),P.dispose(),Y.dispose(),ft.dispose(),ft.removeEventListener("sessionstart",Mn),ft.removeEventListener("sessionend",wn),ot&&(ot.dispose(),ot=null),Ii.stop()};function At(C){C.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function St(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const C=at.autoReset,Z=B.enabled,lt=B.autoUpdate,st=B.needsUpdate,dt=B.type;pt(),at.autoReset=C,B.enabled=Z,B.autoUpdate=lt,B.needsUpdate=st,B.type=dt}function It(C){const Z=C.target;Z.removeEventListener("dispose",It),vt(Z)}function vt(C){Ct(C),z.remove(C)}function Ct(C){const Z=z.get(C).programs;Z!==void 0&&(Z.forEach(function(lt){Y.releaseProgram(lt)}),C.isShaderMaterial&&Y.releaseShaderCache(C))}this.renderBufferDirect=function(C,Z,lt,st,dt,Rt){Z===null&&(Z=wt);const Dt=dt.isMesh&&dt.matrixWorld.determinant()<0,kt=oy(C,Z,lt,st,dt);K.setMaterial(st,Dt);let Pt=lt.index;const Ut=lt.attributes.position;if(Pt===null){if(Ut===void 0||Ut.count===0)return}else if(Pt.count===0)return;let Nt=1;st.wireframe===!0&&(Pt=G.getWireframeAttribute(lt),Nt=2),P.setup(dt,st,kt,lt,Pt);let Ht,he=_t;Pt!==null&&(Ht=F.get(Pt),he=bt,he.setIndex(Ht));const Fi=Pt!==null?Pt.count:Ut.count,ms=lt.drawRange.start*Nt,Gt=lt.drawRange.count*Nt,Sn=Rt!==null?Rt.start*Nt:0,me=Rt!==null?Rt.count*Nt:1/0,En=Math.max(ms,Sn),qo=Math.min(Fi,ms+Gt,Sn+me)-1,Tn=Math.max(0,qo-En+1);if(Tn!==0){if(dt.isMesh)st.wireframe===!0?(K.setLineWidth(st.wireframeLinewidth*J()),he.setMode(1)):he.setMode(4);else if(dt.isLine){let Bn=st.linewidth;Bn===void 0&&(Bn=1),K.setLineWidth(Bn*J()),dt.isLineSegments?he.setMode(1):dt.isLineLoop?he.setMode(2):he.setMode(3)}else dt.isPoints?he.setMode(0):dt.isSprite&&he.setMode(4);if(dt.isInstancedMesh)he.renderInstances(En,Tn,dt.count);else if(lt.isInstancedBufferGeometry){const Bn=Math.min(lt.instanceCount,lt._maxInstanceCount);he.renderInstances(En,Tn,Bn)}else he.render(En,Tn)}},this.compile=function(C,Z){d=y.get(C),d.init(),p.push(d),C.traverseVisible(function(lt){lt.isLight&&lt.layers.test(Z.layers)&&(d.pushLight(lt),lt.castShadow&&d.pushShadow(lt))}),d.setupLights(x.physicallyCorrectLights),C.traverse(function(lt){const st=lt.material;if(st)if(Array.isArray(st))for(let dt=0;dt<st.length;dt++){const Rt=st[dt];nc(Rt,C,lt)}else nc(st,C,lt)}),p.pop(),d=null};let Xt=null;function Kt(C){Xt&&Xt(C)}function Mn(){Ii.stop()}function wn(){Ii.start()}const Ii=new dx;Ii.setAnimationLoop(Kt),typeof window!="undefined"&&Ii.setContext(window),this.setAnimationLoop=function(C){Xt=C,ft.setAnimationLoop(C),C===null?Ii.stop():Ii.start()},ft.addEventListener("sessionstart",Mn),ft.addEventListener("sessionend",wn),this.render=function(C,Z){if(Z!==void 0&&Z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;C.autoUpdate===!0&&C.updateMatrixWorld(),Z.parent===null&&Z.updateMatrixWorld(),ft.enabled===!0&&ft.isPresenting===!0&&(ft.cameraAutoUpdate===!0&&ft.updateCamera(Z),Z=ft.getCamera()),C.isScene===!0&&C.onBeforeRender(x,C,Z,S),d=y.get(C,p.length),d.init(),p.push(d),yt.multiplyMatrices(Z.projectionMatrix,Z.matrixWorldInverse),ct.setFromProjectionMatrix(yt),et=this.localClippingEnabled,xt=O.init(this.clippingPlanes,et,Z),u=M.get(C,f.length),u.init(),f.push(u),fd(C,Z,0,x.sortObjects),u.finish(),x.sortObjects===!0&&u.sort(T,A),xt===!0&&O.beginShadows();const lt=d.state.shadowsArray;if(B.render(lt,C,Z),xt===!0&&O.endShadows(),this.info.autoReset===!0&&this.info.reset(),X.render(u,C),d.setupLights(x.physicallyCorrectLights),Z.isArrayCamera){const st=Z.cameras;for(let dt=0,Rt=st.length;dt<Rt;dt++){const Dt=st[dt];pd(u,C,Dt,Dt.viewport)}}else pd(u,C,Z);S!==null&&(b.updateMultisampleRenderTarget(S),b.updateRenderTargetMipmap(S)),C.isScene===!0&&C.onAfterRender(x,C,Z),K.buffers.depth.setTest(!0),K.buffers.depth.setMask(!0),K.buffers.color.setMask(!0),K.setPolygonOffset(!1),P.resetDefaultState(),v=-1,E=null,p.pop(),p.length>0?d=p[p.length-1]:d=null,f.pop(),f.length>0?u=f[f.length-1]:u=null};function fd(C,Z,lt,st){if(C.visible===!1)return;if(C.layers.test(Z.layers)){if(C.isGroup)lt=C.renderOrder;else if(C.isLOD)C.autoUpdate===!0&&C.update(Z);else if(C.isLight)d.pushLight(C),C.castShadow&&d.pushShadow(C);else if(C.isSprite){if(!C.frustumCulled||ct.intersectsSprite(C)){st&&gt.setFromMatrixPosition(C.matrixWorld).applyMatrix4(yt);const Dt=Q.update(C),kt=C.material;kt.visible&&u.push(C,Dt,kt,lt,gt.z,null)}}else if((C.isMesh||C.isLine||C.isPoints)&&(C.isSkinnedMesh&&C.skeleton.frame!==at.render.frame&&(C.skeleton.update(),C.skeleton.frame=at.render.frame),!C.frustumCulled||ct.intersectsObject(C))){st&&gt.setFromMatrixPosition(C.matrixWorld).applyMatrix4(yt);const Dt=Q.update(C),kt=C.material;if(Array.isArray(kt)){const Pt=Dt.groups;for(let Ut=0,Nt=Pt.length;Ut<Nt;Ut++){const Ht=Pt[Ut],he=kt[Ht.materialIndex];he&&he.visible&&u.push(C,Dt,he,lt,gt.z,Ht)}}else kt.visible&&u.push(C,Dt,kt,lt,gt.z,null)}}const Rt=C.children;for(let Dt=0,kt=Rt.length;Dt<kt;Dt++)fd(Rt[Dt],Z,lt,st)}function pd(C,Z,lt,st){const dt=C.opaque,Rt=C.transmissive,Dt=C.transparent;d.setupLightsView(lt),Rt.length>0&&sy(dt,Z,lt),st&&K.viewport(R.copy(st)),dt.length>0&&jo(dt,Z,lt),Rt.length>0&&jo(Rt,Z,lt),Dt.length>0&&jo(Dt,Z,lt)}function sy(C,Z,lt){if(ot===null){const Dt=o===!0&&rt.isWebGL2===!0?ru:an;ot=new Dt(1024,1024,{generateMipmaps:!0,type:ut.convert(ss)!==null?ss:$n,minFilter:sl,magFilter:_e,wrapS:Ze,wrapT:Ze,useRenderToTexture:H.has("WEBGL_multisampled_render_to_texture")})}const st=x.getRenderTarget();x.setRenderTarget(ot),x.clear();const dt=x.toneMapping;x.toneMapping=xi,jo(C,Z,lt),x.toneMapping=dt,b.updateMultisampleRenderTarget(ot),b.updateRenderTargetMipmap(ot),x.setRenderTarget(st)}function jo(C,Z,lt){const st=Z.isScene===!0?Z.overrideMaterial:null;for(let dt=0,Rt=C.length;dt<Rt;dt++){const Dt=C[dt],kt=Dt.object,Pt=Dt.geometry,Ut=st===null?Dt.material:st,Nt=Dt.group;kt.layers.test(lt.layers)&&ry(kt,Z,lt,Pt,Ut,Nt)}}function ry(C,Z,lt,st,dt,Rt){C.onBeforeRender(x,Z,lt,st,dt,Rt),C.modelViewMatrix.multiplyMatrices(lt.matrixWorldInverse,C.matrixWorld),C.normalMatrix.getNormalMatrix(C.modelViewMatrix),dt.onBeforeRender(x,Z,lt,st,C,Rt),dt.transparent===!0&&dt.side===is?(dt.side=xe,dt.needsUpdate=!0,x.renderBufferDirect(lt,Z,st,dt,C,Rt),dt.side=mo,dt.needsUpdate=!0,x.renderBufferDirect(lt,Z,st,dt,C,Rt),dt.side=is):x.renderBufferDirect(lt,Z,st,dt,C,Rt),C.onAfterRender(x,Z,lt,st,dt,Rt)}function nc(C,Z,lt){Z.isScene!==!0&&(Z=wt);const st=z.get(C),dt=d.state.lights,Rt=d.state.shadowsArray,Dt=dt.state.version,kt=Y.getParameters(C,dt.state,Rt,Z,lt),Pt=Y.getProgramCacheKey(kt);let Ut=st.programs;st.environment=C.isMeshStandardMaterial?Z.environment:null,st.fog=Z.fog,st.envMap=(C.isMeshStandardMaterial?L:w).get(C.envMap||st.environment),Ut===void 0&&(C.addEventListener("dispose",It),Ut=new Map,st.programs=Ut);let Nt=Ut.get(Pt);if(Nt!==void 0){if(st.currentProgram===Nt&&st.lightsStateVersion===Dt)return md(C,kt),Nt}else kt.uniforms=Y.getUniforms(C),C.onBuild(lt,kt,x),C.onBeforeCompile(kt,x),Nt=Y.acquireProgram(kt,Pt),Ut.set(Pt,Nt),st.uniforms=kt.uniforms;const Ht=st.uniforms;(!C.isShaderMaterial&&!C.isRawShaderMaterial||C.clipping===!0)&&(Ht.clippingPlanes=O.uniform),md(C,kt),st.needsLights=ly(C),st.lightsStateVersion=Dt,st.needsLights&&(Ht.ambientLightColor.value=dt.state.ambient,Ht.lightProbe.value=dt.state.probe,Ht.directionalLights.value=dt.state.directional,Ht.directionalLightShadows.value=dt.state.directionalShadow,Ht.spotLights.value=dt.state.spot,Ht.spotLightShadows.value=dt.state.spotShadow,Ht.rectAreaLights.value=dt.state.rectArea,Ht.ltc_1.value=dt.state.rectAreaLTC1,Ht.ltc_2.value=dt.state.rectAreaLTC2,Ht.pointLights.value=dt.state.point,Ht.pointLightShadows.value=dt.state.pointShadow,Ht.hemisphereLights.value=dt.state.hemi,Ht.directionalShadowMap.value=dt.state.directionalShadowMap,Ht.directionalShadowMatrix.value=dt.state.directionalShadowMatrix,Ht.spotShadowMap.value=dt.state.spotShadowMap,Ht.spotShadowMatrix.value=dt.state.spotShadowMatrix,Ht.pointShadowMap.value=dt.state.pointShadowMap,Ht.pointShadowMatrix.value=dt.state.pointShadowMatrix);const he=Nt.getUniforms(),Fi=Ai.seqWithValue(he.seq,Ht);return st.currentProgram=Nt,st.uniformsList=Fi,Nt}function md(C,Z){const lt=z.get(C);lt.outputEncoding=Z.outputEncoding,lt.instancing=Z.instancing,lt.skinning=Z.skinning,lt.morphTargets=Z.morphTargets,lt.morphNormals=Z.morphNormals,lt.morphTargetsCount=Z.morphTargetsCount,lt.numClippingPlanes=Z.numClippingPlanes,lt.numIntersection=Z.numClipIntersection,lt.vertexAlphas=Z.vertexAlphas,lt.vertexTangents=Z.vertexTangents,lt.toneMapping=Z.toneMapping}function oy(C,Z,lt,st,dt){Z.isScene!==!0&&(Z=wt),b.resetTextureUnits();const Rt=Z.fog,Dt=st.isMeshStandardMaterial?Z.environment:null,kt=S===null?x.outputEncoding:S.texture.encoding,Pt=(st.isMeshStandardMaterial?L:w).get(st.envMap||Dt),Ut=st.vertexColors===!0&&!!lt.attributes.color&&lt.attributes.color.itemSize===4,Nt=!!st.normalMap&&!!lt.attributes.tangent,Ht=!!lt.morphAttributes.position,he=!!lt.morphAttributes.normal,Fi=lt.morphAttributes.position?lt.morphAttributes.position.length:0,ms=st.toneMapped?x.toneMapping:xi,Gt=z.get(st),Sn=d.state.lights;if(xt===!0&&(et===!0||C!==E)){const hn=C===E&&st.id===v;O.setState(st,C,hn)}let me=!1;st.version===Gt.__version?(Gt.needsLights&&Gt.lightsStateVersion!==Sn.state.version||Gt.outputEncoding!==kt||dt.isInstancedMesh&&Gt.instancing===!1||!dt.isInstancedMesh&&Gt.instancing===!0||dt.isSkinnedMesh&&Gt.skinning===!1||!dt.isSkinnedMesh&&Gt.skinning===!0||Gt.envMap!==Pt||st.fog&&Gt.fog!==Rt||Gt.numClippingPlanes!==void 0&&(Gt.numClippingPlanes!==O.numPlanes||Gt.numIntersection!==O.numIntersection)||Gt.vertexAlphas!==Ut||Gt.vertexTangents!==Nt||Gt.morphTargets!==Ht||Gt.morphNormals!==he||Gt.toneMapping!==ms||rt.isWebGL2===!0&&Gt.morphTargetsCount!==Fi)&&(me=!0):(me=!0,Gt.__version=st.version);let En=Gt.currentProgram;me===!0&&(En=nc(st,Z,dt));let qo=!1,Tn=!1,Bn=!1;const Le=En.getUniforms(),Ar=Gt.uniforms;if(K.useProgram(En.program)&&(qo=!0,Tn=!0,Bn=!0),st.id!==v&&(v=st.id,Tn=!0),qo||E!==C){if(Le.setValue(j,"projectionMatrix",C.projectionMatrix),rt.logarithmicDepthBuffer&&Le.setValue(j,"logDepthBufFC",2/(Math.log(C.far+1)/Math.LN2)),E!==C&&(E=C,Tn=!0,Bn=!0),st.isShaderMaterial||st.isMeshPhongMaterial||st.isMeshToonMaterial||st.isMeshStandardMaterial||st.envMap){const hn=Le.map.cameraPosition;hn!==void 0&&hn.setValue(j,gt.setFromMatrixPosition(C.matrixWorld))}(st.isMeshPhongMaterial||st.isMeshToonMaterial||st.isMeshLambertMaterial||st.isMeshBasicMaterial||st.isMeshStandardMaterial||st.isShaderMaterial)&&Le.setValue(j,"isOrthographic",C.isOrthographicCamera===!0),(st.isMeshPhongMaterial||st.isMeshToonMaterial||st.isMeshLambertMaterial||st.isMeshBasicMaterial||st.isMeshStandardMaterial||st.isShaderMaterial||st.isShadowMaterial||dt.isSkinnedMesh)&&Le.setValue(j,"viewMatrix",C.matrixWorldInverse)}if(dt.isSkinnedMesh){Le.setOptional(j,dt,"bindMatrix"),Le.setOptional(j,dt,"bindMatrixInverse");const hn=dt.skeleton;hn&&(rt.floatVertexTextures?(hn.boneTexture===null&&hn.computeBoneTexture(),Le.setValue(j,"boneTexture",hn.boneTexture,b),Le.setValue(j,"boneTextureSize",hn.boneTextureSize)):Le.setOptional(j,hn,"boneMatrices"))}return!!lt&&(lt.morphAttributes.position!==void 0||lt.morphAttributes.normal!==void 0)&&q.update(dt,lt,st,En),(Tn||Gt.receiveShadow!==dt.receiveShadow)&&(Gt.receiveShadow=dt.receiveShadow,Le.setValue(j,"receiveShadow",dt.receiveShadow)),Tn&&(Le.setValue(j,"toneMappingExposure",x.toneMappingExposure),Gt.needsLights&&ay(Ar,Bn),Rt&&st.fog&&nt.refreshFogUniforms(Ar,Rt),nt.refreshMaterialUniforms(Ar,st,N,tt,ot),Ai.upload(j,Gt.uniformsList,Ar,b)),st.isShaderMaterial&&st.uniformsNeedUpdate===!0&&(Ai.upload(j,Gt.uniformsList,Ar,b),st.uniformsNeedUpdate=!1),st.isSpriteMaterial&&Le.setValue(j,"center",dt.center),Le.setValue(j,"modelViewMatrix",dt.modelViewMatrix),Le.setValue(j,"normalMatrix",dt.normalMatrix),Le.setValue(j,"modelMatrix",dt.matrixWorld),En}function ay(C,Z){C.ambientLightColor.needsUpdate=Z,C.lightProbe.needsUpdate=Z,C.directionalLights.needsUpdate=Z,C.directionalLightShadows.needsUpdate=Z,C.pointLights.needsUpdate=Z,C.pointLightShadows.needsUpdate=Z,C.spotLights.needsUpdate=Z,C.spotLightShadows.needsUpdate=Z,C.rectAreaLights.needsUpdate=Z,C.hemisphereLights.needsUpdate=Z}function ly(C){return C.isMeshLambertMaterial||C.isMeshToonMaterial||C.isMeshPhongMaterial||C.isMeshStandardMaterial||C.isShadowMaterial||C.isShaderMaterial&&C.lights===!0}this.getActiveCubeFace=function(){return m},this.getActiveMipmapLevel=function(){return g},this.getRenderTarget=function(){return S},this.setRenderTargetTextures=function(C,Z,lt){z.get(C.texture).__webglTexture=Z,z.get(C.depthTexture).__webglTexture=lt;const st=z.get(C);st.__hasExternalTextures=!0,st.__hasExternalTextures&&(st.__autoAllocateDepthBuffer=lt===void 0,st.__autoAllocateDepthBuffer||C.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),C.useRenderToTexture=!1,C.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(C,Z){const lt=z.get(C);lt.__webglFramebuffer=Z,lt.__useDefaultFramebuffer=Z===void 0},this.setRenderTarget=function(C,Z=0,lt=0){S=C,m=Z,g=lt;let st=!0;if(C){const Pt=z.get(C);Pt.__useDefaultFramebuffer!==void 0?(K.bindFramebuffer(36160,null),st=!1):Pt.__webglFramebuffer===void 0?b.setupRenderTarget(C):Pt.__hasExternalTextures&&b.rebindTextures(C,z.get(C.texture).__webglTexture,z.get(C.depthTexture).__webglTexture)}let dt=null,Rt=!1,Dt=!1;if(C){const Pt=C.texture;(Pt.isDataTexture3D||Pt.isDataTexture2DArray)&&(Dt=!0);const Ut=z.get(C).__webglFramebuffer;C.isWebGLCubeRenderTarget?(dt=Ut[Z],Rt=!0):C.useRenderbuffer?dt=z.get(C).__webglMultisampledFramebuffer:dt=Ut,R.copy(C.viewport),D.copy(C.scissor),$=C.scissorTest}else R.copy(W).multiplyScalar(N).floor(),D.copy(V).multiplyScalar(N).floor(),$=k;if(K.bindFramebuffer(36160,dt)&&rt.drawBuffers&&st){let Pt=!1;if(C)if(C.isWebGLMultipleRenderTargets){const Ut=C.texture;if(U.length!==Ut.length||U[0]!==36064){for(let Nt=0,Ht=Ut.length;Nt<Ht;Nt++)U[Nt]=36064+Nt;U.length=Ut.length,Pt=!0}}else(U.length!==1||U[0]!==36064)&&(U[0]=36064,U.length=1,Pt=!0);else(U.length!==1||U[0]!==1029)&&(U[0]=1029,U.length=1,Pt=!0);Pt&&(rt.isWebGL2?j.drawBuffers(U):H.get("WEBGL_draw_buffers").drawBuffersWEBGL(U))}if(K.viewport(R),K.scissor(D),K.setScissorTest($),Rt){const Pt=z.get(C.texture);j.framebufferTexture2D(36160,36064,34069+Z,Pt.__webglTexture,lt)}else if(Dt){const Pt=z.get(C.texture),Ut=Z||0;j.framebufferTextureLayer(36160,36064,Pt.__webglTexture,lt||0,Ut)}v=-1},this.readRenderTargetPixels=function(C,Z,lt,st,dt,Rt,Dt){if(!(C&&C.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let kt=z.get(C).__webglFramebuffer;if(C.isWebGLCubeRenderTarget&&Dt!==void 0&&(kt=kt[Dt]),kt){K.bindFramebuffer(36160,kt);try{const Pt=C.texture,Ut=Pt.format,Nt=Pt.type;if(Ut!==be&&ut.convert(Ut)!==j.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Ht=Nt===ss&&(H.has("EXT_color_buffer_half_float")||rt.isWebGL2&&H.has("EXT_color_buffer_float"));if(Nt!==$n&&ut.convert(Nt)!==j.getParameter(35738)&&!(Nt===_i&&(rt.isWebGL2||H.has("OES_texture_float")||H.has("WEBGL_color_buffer_float")))&&!Ht){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}j.checkFramebufferStatus(36160)===36053?Z>=0&&Z<=C.width-st&&lt>=0&&lt<=C.height-dt&&j.readPixels(Z,lt,st,dt,ut.convert(Ut),ut.convert(Nt),Rt):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Pt=S!==null?z.get(S).__webglFramebuffer:null;K.bindFramebuffer(36160,Pt)}}},this.copyFramebufferToTexture=function(C,Z,lt=0){if(Z.isFramebufferTexture!==!0){console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");return}const st=Math.pow(2,-lt),dt=Math.floor(Z.image.width*st),Rt=Math.floor(Z.image.height*st);b.setTexture2D(Z,0),j.copyTexSubImage2D(3553,lt,0,0,C.x,C.y,dt,Rt),K.unbindTexture()},this.copyTextureToTexture=function(C,Z,lt,st=0){const dt=Z.image.width,Rt=Z.image.height,Dt=ut.convert(lt.format),kt=ut.convert(lt.type);b.setTexture2D(lt,0),j.pixelStorei(37440,lt.flipY),j.pixelStorei(37441,lt.premultiplyAlpha),j.pixelStorei(3317,lt.unpackAlignment),Z.isDataTexture?j.texSubImage2D(3553,st,C.x,C.y,dt,Rt,Dt,kt,Z.image.data):Z.isCompressedTexture?j.compressedTexSubImage2D(3553,st,C.x,C.y,Z.mipmaps[0].width,Z.mipmaps[0].height,Dt,Z.mipmaps[0].data):j.texSubImage2D(3553,st,C.x,C.y,Dt,kt,Z.image),st===0&&lt.generateMipmaps&&j.generateMipmap(3553),K.unbindTexture()},this.copyTextureToTexture3D=function(C,Z,lt,st,dt=0){if(x.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Rt=C.max.x-C.min.x+1,Dt=C.max.y-C.min.y+1,kt=C.max.z-C.min.z+1,Pt=ut.convert(st.format),Ut=ut.convert(st.type);let Nt;if(st.isDataTexture3D)b.setTexture3D(st,0),Nt=32879;else if(st.isDataTexture2DArray)b.setTexture2DArray(st,0),Nt=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}j.pixelStorei(37440,st.flipY),j.pixelStorei(37441,st.premultiplyAlpha),j.pixelStorei(3317,st.unpackAlignment);const Ht=j.getParameter(3314),he=j.getParameter(32878),Fi=j.getParameter(3316),ms=j.getParameter(3315),Gt=j.getParameter(32877),Sn=lt.isCompressedTexture?lt.mipmaps[0]:lt.image;j.pixelStorei(3314,Sn.width),j.pixelStorei(32878,Sn.height),j.pixelStorei(3316,C.min.x),j.pixelStorei(3315,C.min.y),j.pixelStorei(32877,C.min.z),lt.isDataTexture||lt.isDataTexture3D?j.texSubImage3D(Nt,dt,Z.x,Z.y,Z.z,Rt,Dt,kt,Pt,Ut,Sn.data):lt.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),j.compressedTexSubImage3D(Nt,dt,Z.x,Z.y,Z.z,Rt,Dt,kt,Pt,Sn.data)):j.texSubImage3D(Nt,dt,Z.x,Z.y,Z.z,Rt,Dt,kt,Pt,Ut,Sn),j.pixelStorei(3314,Ht),j.pixelStorei(32878,he),j.pixelStorei(3316,Fi),j.pixelStorei(3315,ms),j.pixelStorei(32877,Gt),dt===0&&st.generateMipmaps&&j.generateMipmap(Nt),K.unbindTexture()},this.initTexture=function(C){b.setTexture2D(C,0),K.unbindTexture()},this.resetState=function(){m=0,g=0,S=null,K.reset(),P.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Qt.prototype.isWebGLRenderer=!0;class xP extends Qt{}xP.prototype.isWebGL1Renderer=!0;class Zx extends qt{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,e){return super.copy(t,e),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const e=super.toJSON(t);return this.fog!==null&&(e.object.fog=this.fog.toJSON()),e}}Zx.prototype.isScene=!0;class Ro{constructor(t,e){this.array=t,this.stride=e,this.count=t!==void 0?t.length/e:0,this.usage=vo,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Fn()}onUploadCallback(){}set needsUpdate(t){t===!0&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.array=new t.array.constructor(t.array),this.count=t.count,this.stride=t.stride,this.usage=t.usage,this}copyAt(t,e,i){t*=this.stride,i*=e.stride;for(let s=0,r=this.stride;s<r;s++)this.array[t+s]=e.array[i+s];return this}set(t,e=0){return this.array.set(t,e),this}clone(t){t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const e=new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]),i=new this.constructor(e,this.stride);return i.setUsage(this.usage),i}onUpload(t){return this.onUploadCallback=t,this}toJSON(t){return t.arrayBuffers===void 0&&(t.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fn()),t.arrayBuffers[this.array.buffer._uuid]===void 0&&(t.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}Ro.prototype.isInterleavedBuffer=!0;const fe=new I;class Po{constructor(t,e,i,s=!1){this.name="",this.data=t,this.itemSize=e,this.offset=i,this.normalized=s===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(t){this.data.needsUpdate=t}applyMatrix4(t){for(let e=0,i=this.data.count;e<i;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.applyMatrix4(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}applyNormalMatrix(t){for(let e=0,i=this.count;e<i;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.applyNormalMatrix(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}transformDirection(t){for(let e=0,i=this.count;e<i;e++)fe.x=this.getX(e),fe.y=this.getY(e),fe.z=this.getZ(e),fe.transformDirection(t),this.setXYZ(e,fe.x,fe.y,fe.z);return this}setX(t,e){return this.data.array[t*this.data.stride+this.offset]=e,this}setY(t,e){return this.data.array[t*this.data.stride+this.offset+1]=e,this}setZ(t,e){return this.data.array[t*this.data.stride+this.offset+2]=e,this}setW(t,e){return this.data.array[t*this.data.stride+this.offset+3]=e,this}getX(t){return this.data.array[t*this.data.stride+this.offset]}getY(t){return this.data.array[t*this.data.stride+this.offset+1]}getZ(t){return this.data.array[t*this.data.stride+this.offset+2]}getW(t){return this.data.array[t*this.data.stride+this.offset+3]}setXY(t,e,i){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this}setXYZ(t,e,i,s){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this}setXYZW(t,e,i,s,r){return t=t*this.data.stride+this.offset,this.data.array[t+0]=e,this.data.array[t+1]=i,this.data.array[t+2]=s,this.data.array[t+3]=r,this}clone(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[s+r])}return new ve(new this.array.constructor(e),this.itemSize,this.normalized)}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.clone(t)),new Po(t.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(t){if(t===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const e=[];for(let i=0;i<this.count;i++){const s=i*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)e.push(this.data.array[s+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:e,normalized:this.normalized}}else return t.interleavedBuffers===void 0&&(t.interleavedBuffers={}),t.interleavedBuffers[this.data.uuid]===void 0&&(t.interleavedBuffers[this.data.uuid]=this.data.toJSON(t)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}Po.prototype.isInterleavedBufferAttribute=!0;class Jx extends Ie{constructor(t){super();this.type="SpriteMaterial",this.color=new Et(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.rotation=t.rotation,this.sizeAttenuation=t.sizeAttenuation,this}}Jx.prototype.isSpriteMaterial=!0;let mr;const Do=new I,gr=new I,xr=new I,_r=new mt,Io=new mt,Kx=new Tt,Nl=new I,Fo=new I,zl=new I,Qx=new mt,Bu=new mt,t_=new mt;class _P extends qt{constructor(t){super();if(this.type="Sprite",mr===void 0){mr=new ae;const e=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),i=new Ro(e,5);mr.setIndex([0,1,2,0,2,3]),mr.setAttribute("position",new Po(i,3,0,!1)),mr.setAttribute("uv",new Po(i,2,3,!1))}this.geometry=mr,this.material=t!==void 0?t:new Jx,this.center=new mt(.5,.5)}raycast(t,e){t.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),gr.setFromMatrixScale(this.matrixWorld),Kx.copy(t.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse,this.matrixWorld),xr.setFromMatrixPosition(this.modelViewMatrix),t.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&gr.multiplyScalar(-xr.z);const i=this.material.rotation;let s,r;i!==0&&(r=Math.cos(i),s=Math.sin(i));const o=this.center;Bl(Nl.set(-.5,-.5,0),xr,o,gr,s,r),Bl(Fo.set(.5,-.5,0),xr,o,gr,s,r),Bl(zl.set(.5,.5,0),xr,o,gr,s,r),Qx.set(0,0),Bu.set(1,0),t_.set(1,1);let a=t.ray.intersectTriangle(Nl,Fo,zl,!1,Do);if(a===null&&(Bl(Fo.set(-.5,.5,0),xr,o,gr,s,r),Bu.set(0,1),a=t.ray.intersectTriangle(Nl,zl,Fo,!1,Do),a===null))return;const l=t.ray.origin.distanceTo(Do);l<t.near||l>t.far||e.push({distance:l,point:Do.clone(),uv:pe.getUV(Do,Nl,Fo,zl,Qx,Bu,t_,new mt),face:null,object:this})}copy(t){return super.copy(t),t.center!==void 0&&this.center.copy(t.center),this.material=t.material,this}}_P.prototype.isSprite=!0;function Bl(n,t,e,i,s,r){_r.subVectors(n,e).addScalar(.5).multiply(i),s!==void 0?(Io.x=r*_r.x-s*_r.y,Io.y=s*_r.x+r*_r.y):Io.copy(_r),n.copy(t),n.x+=Io.x,n.y+=Io.y,n.applyMatrix4(Kx)}const e_=new I,n_=new Zt,i_=new Zt,yP=new I,s_=new Tt;class r_ extends He{constructor(t,e){super(t,e);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Tt,this.bindMatrixInverse=new Tt}copy(t){return super.copy(t),this.bindMode=t.bindMode,this.bindMatrix.copy(t.bindMatrix),this.bindMatrixInverse.copy(t.bindMatrixInverse),this.skeleton=t.skeleton,this}bind(t,e){this.skeleton=t,e===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),e=this.matrixWorld),this.bindMatrix.copy(e),this.bindMatrixInverse.copy(e).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const t=new Zt,e=this.geometry.attributes.skinWeight;for(let i=0,s=e.count;i<s;i++){t.x=e.getX(i),t.y=e.getY(i),t.z=e.getZ(i),t.w=e.getW(i);const r=1/t.manhattanLength();r!==1/0?t.multiplyScalar(r):t.set(1,0,0,0),e.setXYZW(i,t.x,t.y,t.z,t.w)}}updateMatrixWorld(t){super.updateMatrixWorld(t),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(t,e){const i=this.skeleton,s=this.geometry;n_.fromBufferAttribute(s.attributes.skinIndex,t),i_.fromBufferAttribute(s.attributes.skinWeight,t),e_.copy(e).applyMatrix4(this.bindMatrix),e.set(0,0,0);for(let r=0;r<4;r++){const o=i_.getComponent(r);if(o!==0){const a=n_.getComponent(r);s_.multiplyMatrices(i.bones[a].matrixWorld,i.boneInverses[a]),e.addScaledVector(yP.copy(e_).applyMatrix4(s_),o)}}return e.applyMatrix4(this.bindMatrixInverse)}}r_.prototype.isSkinnedMesh=!0;class vP extends qt{constructor(){super();this.type="Bone"}}vP.prototype.isBone=!0;class bP extends Me{constructor(t=null,e=1,i=1,s,r,o,a,l,c=_e,h=_e,u,d){super(null,o,a,l,c,h,s,r,u,d);this.image={data:t,width:e,height:i},this.magFilter=c,this.minFilter=h,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}bP.prototype.isDataTexture=!0;class Hu extends ve{constructor(t,e,i,s=1){typeof i=="number"&&(s=i,i=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(t,e,i);this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}Hu.prototype.isInstancedBufferAttribute=!0;const o_=new Tt,a_=new Tt,Hl=[],Oo=new He;class MP extends He{constructor(t,e,i){super(t,e);this.instanceMatrix=new Hu(new Float32Array(i*16),16),this.instanceColor=null,this.count=i,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),t.instanceColor!==null&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,t*3)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,t*16)}raycast(t,e){const i=this.matrixWorld,s=this.count;if(Oo.geometry=this.geometry,Oo.material=this.material,Oo.material!==void 0)for(let r=0;r<s;r++){this.getMatrixAt(r,o_),a_.multiplyMatrices(i,o_),Oo.matrixWorld=a_,Oo.raycast(t,Hl);for(let o=0,a=Hl.length;o<a;o++){const l=Hl[o];l.instanceId=r,l.object=this,e.push(l)}Hl.length=0}}setColorAt(t,e){this.instanceColor===null&&(this.instanceColor=new Hu(new Float32Array(this.instanceMatrix.count*3),3)),e.toArray(this.instanceColor.array,t*3)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,t*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}MP.prototype.isInstancedMesh=!0;class ko extends Ie{constructor(t){super();this.type="LineBasicMaterial",this.color=new Et(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.linewidth=t.linewidth,this.linecap=t.linecap,this.linejoin=t.linejoin,this}}ko.prototype.isLineBasicMaterial=!0;const l_=new I,c_=new I,h_=new Tt,Uu=new Qs,Ul=new Ks;class Vu extends qt{constructor(t=new ae,e=new ko){super();this.type="Line",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,i=[0];for(let s=1,r=e.count;s<r;s++)l_.fromBufferAttribute(e,s-1),c_.fromBufferAttribute(e,s),i[s]=i[s-1],i[s]+=l_.distanceTo(c_);t.setAttribute("lineDistance",new we(i,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,r=t.params.Line.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Ul.copy(i.boundingSphere),Ul.applyMatrix4(s),Ul.radius+=r,t.ray.intersectsSphere(Ul)===!1)return;h_.copy(s).invert(),Uu.copy(t.ray).applyMatrix4(h_);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new I,h=new I,u=new I,d=new I,f=this.isLineSegments?2:1;if(i.isBufferGeometry){const p=i.index,_=i.attributes.position;if(p!==null){const m=Math.max(0,o.start),g=Math.min(p.count,o.start+o.count);for(let S=m,v=g-1;S<v;S+=f){const E=p.getX(S),R=p.getX(S+1);if(c.fromBufferAttribute(_,E),h.fromBufferAttribute(_,R),Uu.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const $=t.ray.origin.distanceTo(d);$<t.near||$>t.far||e.push({distance:$,point:u.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else{const m=Math.max(0,o.start),g=Math.min(_.count,o.start+o.count);for(let S=m,v=g-1;S<v;S+=f){if(c.fromBufferAttribute(_,S),h.fromBufferAttribute(_,S+1),Uu.distanceSqToSegment(c,h,d,u)>l)continue;d.applyMatrix4(this.matrixWorld);const R=t.ray.origin.distanceTo(d);R<t.near||R>t.far||e.push({distance:R,point:u.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}}else i.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Vu.prototype.isLine=!0;const u_=new I,d_=new I;class Wu extends Vu{constructor(t,e){super(t,e);this.type="LineSegments"}computeLineDistances(){const t=this.geometry;if(t.isBufferGeometry)if(t.index===null){const e=t.attributes.position,i=[];for(let s=0,r=e.count;s<r;s+=2)u_.fromBufferAttribute(e,s),d_.fromBufferAttribute(e,s+1),i[s]=s===0?0:i[s-1],i[s+1]=i[s]+u_.distanceTo(d_);t.setAttribute("lineDistance",new we(i,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else t.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Wu.prototype.isLineSegments=!0;class wP extends Vu{constructor(t,e){super(t,e);this.type="LineLoop"}}wP.prototype.isLineLoop=!0;class f_ extends Ie{constructor(t){super();this.type="PointsMaterial",this.color=new Et(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this}}f_.prototype.isPointsMaterial=!0;const p_=new Tt,Gu=new Qs,Vl=new Ks,Wl=new I;class SP extends qt{constructor(t=new ae,e=new f_){super();this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const i=this.geometry,s=this.matrixWorld,r=t.params.Points.threshold,o=i.drawRange;if(i.boundingSphere===null&&i.computeBoundingSphere(),Vl.copy(i.boundingSphere),Vl.applyMatrix4(s),Vl.radius+=r,t.ray.intersectsSphere(Vl)===!1)return;p_.copy(s).invert(),Gu.copy(t.ray).applyMatrix4(p_);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a;if(i.isBufferGeometry){const c=i.index,u=i.attributes.position;if(c!==null){const d=Math.max(0,o.start),f=Math.min(c.count,o.start+o.count);for(let p=d,x=f;p<x;p++){const _=c.getX(p);Wl.fromBufferAttribute(u,_),m_(Wl,_,l,s,t,e,this)}}else{const d=Math.max(0,o.start),f=Math.min(u.count,o.start+o.count);for(let p=d,x=f;p<x;p++)Wl.fromBufferAttribute(u,p),m_(Wl,p,l,s,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,i=Object.keys(e);if(i.length>0){const s=e[i[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,o=s.length;r<o;r++){const a=s[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}SP.prototype.isPoints=!0;function m_(n,t,e,i,s,r,o){const a=Gu.distanceSqToPoint(n);if(a<e){const l=new I;Gu.closestPointToPoint(n,l),l.applyMatrix4(i);const c=s.ray.origin.distanceTo(l);if(c<s.near||c>s.far)return;r.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:t,face:null,object:o})}}class EP extends Me{constructor(t,e,i,s,r,o,a,l,c){super(t,e,i,s,r,o,a,l,c);this.format=a!==void 0?a:rs,this.minFilter=o!==void 0?o:Be,this.magFilter=r!==void 0?r:Be,this.generateMipmaps=!1;const h=this;function u(){h.needsUpdate=!0,t.requestVideoFrameCallback(u)}"requestVideoFrameCallback"in t&&t.requestVideoFrameCallback(u)}clone(){return new this.constructor(this.image).copy(this)}update(){const t=this.image;"requestVideoFrameCallback"in t===!1&&t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}EP.prototype.isVideoTexture=!0;class TP extends Me{constructor(t,e,i){super({width:t,height:e});this.format=i,this.magFilter=_e,this.minFilter=_e,this.generateMipmaps=!1,this.needsUpdate=!0}}TP.prototype.isFramebufferTexture=!0;class AP extends Me{constructor(t,e,i,s,r,o,a,l,c,h,u,d){super(null,o,a,l,c,h,s,r,u,d);this.image={width:e,height:i},this.mipmaps=t,this.flipY=!1,this.generateMipmaps=!1}}AP.prototype.isCompressedTexture=!0;class CP extends Me{constructor(t,e,i,s,r,o,a,l,c){super(t,e,i,s,r,o,a,l,c);this.needsUpdate=!0}}CP.prototype.isCanvasTexture=!0;new I;new I;new I;new pe;class cn{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(t,e){const i=this.getUtoTmapping(t);return this.getPoint(i,e)}getPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return e}getSpacedPoints(t=5){const e=[];for(let i=0;i<=t;i++)e.push(this.getPointAt(i/t));return e}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const e=[];let i,s=this.getPoint(0),r=0;e.push(0);for(let o=1;o<=t;o++)i=this.getPoint(o/t),r+=i.distanceTo(s),e.push(r),s=i;return this.cacheArcLengths=e,e}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,e){const i=this.getLengths();let s=0;const r=i.length;let o;e?o=e:o=t*i[r-1];let a=0,l=r-1,c;for(;a<=l;)if(s=Math.floor(a+(l-a)/2),c=i[s]-o,c<0)a=s+1;else if(c>0)l=s-1;else{l=s;break}if(s=l,i[s]===o)return s/(r-1);const h=i[s],d=i[s+1]-h,f=(o-h)/d;return(s+f)/(r-1)}getTangent(t,e){const i=1e-4;let s=t-i,r=t+i;s<0&&(s=0),r>1&&(r=1);const o=this.getPoint(s),a=this.getPoint(r),l=e||(o.isVector2?new mt:new I);return l.copy(a).sub(o).normalize(),l}getTangentAt(t,e){const i=this.getUtoTmapping(t);return this.getTangent(i,e)}computeFrenetFrames(t,e){const i=new I,s=[],r=[],o=[],a=new I,l=new Tt;for(let f=0;f<=t;f++){const p=f/t;s[f]=this.getTangentAt(p,new I)}r[0]=new I,o[0]=new I;let c=Number.MAX_VALUE;const h=Math.abs(s[0].x),u=Math.abs(s[0].y),d=Math.abs(s[0].z);h<=c&&(c=h,i.set(1,0,0)),u<=c&&(c=u,i.set(0,1,0)),d<=c&&i.set(0,0,1),a.crossVectors(s[0],i).normalize(),r[0].crossVectors(s[0],a),o[0].crossVectors(s[0],r[0]);for(let f=1;f<=t;f++){if(r[f]=r[f-1].clone(),o[f]=o[f-1].clone(),a.crossVectors(s[f-1],s[f]),a.length()>Number.EPSILON){a.normalize();const p=Math.acos(Je(s[f-1].dot(s[f]),-1,1));r[f].applyMatrix4(l.makeRotationAxis(a,p))}o[f].crossVectors(s[f],r[f])}if(e===!0){let f=Math.acos(Je(r[0].dot(r[t]),-1,1));f/=t,s[0].dot(a.crossVectors(r[0],r[t]))>0&&(f=-f);for(let p=1;p<=t;p++)r[p].applyMatrix4(l.makeRotationAxis(s[p],f*p)),o[p].crossVectors(s[p],r[p])}return{tangents:s,normals:r,binormals:o}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}class Gl extends cn{constructor(t=0,e=0,i=1,s=1,r=0,o=Math.PI*2,a=!1,l=0){super();this.type="EllipseCurve",this.aX=t,this.aY=e,this.xRadius=i,this.yRadius=s,this.aStartAngle=r,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(t,e){const i=e||new mt,s=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const o=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=s;for(;r>s;)r-=s;r<Number.EPSILON&&(o?r=0:r=s),this.aClockwise===!0&&!o&&(r===s?r=-s:r=r-s);const a=this.aStartAngle+t*r;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const h=Math.cos(this.aRotation),u=Math.sin(this.aRotation),d=l-this.aX,f=c-this.aY;l=d*h-f*u+this.aX,c=d*u+f*h+this.aY}return i.set(l,c)}copy(t){return super.copy(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}toJSON(){const t=super.toJSON();return t.aX=this.aX,t.aY=this.aY,t.xRadius=this.xRadius,t.yRadius=this.yRadius,t.aStartAngle=this.aStartAngle,t.aEndAngle=this.aEndAngle,t.aClockwise=this.aClockwise,t.aRotation=this.aRotation,t}fromJSON(t){return super.fromJSON(t),this.aX=t.aX,this.aY=t.aY,this.xRadius=t.xRadius,this.yRadius=t.yRadius,this.aStartAngle=t.aStartAngle,this.aEndAngle=t.aEndAngle,this.aClockwise=t.aClockwise,this.aRotation=t.aRotation,this}}Gl.prototype.isEllipseCurve=!0;class g_ extends Gl{constructor(t,e,i,s,r,o){super(t,e,i,i,s,r,o);this.type="ArcCurve"}}g_.prototype.isArcCurve=!0;function ju(){let n=0,t=0,e=0,i=0;function s(r,o,a,l){n=r,t=a,e=-3*r+3*o-2*a-l,i=2*r-2*o+a+l}return{initCatmullRom:function(r,o,a,l,c){s(o,a,c*(a-r),c*(l-o))},initNonuniformCatmullRom:function(r,o,a,l,c,h,u){let d=(o-r)/c-(a-r)/(c+h)+(a-o)/h,f=(a-o)/h-(l-o)/(h+u)+(l-a)/u;d*=h,f*=h,s(o,a,d,f)},calc:function(r){const o=r*r,a=o*r;return n+t*r+e*o+i*a}}}const jl=new I,qu=new ju,Xu=new ju,$u=new ju;class x_ extends cn{constructor(t=[],e=!1,i="centripetal",s=.5){super();this.type="CatmullRomCurve3",this.points=t,this.closed=e,this.curveType=i,this.tension=s}getPoint(t,e=new I){const i=e,s=this.points,r=s.length,o=(r-(this.closed?0:1))*t;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/r)+1)*r:l===0&&a===r-1&&(a=r-2,l=1);let c,h;this.closed||a>0?c=s[(a-1)%r]:(jl.subVectors(s[0],s[1]).add(s[0]),c=jl);const u=s[a%r],d=s[(a+1)%r];if(this.closed||a+2<r?h=s[(a+2)%r]:(jl.subVectors(s[r-1],s[r-2]).add(s[r-1]),h=jl),this.curveType==="centripetal"||this.curveType==="chordal"){const f=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(u),f),x=Math.pow(u.distanceToSquared(d),f),_=Math.pow(d.distanceToSquared(h),f);x<1e-4&&(x=1),p<1e-4&&(p=x),_<1e-4&&(_=x),qu.initNonuniformCatmullRom(c.x,u.x,d.x,h.x,p,x,_),Xu.initNonuniformCatmullRom(c.y,u.y,d.y,h.y,p,x,_),$u.initNonuniformCatmullRom(c.z,u.z,d.z,h.z,p,x,_)}else this.curveType==="catmullrom"&&(qu.initCatmullRom(c.x,u.x,d.x,h.x,this.tension),Xu.initCatmullRom(c.y,u.y,d.y,h.y,this.tension),$u.initCatmullRom(c.z,u.z,d.z,h.z,this.tension));return i.set(qu.calc(l),Xu.calc(l),$u.calc(l)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t.closed=this.closed,t.curveType=this.curveType,t.tension=this.tension,t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new I().fromArray(s))}return this.closed=t.closed,this.curveType=t.curveType,this.tension=t.tension,this}}x_.prototype.isCatmullRomCurve3=!0;function __(n,t,e,i,s){const r=(i-t)*.5,o=(s-e)*.5,a=n*n,l=n*a;return(2*e-2*i+r+o)*l+(-3*e+3*i-2*r-o)*a+r*n+e}function LP(n,t){const e=1-n;return e*e*t}function RP(n,t){return 2*(1-n)*n*t}function PP(n,t){return n*n*t}function No(n,t,e,i){return LP(n,t)+RP(n,e)+PP(n,i)}function DP(n,t){const e=1-n;return e*e*e*t}function IP(n,t){const e=1-n;return 3*e*e*n*t}function FP(n,t){return 3*(1-n)*n*n*t}function OP(n,t){return n*n*n*t}function zo(n,t,e,i,s){return DP(n,t)+IP(n,e)+FP(n,i)+OP(n,s)}class Yu extends cn{constructor(t=new mt,e=new mt,i=new mt,s=new mt){super();this.type="CubicBezierCurve",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new mt){const i=e,s=this.v0,r=this.v1,o=this.v2,a=this.v3;return i.set(zo(t,s.x,r.x,o.x,a.x),zo(t,s.y,r.y,o.y,a.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}Yu.prototype.isCubicBezierCurve=!0;class y_ extends cn{constructor(t=new I,e=new I,i=new I,s=new I){super();this.type="CubicBezierCurve3",this.v0=t,this.v1=e,this.v2=i,this.v3=s}getPoint(t,e=new I){const i=e,s=this.v0,r=this.v1,o=this.v2,a=this.v3;return i.set(zo(t,s.x,r.x,o.x,a.x),zo(t,s.y,r.y,o.y,a.y),zo(t,s.z,r.z,o.z,a.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this.v3.copy(t.v3),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t.v3=this.v3.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this.v3.fromArray(t.v3),this}}y_.prototype.isCubicBezierCurve3=!0;class ql extends cn{constructor(t=new mt,e=new mt){super();this.type="LineCurve",this.v1=t,this.v2=e}getPoint(t,e=new mt){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}getTangent(t,e){const i=e||new mt;return i.copy(this.v2).sub(this.v1).normalize(),i}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}ql.prototype.isLineCurve=!0;class kP extends cn{constructor(t=new I,e=new I){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=t,this.v2=e}getPoint(t,e=new I){const i=e;return t===1?i.copy(this.v2):(i.copy(this.v2).sub(this.v1),i.multiplyScalar(t).add(this.v1)),i}getPointAt(t,e){return this.getPoint(t,e)}copy(t){return super.copy(t),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}class Zu extends cn{constructor(t=new mt,e=new mt,i=new mt){super();this.type="QuadraticBezierCurve",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new mt){const i=e,s=this.v0,r=this.v1,o=this.v2;return i.set(No(t,s.x,r.x,o.x),No(t,s.y,r.y,o.y)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}Zu.prototype.isQuadraticBezierCurve=!0;class v_ extends cn{constructor(t=new I,e=new I,i=new I){super();this.type="QuadraticBezierCurve3",this.v0=t,this.v1=e,this.v2=i}getPoint(t,e=new I){const i=e,s=this.v0,r=this.v1,o=this.v2;return i.set(No(t,s.x,r.x,o.x),No(t,s.y,r.y,o.y),No(t,s.z,r.z,o.z)),i}copy(t){return super.copy(t),this.v0.copy(t.v0),this.v1.copy(t.v1),this.v2.copy(t.v2),this}toJSON(){const t=super.toJSON();return t.v0=this.v0.toArray(),t.v1=this.v1.toArray(),t.v2=this.v2.toArray(),t}fromJSON(t){return super.fromJSON(t),this.v0.fromArray(t.v0),this.v1.fromArray(t.v1),this.v2.fromArray(t.v2),this}}v_.prototype.isQuadraticBezierCurve3=!0;class Ju extends cn{constructor(t=[]){super();this.type="SplineCurve",this.points=t}getPoint(t,e=new mt){const i=e,s=this.points,r=(s.length-1)*t,o=Math.floor(r),a=r-o,l=s[o===0?o:o-1],c=s[o],h=s[o>s.length-2?s.length-1:o+1],u=s[o>s.length-3?s.length-1:o+2];return i.set(__(a,l.x,c.x,h.x,u.x),__(a,l.y,c.y,h.y,u.y)),i}copy(t){super.copy(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let e=0,i=this.points.length;e<i;e++){const s=this.points[e];t.points.push(s.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let e=0,i=t.points.length;e<i;e++){const s=t.points[e];this.points.push(new mt().fromArray(s))}return this}}Ju.prototype.isSplineCurve=!0;var b_=Object.freeze({__proto__:null,ArcCurve:g_,CatmullRomCurve3:x_,CubicBezierCurve:Yu,CubicBezierCurve3:y_,EllipseCurve:Gl,LineCurve:ql,LineCurve3:kP,QuadraticBezierCurve:Zu,QuadraticBezierCurve3:v_,SplineCurve:Ju});class NP extends cn{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(t){this.curves.push(t)}closePath(){const t=this.curves[0].getPoint(0),e=this.curves[this.curves.length-1].getPoint(1);t.equals(e)||this.curves.push(new ql(e,t))}getPoint(t,e){const i=t*this.getLength(),s=this.getCurveLengths();let r=0;for(;r<s.length;){if(s[r]>=i){const o=s[r]-i,a=this.curves[r],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,e)}r++}return null}getLength(){const t=this.getCurveLengths();return t[t.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const t=[];let e=0;for(let i=0,s=this.curves.length;i<s;i++)e+=this.curves[i].getLength(),t.push(e);return this.cacheLengths=t,t}getSpacedPoints(t=40){const e=[];for(let i=0;i<=t;i++)e.push(this.getPoint(i/t));return this.autoClose&&e.push(e[0]),e}getPoints(t=12){const e=[];let i;for(let s=0,r=this.curves;s<r.length;s++){const o=r[s],a=o&&o.isEllipseCurve?t*2:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?t*o.points.length:t,l=o.getPoints(a);for(let c=0;c<l.length;c++){const h=l[c];i&&i.equals(h)||(e.push(h),i=h)}}return this.autoClose&&e.length>1&&!e[e.length-1].equals(e[0])&&e.push(e[0]),e}copy(t){super.copy(t),this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(s.clone())}return this.autoClose=t.autoClose,this}toJSON(){const t=super.toJSON();t.autoClose=this.autoClose,t.curves=[];for(let e=0,i=this.curves.length;e<i;e++){const s=this.curves[e];t.curves.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.autoClose=t.autoClose,this.curves=[];for(let e=0,i=t.curves.length;e<i;e++){const s=t.curves[e];this.curves.push(new b_[s.type]().fromJSON(s))}return this}}class Ku extends NP{constructor(t){super();this.type="Path",this.currentPoint=new mt,t&&this.setFromPoints(t)}setFromPoints(t){this.moveTo(t[0].x,t[0].y);for(let e=1,i=t.length;e<i;e++)this.lineTo(t[e].x,t[e].y);return this}moveTo(t,e){return this.currentPoint.set(t,e),this}lineTo(t,e){const i=new ql(this.currentPoint.clone(),new mt(t,e));return this.curves.push(i),this.currentPoint.set(t,e),this}quadraticCurveTo(t,e,i,s){const r=new Zu(this.currentPoint.clone(),new mt(t,e),new mt(i,s));return this.curves.push(r),this.currentPoint.set(i,s),this}bezierCurveTo(t,e,i,s,r,o){const a=new Yu(this.currentPoint.clone(),new mt(t,e),new mt(i,s),new mt(r,o));return this.curves.push(a),this.currentPoint.set(r,o),this}splineThru(t){const e=[this.currentPoint.clone()].concat(t),i=new Ju(e);return this.curves.push(i),this.currentPoint.copy(t[t.length-1]),this}arc(t,e,i,s,r,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(t+a,e+l,i,s,r,o),this}absarc(t,e,i,s,r,o){return this.absellipse(t,e,i,i,s,r,o),this}ellipse(t,e,i,s,r,o,a,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(t+c,e+h,i,s,r,o,a,l),this}absellipse(t,e,i,s,r,o,a,l){const c=new Gl(t,e,i,s,r,o,a,l);if(this.curves.length>0){const u=c.getPoint(0);u.equals(this.currentPoint)||this.lineTo(u.x,u.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(t){return super.copy(t),this.currentPoint.copy(t.currentPoint),this}toJSON(){const t=super.toJSON();return t.currentPoint=this.currentPoint.toArray(),t}fromJSON(t){return super.fromJSON(t),this.currentPoint.fromArray(t.currentPoint),this}}class Bo extends Ku{constructor(t){super(t);this.uuid=Fn(),this.type="Shape",this.holes=[]}getPointsHoles(t){const e=[];for(let i=0,s=this.holes.length;i<s;i++)e[i]=this.holes[i].getPoints(t);return e}extractPoints(t){return{shape:this.getPoints(t),holes:this.getPointsHoles(t)}}copy(t){super.copy(t),this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(s.clone())}return this}toJSON(){const t=super.toJSON();t.uuid=this.uuid,t.holes=[];for(let e=0,i=this.holes.length;e<i;e++){const s=this.holes[e];t.holes.push(s.toJSON())}return t}fromJSON(t){super.fromJSON(t),this.uuid=t.uuid,this.holes=[];for(let e=0,i=t.holes.length;e<i;e++){const s=t.holes[e];this.holes.push(new Ku().fromJSON(s))}return this}}const zP={triangulate:function(n,t,e=2){const i=t&&t.length,s=i?t[0]*e:n.length;let r=M_(n,0,s,e,!0);const o=[];if(!r||r.next===r.prev)return o;let a,l,c,h,u,d,f;if(i&&(r=WP(n,t,r,e)),n.length>80*e){a=c=n[0],l=h=n[1];for(let p=e;p<s;p+=e)u=n[p],d=n[p+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>h&&(h=d);f=Math.max(c-a,h-l),f=f!==0?1/f:0}return Ho(r,o,e,a,l,f),o}};function M_(n,t,e,i,s){let r,o;if(s===t2(n,t,e,i)>0)for(r=t;r<e;r+=i)o=E_(r,n[r],n[r+1],o);else for(r=e-i;r>=t;r-=i)o=E_(r,n[r],n[r+1],o);return o&&Xl(o,o.next)&&(Vo(o),o=o.next),o}function Ci(n,t){if(!n)return n;t||(t=n);let e=n,i;do if(i=!1,!e.steiner&&(Xl(e,e.next)||ce(e.prev,e,e.next)===0)){if(Vo(e),e=t=e.prev,e===e.next)break;i=!0}else e=e.next;while(i||e!==t);return t}function Ho(n,t,e,i,s,r,o){if(!n)return;!o&&r&&$P(n,i,s,r);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,r?HP(n,i,s,r):BP(n)){t.push(l.i/e),t.push(n.i/e),t.push(c.i/e),Vo(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=UP(Ci(n),t,e),Ho(n,t,e,i,s,r,2)):o===2&&VP(n,t,e,i,s,r):Ho(Ci(n),t,e,i,s,r,1);break}}}function BP(n){const t=n.prev,e=n,i=n.next;if(ce(t,e,i)>=0)return!1;let s=n.next.next;for(;s!==n.prev;){if(yr(t.x,t.y,e.x,e.y,i.x,i.y,s.x,s.y)&&ce(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function HP(n,t,e,i){const s=n.prev,r=n,o=n.next;if(ce(s,r,o)>=0)return!1;const a=s.x<r.x?s.x<o.x?s.x:o.x:r.x<o.x?r.x:o.x,l=s.y<r.y?s.y<o.y?s.y:o.y:r.y<o.y?r.y:o.y,c=s.x>r.x?s.x>o.x?s.x:o.x:r.x>o.x?r.x:o.x,h=s.y>r.y?s.y>o.y?s.y:o.y:r.y>o.y?r.y:o.y,u=Qu(a,l,t,e,i),d=Qu(c,h,t,e,i);let f=n.prevZ,p=n.nextZ;for(;f&&f.z>=u&&p&&p.z<=d;){if(f!==n.prev&&f!==n.next&&yr(s.x,s.y,r.x,r.y,o.x,o.y,f.x,f.y)&&ce(f.prev,f,f.next)>=0||(f=f.prevZ,p!==n.prev&&p!==n.next&&yr(s.x,s.y,r.x,r.y,o.x,o.y,p.x,p.y)&&ce(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;f&&f.z>=u;){if(f!==n.prev&&f!==n.next&&yr(s.x,s.y,r.x,r.y,o.x,o.y,f.x,f.y)&&ce(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;p&&p.z<=d;){if(p!==n.prev&&p!==n.next&&yr(s.x,s.y,r.x,r.y,o.x,o.y,p.x,p.y)&&ce(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function UP(n,t,e){let i=n;do{const s=i.prev,r=i.next.next;!Xl(s,r)&&w_(s,i,i.next,r)&&Uo(s,r)&&Uo(r,s)&&(t.push(s.i/e),t.push(i.i/e),t.push(r.i/e),Vo(i),Vo(i.next),i=n=r),i=i.next}while(i!==n);return Ci(i)}function VP(n,t,e,i,s,r){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&JP(o,a)){let l=S_(o,a);o=Ci(o,o.next),l=Ci(l,l.next),Ho(o,t,e,i,s,r),Ho(l,t,e,i,s,r);return}a=a.next}o=o.next}while(o!==n)}function WP(n,t,e,i){const s=[];let r,o,a,l,c;for(r=0,o=t.length;r<o;r++)a=t[r]*i,l=r<o-1?t[r+1]*i:n.length,c=M_(n,a,l,i,!1),c===c.next&&(c.steiner=!0),s.push(ZP(c));for(s.sort(GP),r=0;r<s.length;r++)jP(s[r],e),e=Ci(e,e.next);return e}function GP(n,t){return n.x-t.x}function jP(n,t){if(t=qP(n,t),t){const e=S_(t,n);Ci(t,t.next),Ci(e,e.next)}}function qP(n,t){let e=t;const i=n.x,s=n.y;let r=-1/0,o;do{if(s<=e.y&&s>=e.next.y&&e.next.y!==e.y){const d=e.x+(s-e.y)*(e.next.x-e.x)/(e.next.y-e.y);if(d<=i&&d>r){if(r=d,d===i){if(s===e.y)return e;if(s===e.next.y)return e.next}o=e.x<e.next.x?e:e.next}}e=e.next}while(e!==t);if(!o)return null;if(i===r)return o;const a=o,l=o.x,c=o.y;let h=1/0,u;e=o;do i>=e.x&&e.x>=l&&i!==e.x&&yr(s<c?i:r,s,l,c,s<c?r:i,s,e.x,e.y)&&(u=Math.abs(s-e.y)/(i-e.x),Uo(e,n)&&(u<h||u===h&&(e.x>o.x||e.x===o.x&&XP(o,e)))&&(o=e,h=u)),e=e.next;while(e!==a);return o}function XP(n,t){return ce(n.prev,n,t.prev)<0&&ce(t.next,n,n.next)<0}function $P(n,t,e,i){let s=n;do s.z===null&&(s.z=Qu(s.x,s.y,t,e,i)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==n);s.prevZ.nextZ=null,s.prevZ=null,YP(s)}function YP(n){let t,e,i,s,r,o,a,l,c=1;do{for(e=n,n=null,r=null,o=0;e;){for(o++,i=e,a=0,t=0;t<c&&(a++,i=i.nextZ,!!i);t++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||e.z<=i.z)?(s=e,e=e.nextZ,a--):(s=i,i=i.nextZ,l--),r?r.nextZ=s:n=s,s.prevZ=r,r=s;e=i}r.nextZ=null,c*=2}while(o>1);return n}function Qu(n,t,e,i,s){return n=32767*(n-e)*s,t=32767*(t-i)*s,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,n|t<<1}function ZP(n){let t=n,e=n;do(t.x<e.x||t.x===e.x&&t.y<e.y)&&(e=t),t=t.next;while(t!==n);return e}function yr(n,t,e,i,s,r,o,a){return(s-o)*(t-a)-(n-o)*(r-a)>=0&&(n-o)*(i-a)-(e-o)*(t-a)>=0&&(e-o)*(r-a)-(s-o)*(i-a)>=0}function JP(n,t){return n.next.i!==t.i&&n.prev.i!==t.i&&!KP(n,t)&&(Uo(n,t)&&Uo(t,n)&&QP(n,t)&&(ce(n.prev,n,t.prev)||ce(n,t.prev,t))||Xl(n,t)&&ce(n.prev,n,n.next)>0&&ce(t.prev,t,t.next)>0)}function ce(n,t,e){return(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y)}function Xl(n,t){return n.x===t.x&&n.y===t.y}function w_(n,t,e,i){const s=Yl(ce(n,t,e)),r=Yl(ce(n,t,i)),o=Yl(ce(e,i,n)),a=Yl(ce(e,i,t));return!!(s!==r&&o!==a||s===0&&$l(n,e,t)||r===0&&$l(n,i,t)||o===0&&$l(e,n,i)||a===0&&$l(e,t,i))}function $l(n,t,e){return t.x<=Math.max(n.x,e.x)&&t.x>=Math.min(n.x,e.x)&&t.y<=Math.max(n.y,e.y)&&t.y>=Math.min(n.y,e.y)}function Yl(n){return n>0?1:n<0?-1:0}function KP(n,t){let e=n;do{if(e.i!==n.i&&e.next.i!==n.i&&e.i!==t.i&&e.next.i!==t.i&&w_(e,e.next,n,t))return!0;e=e.next}while(e!==n);return!1}function Uo(n,t){return ce(n.prev,n,n.next)<0?ce(n,t,n.next)>=0&&ce(n,n.prev,t)>=0:ce(n,t,n.prev)<0||ce(n,n.next,t)<0}function QP(n,t){let e=n,i=!1;const s=(n.x+t.x)/2,r=(n.y+t.y)/2;do e.y>r!=e.next.y>r&&e.next.y!==e.y&&s<(e.next.x-e.x)*(r-e.y)/(e.next.y-e.y)+e.x&&(i=!i),e=e.next;while(e!==n);return i}function S_(n,t){const e=new td(n.i,n.x,n.y),i=new td(t.i,t.x,t.y),s=n.next,r=t.prev;return n.next=t,t.prev=n,e.next=s,s.prev=e,i.next=e,e.prev=i,r.next=i,i.prev=r,i}function E_(n,t,e,i){const s=new td(n,t,e);return i?(s.next=i.next,s.prev=i,i.next.prev=s,i.next=s):(s.prev=s,s.next=s),s}function Vo(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function td(n,t,e){this.i=n,this.x=t,this.y=e,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function t2(n,t,e,i){let s=0;for(let r=t,o=e-i;r<e;r+=i)s+=(n[o]-n[r])*(n[r+1]+n[o+1]),o=r;return s}class Li{static area(t){const e=t.length;let i=0;for(let s=e-1,r=0;r<e;s=r++)i+=t[s].x*t[r].y-t[r].x*t[s].y;return i*.5}static isClockWise(t){return Li.area(t)<0}static triangulateShape(t,e){const i=[],s=[],r=[];T_(t),A_(i,t);let o=t.length;e.forEach(T_);for(let l=0;l<e.length;l++)s.push(o),o+=e[l].length,A_(i,e[l]);const a=zP.triangulate(i,s);for(let l=0;l<a.length;l+=3)r.push(a.slice(l,l+3));return r}}function T_(n){const t=n.length;t>2&&n[t-1].equals(n[0])&&n.pop()}function A_(n,t){for(let e=0;e<t.length;e++)n.push(t[e].x),n.push(t[e].y)}class vr extends ae{constructor(t=new Bo([new mt(.5,.5),new mt(-.5,.5),new mt(-.5,-.5),new mt(.5,-.5)]),e={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:t,options:e},t=Array.isArray(t)?t:[t];const i=this,s=[],r=[];for(let a=0,l=t.length;a<l;a++){const c=t[a];o(c)}this.setAttribute("position",new we(s,3)),this.setAttribute("uv",new we(r,2)),this.computeVertexNormals();function o(a){const l=[],c=e.curveSegments!==void 0?e.curveSegments:12,h=e.steps!==void 0?e.steps:1;let u=e.depth!==void 0?e.depth:1,d=e.bevelEnabled!==void 0?e.bevelEnabled:!0,f=e.bevelThickness!==void 0?e.bevelThickness:.2,p=e.bevelSize!==void 0?e.bevelSize:f-.1,x=e.bevelOffset!==void 0?e.bevelOffset:0,_=e.bevelSegments!==void 0?e.bevelSegments:3;const m=e.extrudePath,g=e.UVGenerator!==void 0?e.UVGenerator:e2;e.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=e.amount);let S,v=!1,E,R,D,$;m&&(S=m.getSpacedPoints(h),v=!0,d=!1,E=m.computeFrenetFrames(h,!1),R=new I,D=new I,$=new I),d||(_=0,f=0,p=0,x=0);const it=a.extractPoints(c);let tt=it.shape;const N=it.holes;if(!Li.isClockWise(tt)){tt=tt.reverse();for(let z=0,b=N.length;z<b;z++){const w=N[z];Li.isClockWise(w)&&(N[z]=w.reverse())}}const A=Li.triangulateShape(tt,N),W=tt;for(let z=0,b=N.length;z<b;z++){const w=N[z];tt=tt.concat(w)}function V(z,b,w){return b||console.error("THREE.ExtrudeGeometry: vec does not exist"),b.clone().multiplyScalar(w).add(z)}const k=tt.length,U=A.length;function ct(z,b,w){let L,F,G;const Q=z.x-b.x,Y=z.y-b.y,nt=w.x-z.x,M=w.y-z.y,y=Q*Q+Y*Y,O=Q*M-Y*nt;if(Math.abs(O)>Number.EPSILON){const B=Math.sqrt(y),X=Math.sqrt(nt*nt+M*M),q=b.x-Y/B,_t=b.y+Q/B,bt=w.x-M/X,ut=w.y+nt/X,P=((bt-q)*M-(ut-_t)*nt)/(Q*M-Y*nt);L=q+Q*P-z.x,F=_t+Y*P-z.y;const pt=L*L+F*F;if(pt<=2)return new mt(L,F);G=Math.sqrt(pt/2)}else{let B=!1;Q>Number.EPSILON?nt>Number.EPSILON&&(B=!0):Q<-Number.EPSILON?nt<-Number.EPSILON&&(B=!0):Math.sign(Y)===Math.sign(M)&&(B=!0),B?(L=-Y,F=Q,G=Math.sqrt(y)):(L=Q,F=Y,G=Math.sqrt(y/2))}return new mt(L/G,F/G)}const xt=[];for(let z=0,b=W.length,w=b-1,L=z+1;z<b;z++,w++,L++)w===b&&(w=0),L===b&&(L=0),xt[z]=ct(W[z],W[w],W[L]);const et=[];let ot,yt=xt.concat();for(let z=0,b=N.length;z<b;z++){const w=N[z];ot=[];for(let L=0,F=w.length,G=F-1,Q=L+1;L<F;L++,G++,Q++)G===F&&(G=0),Q===F&&(Q=0),ot[L]=ct(w[L],w[G],w[Q]);et.push(ot),yt=yt.concat(ot)}for(let z=0;z<_;z++){const b=z/_,w=f*Math.cos(b*Math.PI/2),L=p*Math.sin(b*Math.PI/2)+x;for(let F=0,G=W.length;F<G;F++){const Q=V(W[F],xt[F],L);ht(Q.x,Q.y,-w)}for(let F=0,G=N.length;F<G;F++){const Q=N[F];ot=et[F];for(let Y=0,nt=Q.length;Y<nt;Y++){const M=V(Q[Y],ot[Y],L);ht(M.x,M.y,-w)}}}const gt=p+x;for(let z=0;z<k;z++){const b=d?V(tt[z],yt[z],gt):tt[z];v?(D.copy(E.normals[0]).multiplyScalar(b.x),R.copy(E.binormals[0]).multiplyScalar(b.y),$.copy(S[0]).add(D).add(R),ht($.x,$.y,$.z)):ht(b.x,b.y,0)}for(let z=1;z<=h;z++)for(let b=0;b<k;b++){const w=d?V(tt[b],yt[b],gt):tt[b];v?(D.copy(E.normals[z]).multiplyScalar(w.x),R.copy(E.binormals[z]).multiplyScalar(w.y),$.copy(S[z]).add(D).add(R),ht($.x,$.y,$.z)):ht(w.x,w.y,u/h*z)}for(let z=_-1;z>=0;z--){const b=z/_,w=f*Math.cos(b*Math.PI/2),L=p*Math.sin(b*Math.PI/2)+x;for(let F=0,G=W.length;F<G;F++){const Q=V(W[F],xt[F],L);ht(Q.x,Q.y,u+w)}for(let F=0,G=N.length;F<G;F++){const Q=N[F];ot=et[F];for(let Y=0,nt=Q.length;Y<nt;Y++){const M=V(Q[Y],ot[Y],L);v?ht(M.x,M.y+S[h-1].y,S[h-1].x+w):ht(M.x,M.y,u+w)}}}wt(),J();function wt(){const z=s.length/3;if(d){let b=0,w=k*b;for(let L=0;L<U;L++){const F=A[L];H(F[2]+w,F[1]+w,F[0]+w)}b=h+_*2,w=k*b;for(let L=0;L<U;L++){const F=A[L];H(F[0]+w,F[1]+w,F[2]+w)}}else{for(let b=0;b<U;b++){const w=A[b];H(w[2],w[1],w[0])}for(let b=0;b<U;b++){const w=A[b];H(w[0]+k*h,w[1]+k*h,w[2]+k*h)}}i.addGroup(z,s.length/3-z,0)}function J(){const z=s.length/3;let b=0;j(W,b),b+=W.length;for(let w=0,L=N.length;w<L;w++){const F=N[w];j(F,b),b+=F.length}i.addGroup(z,s.length/3-z,1)}function j(z,b){let w=z.length;for(;--w>=0;){const L=w;let F=w-1;F<0&&(F=z.length-1);for(let G=0,Q=h+_*2;G<Q;G++){const Y=k*G,nt=k*(G+1),M=b+L+Y,y=b+F+Y,O=b+F+nt,B=b+L+nt;rt(M,y,O,B)}}}function ht(z,b,w){l.push(z),l.push(b),l.push(w)}function H(z,b,w){K(z),K(b),K(w);const L=s.length/3,F=g.generateTopUV(i,s,L-3,L-2,L-1);at(F[0]),at(F[1]),at(F[2])}function rt(z,b,w,L){K(z),K(b),K(L),K(b),K(w),K(L);const F=s.length/3,G=g.generateSideWallUV(i,s,F-6,F-3,F-2,F-1);at(G[0]),at(G[1]),at(G[3]),at(G[1]),at(G[2]),at(G[3])}function K(z){s.push(l[z*3+0]),s.push(l[z*3+1]),s.push(l[z*3+2])}function at(z){r.push(z.x),r.push(z.y)}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes,i=this.parameters.options;return n2(e,i,t)}static fromJSON(t,e){const i=[];for(let r=0,o=t.shapes.length;r<o;r++){const a=e[t.shapes[r]];i.push(a)}const s=t.options.extrudePath;return s!==void 0&&(t.options.extrudePath=new b_[s.type]().fromJSON(s)),new vr(i,t.options)}}const e2={generateTopUV:function(n,t,e,i,s){const r=t[e*3],o=t[e*3+1],a=t[i*3],l=t[i*3+1],c=t[s*3],h=t[s*3+1];return[new mt(r,o),new mt(a,l),new mt(c,h)]},generateSideWallUV:function(n,t,e,i,s,r){const o=t[e*3],a=t[e*3+1],l=t[e*3+2],c=t[i*3],h=t[i*3+1],u=t[i*3+2],d=t[s*3],f=t[s*3+1],p=t[s*3+2],x=t[r*3],_=t[r*3+1],m=t[r*3+2];return Math.abs(a-h)<Math.abs(o-c)?[new mt(o,1-l),new mt(c,1-u),new mt(d,1-p),new mt(x,1-m)]:[new mt(a,1-l),new mt(h,1-u),new mt(f,1-p),new mt(_,1-m)]}};function n2(n,t,e){if(e.shapes=[],Array.isArray(n))for(let i=0,s=n.length;i<s;i++){const r=n[i];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return t.extrudePath!==void 0&&(e.options.extrudePath=t.extrudePath.toJSON()),e}class ed extends ae{constructor(t=new Bo([new mt(0,.5),new mt(-.5,-.5),new mt(.5,-.5)]),e=12){super();this.type="ShapeGeometry",this.parameters={shapes:t,curveSegments:e};const i=[],s=[],r=[],o=[];let a=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let h=0;h<t.length;h++)c(t[h]),this.addGroup(a,l,h),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new we(s,3)),this.setAttribute("normal",new we(r,3)),this.setAttribute("uv",new we(o,2));function c(h){const u=s.length/3,d=h.extractPoints(e);let f=d.shape;const p=d.holes;Li.isClockWise(f)===!1&&(f=f.reverse());for(let _=0,m=p.length;_<m;_++){const g=p[_];Li.isClockWise(g)===!0&&(p[_]=g.reverse())}const x=Li.triangulateShape(f,p);for(let _=0,m=p.length;_<m;_++){const g=p[_];f=f.concat(g)}for(let _=0,m=f.length;_<m;_++){const g=f[_];s.push(g.x,g.y,0),r.push(0,0,1),o.push(g.x,g.y)}for(let _=0,m=x.length;_<m;_++){const g=x[_],S=g[0]+u,v=g[1]+u,E=g[2]+u;i.push(S,v,E),l+=3}}}toJSON(){const t=super.toJSON(),e=this.parameters.shapes;return i2(e,t)}static fromJSON(t,e){const i=[];for(let s=0,r=t.shapes.length;s<r;s++){const o=e[t.shapes[s]];i.push(o)}return new ed(i,t.curveSegments)}}function i2(n,t){if(t.shapes=[],Array.isArray(n))for(let e=0,i=n.length;e<i;e++){const s=n[e];t.shapes.push(s.uuid)}else t.shapes.push(n.uuid);return t}class s2 extends Ie{constructor(t){super();this.type="ShadowMaterial",this.color=new Et(0),this.transparent=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this}}s2.prototype.isShadowMaterial=!0;class C_ extends Ie{constructor(t){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Et(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qs,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={STANDARD:""},this.color.copy(t.color),this.roughness=t.roughness,this.metalness=t.metalness,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.roughnessMap=t.roughnessMap,this.metalnessMap=t.metalnessMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.envMapIntensity=t.envMapIntensity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}C_.prototype.isMeshStandardMaterial=!0;class r2 extends C_{constructor(t){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new mt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Je(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(e){this.ior=(1+.4*e)/(1-.4*e)}}),this.sheenColor=new Et(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Et(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Et(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(t)}get sheen(){return this._sheen}set sheen(t){this._sheen>0!=t>0&&this.version++,this._sheen=t}get clearcoat(){return this._clearcoat}set clearcoat(t){this._clearcoat>0!=t>0&&this.version++,this._clearcoat=t}get transmission(){return this._transmission}set transmission(t){this._transmission>0!=t>0&&this.version++,this._transmission=t}copy(t){return super.copy(t),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=t.clearcoat,this.clearcoatMap=t.clearcoatMap,this.clearcoatRoughness=t.clearcoatRoughness,this.clearcoatRoughnessMap=t.clearcoatRoughnessMap,this.clearcoatNormalMap=t.clearcoatNormalMap,this.clearcoatNormalScale.copy(t.clearcoatNormalScale),this.ior=t.ior,this.sheen=t.sheen,this.sheenColor.copy(t.sheenColor),this.sheenColorMap=t.sheenColorMap,this.sheenRoughness=t.sheenRoughness,this.sheenRoughnessMap=t.sheenRoughnessMap,this.transmission=t.transmission,this.transmissionMap=t.transmissionMap,this.thickness=t.thickness,this.thicknessMap=t.thicknessMap,this.attenuationDistance=t.attenuationDistance,this.attenuationColor.copy(t.attenuationColor),this.specularIntensity=t.specularIntensity,this.specularIntensityMap=t.specularIntensityMap,this.specularColor.copy(t.specularColor),this.specularColorMap=t.specularColorMap,this}}r2.prototype.isMeshPhysicalMaterial=!0;class o2 extends Ie{constructor(t){super();this.type="MeshPhongMaterial",this.color=new Et(16777215),this.specular=new Et(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qs,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=nl,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.specular.copy(t.specular),this.shininess=t.shininess,this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.flatShading=t.flatShading,this}}o2.prototype.isMeshPhongMaterial=!0;class a2 extends Ie{constructor(t){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Et(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qs,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.gradientMap=t.gradientMap,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}a2.prototype.isMeshToonMaterial=!0;class l2 extends Ie{constructor(t){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qs,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.flatShading=t.flatShading,this}}l2.prototype.isMeshNormalMaterial=!0;class c2 extends Ie{constructor(t){super();this.type="MeshLambertMaterial",this.color=new Et(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Et(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=nl,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.emissive.copy(t.emissive),this.emissiveMap=t.emissiveMap,this.emissiveIntensity=t.emissiveIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this}}c2.prototype.isMeshLambertMaterial=!0;class h2 extends Ie{constructor(t){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Et(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=qs,this.normalScale=new mt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(t)}copy(t){return super.copy(t),this.defines={MATCAP:""},this.color.copy(t.color),this.matcap=t.matcap,this.map=t.map,this.bumpMap=t.bumpMap,this.bumpScale=t.bumpScale,this.normalMap=t.normalMap,this.normalMapType=t.normalMapType,this.normalScale.copy(t.normalScale),this.displacementMap=t.displacementMap,this.displacementScale=t.displacementScale,this.displacementBias=t.displacementBias,this.alphaMap=t.alphaMap,this.flatShading=t.flatShading,this}}h2.prototype.isMeshMatcapMaterial=!0;class u2 extends ko{constructor(t){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(t)}copy(t){return super.copy(t),this.scale=t.scale,this.dashSize=t.dashSize,this.gapSize=t.gapSize,this}}u2.prototype.isLineDashedMaterial=!0;const le={arraySlice:function(n,t,e){return le.isTypedArray(n)?new n.constructor(n.subarray(t,e!==void 0?e:n.length)):n.slice(t,e)},convertArray:function(n,t,e){return!n||!e&&n.constructor===t?n:typeof t.BYTES_PER_ELEMENT=="number"?new t(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function t(s,r){return n[s]-n[r]}const e=n.length,i=new Array(e);for(let s=0;s!==e;++s)i[s]=s;return i.sort(t),i},sortedArray:function(n,t,e){const i=n.length,s=new n.constructor(i);for(let r=0,o=0;o!==i;++r){const a=e[r]*t;for(let l=0;l!==t;++l)s[o++]=n[a+l]}return s},flattenJSON:function(n,t,e,i){let s=1,r=n[0];for(;r!==void 0&&r[i]===void 0;)r=n[s++];if(r===void 0)return;let o=r[i];if(o!==void 0)if(Array.isArray(o))do o=r[i],o!==void 0&&(t.push(r.time),e.push.apply(e,o)),r=n[s++];while(r!==void 0);else if(o.toArray!==void 0)do o=r[i],o!==void 0&&(t.push(r.time),o.toArray(e,e.length)),r=n[s++];while(r!==void 0);else do o=r[i],o!==void 0&&(t.push(r.time),e.push(o)),r=n[s++];while(r!==void 0)},subclip:function(n,t,e,i,s=30){const r=n.clone();r.name=t;const o=[];for(let l=0;l<r.tracks.length;++l){const c=r.tracks[l],h=c.getValueSize(),u=[],d=[];for(let f=0;f<c.times.length;++f){const p=c.times[f]*s;if(!(p<e||p>=i)){u.push(c.times[f]);for(let x=0;x<h;++x)d.push(c.values[f*h+x])}}u.length!==0&&(c.times=le.convertArray(u,c.times.constructor),c.values=le.convertArray(d,c.values.constructor),o.push(c))}r.tracks=o;let a=1/0;for(let l=0;l<r.tracks.length;++l)a>r.tracks[l].times[0]&&(a=r.tracks[l].times[0]);for(let l=0;l<r.tracks.length;++l)r.tracks[l].shift(-1*a);return r.resetDuration(),r},makeClipAdditive:function(n,t=0,e=n,i=30){i<=0&&(i=30);const s=e.tracks.length,r=t/i;for(let o=0;o<s;++o){const a=e.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(m){return m.name===a.name&&m.ValueTypeName===l});if(c===void 0)continue;let h=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(h=u/3);let d=0;const f=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=f/3);const p=a.times.length-1;let x;if(r<=a.times[0]){const m=h,g=u-h;x=le.arraySlice(a.values,m,g)}else if(r>=a.times[p]){const m=p*u+h,g=m+u-h;x=le.arraySlice(a.values,m,g)}else{const m=a.createInterpolant(),g=h,S=u-h;m.evaluate(r),x=le.arraySlice(m.resultBuffer,g,S)}l==="quaternion"&&new Ge().fromArray(x).normalize().conjugate().toArray(x);const _=c.times.length;for(let m=0;m<_;++m){const g=m*f+d;if(l==="quaternion")Ge.multiplyQuaternionsFlat(c.values,g,x,0,c.values,g);else{const S=f-d*2;for(let v=0;v<S;++v)c.values[g+v]-=x[v]}}}return n.blendMode=qg,n}};class Ri{constructor(t,e,i,s){this.parameterPositions=t,this._cachedIndex=0,this.resultBuffer=s!==void 0?s:new e.constructor(i),this.sampleValues=e,this.valueSize=i,this.settings=null,this.DefaultSettings_={}}evaluate(t){const e=this.parameterPositions;let i=this._cachedIndex,s=e[i],r=e[i-1];t:{e:{let o;n:{i:if(!(t<s)){for(let a=i+2;;){if(s===void 0){if(t<r)break i;return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,t,r)}if(i===a)break;if(r=s,s=e[++i],t<s)break e}o=e.length;break n}if(!(t>=r)){const a=e[1];t<a&&(i=2,r=a);for(let l=i-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,s);if(i===l)break;if(s=r,r=e[--i-1],t>=r)break e}o=i,i=0;break n}break t}for(;i<o;){const a=i+o>>>1;t<e[a]?o=a:i=a+1}if(s=e[i],r=e[i-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,t,s);if(s===void 0)return i=e.length,this._cachedIndex=i,this.afterEnd_(i-1,r,t)}this._cachedIndex=i,this.intervalChanged_(i,r,s)}return this.interpolate_(i,r,t,s)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(t){const e=this.resultBuffer,i=this.sampleValues,s=this.valueSize,r=t*s;for(let o=0;o!==s;++o)e[o]=i[r+o];return e}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Ri.prototype.beforeStart_=Ri.prototype.copySampleValue_;Ri.prototype.afterEnd_=Ri.prototype.copySampleValue_;class d2 extends Ri{constructor(t,e,i,s){super(t,e,i,s);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ws,endingEnd:Ws}}intervalChanged_(t,e,i){const s=this.parameterPositions;let r=t-2,o=t+1,a=s[r],l=s[o];if(a===void 0)switch(this.getSettings_().endingStart){case Gs:r=t,a=2*e-i;break;case ll:r=s.length-2,a=e+s[r]-s[r+1];break;default:r=t,a=i}if(l===void 0)switch(this.getSettings_().endingEnd){case Gs:o=t,l=2*i-e;break;case ll:o=1,l=i+s[1]-s[0];break;default:o=t-1,l=e}const c=(i-e)*.5,h=this.valueSize;this._weightPrev=c/(e-a),this._weightNext=c/(l-i),this._offsetPrev=r*h,this._offsetNext=o*h}interpolate_(t,e,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=t*a,c=l-a,h=this._offsetPrev,u=this._offsetNext,d=this._weightPrev,f=this._weightNext,p=(i-e)/(s-e),x=p*p,_=x*p,m=-d*_+2*d*x-d*p,g=(1+d)*_+(-1.5-2*d)*x+(-.5+d)*p+1,S=(-1-f)*_+(1.5+f)*x+.5*p,v=f*_-f*x;for(let E=0;E!==a;++E)r[E]=m*o[h+E]+g*o[c+E]+S*o[l+E]+v*o[u+E];return r}}class L_ extends Ri{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=t*a,c=l-a,h=(i-e)/(s-e),u=1-h;for(let d=0;d!==a;++d)r[d]=o[c+d]*u+o[l+d]*h;return r}}class f2 extends Ri{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t){return this.copySampleValue_(t-1)}}class Nn{constructor(t,e,i,s){if(t===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(e===void 0||e.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+t);this.name=t,this.times=le.convertArray(e,this.TimeBufferType),this.values=le.convertArray(i,this.ValueBufferType),this.setInterpolation(s||this.DefaultInterpolation)}static toJSON(t){const e=t.constructor;let i;if(e.toJSON!==this.toJSON)i=e.toJSON(t);else{i={name:t.name,times:le.convertArray(t.times,Array),values:le.convertArray(t.values,Array)};const s=t.getInterpolation();s!==t.DefaultInterpolation&&(i.interpolation=s)}return i.type=t.ValueTypeName,i}InterpolantFactoryMethodDiscrete(t){return new f2(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodLinear(t){return new L_(this.times,this.values,this.getValueSize(),t)}InterpolantFactoryMethodSmooth(t){return new d2(this.times,this.values,this.getValueSize(),t)}setInterpolation(t){let e;switch(t){case ol:e=this.InterpolantFactoryMethodDiscrete;break;case al:e=this.InterpolantFactoryMethodLinear;break;case Kh:e=this.InterpolantFactoryMethodSmooth;break}if(e===void 0){const i="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(t!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(i);return console.warn("THREE.KeyframeTrack:",i),this}return this.createInterpolant=e,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return ol;case this.InterpolantFactoryMethodLinear:return al;case this.InterpolantFactoryMethodSmooth:return Kh}}getValueSize(){return this.values.length/this.times.length}shift(t){if(t!==0){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]+=t}return this}scale(t){if(t!==1){const e=this.times;for(let i=0,s=e.length;i!==s;++i)e[i]*=t}return this}trim(t,e){const i=this.times,s=i.length;let r=0,o=s-1;for(;r!==s&&i[r]<t;)++r;for(;o!==-1&&i[o]>e;)--o;if(++o,r!==0||o!==s){r>=o&&(o=Math.max(o,1),r=o-1);const a=this.getValueSize();this.times=le.arraySlice(i,r,o),this.values=le.arraySlice(this.values,r*a,o*a)}return this}validate(){let t=!0;const e=this.getValueSize();e-Math.floor(e)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),t=!1);const i=this.times,s=this.values,r=i.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),t=!1);let o=null;for(let a=0;a!==r;a++){const l=i[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),t=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),t=!1;break}o=l}if(s!==void 0&&le.isTypedArray(s))for(let a=0,l=s.length;a!==l;++a){const c=s[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),t=!1;break}}return t}optimize(){const t=le.arraySlice(this.times),e=le.arraySlice(this.values),i=this.getValueSize(),s=this.getInterpolation()===Kh,r=t.length-1;let o=1;for(let a=1;a<r;++a){let l=!1;const c=t[a],h=t[a+1];if(c!==h&&(a!==1||c!==t[0]))if(s)l=!0;else{const u=a*i,d=u-i,f=u+i;for(let p=0;p!==i;++p){const x=e[u+p];if(x!==e[d+p]||x!==e[f+p]){l=!0;break}}}if(l){if(a!==o){t[o]=t[a];const u=a*i,d=o*i;for(let f=0;f!==i;++f)e[d+f]=e[u+f]}++o}}if(r>0){t[o]=t[r];for(let a=r*i,l=o*i,c=0;c!==i;++c)e[l+c]=e[a+c];++o}return o!==t.length?(this.times=le.arraySlice(t,0,o),this.values=le.arraySlice(e,0,o*i)):(this.times=t,this.values=e),this}clone(){const t=le.arraySlice(this.times,0),e=le.arraySlice(this.values,0),i=this.constructor,s=new i(this.name,t,e);return s.createInterpolant=this.createInterpolant,s}}Nn.prototype.TimeBufferType=Float32Array;Nn.prototype.ValueBufferType=Float32Array;Nn.prototype.DefaultInterpolation=al;class br extends Nn{}br.prototype.ValueTypeName="bool";br.prototype.ValueBufferType=Array;br.prototype.DefaultInterpolation=ol;br.prototype.InterpolantFactoryMethodLinear=void 0;br.prototype.InterpolantFactoryMethodSmooth=void 0;class R_ extends Nn{}R_.prototype.ValueTypeName="color";class Zl extends Nn{}Zl.prototype.ValueTypeName="number";class p2 extends Ri{constructor(t,e,i,s){super(t,e,i,s)}interpolate_(t,e,i,s){const r=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(i-e)/(s-e);let c=t*a;for(let h=c+a;c!==h;c+=4)Ge.slerpFlat(r,0,o,c-a,o,c,l);return r}}class Wo extends Nn{InterpolantFactoryMethodLinear(t){return new p2(this.times,this.values,this.getValueSize(),t)}}Wo.prototype.ValueTypeName="quaternion";Wo.prototype.DefaultInterpolation=al;Wo.prototype.InterpolantFactoryMethodSmooth=void 0;class Mr extends Nn{}Mr.prototype.ValueTypeName="string";Mr.prototype.ValueBufferType=Array;Mr.prototype.DefaultInterpolation=ol;Mr.prototype.InterpolantFactoryMethodLinear=void 0;Mr.prototype.InterpolantFactoryMethodSmooth=void 0;class Jl extends Nn{}Jl.prototype.ValueTypeName="vector";class P_{constructor(t,e=-1,i,s=Qh){this.name=t,this.tracks=i,this.duration=e,this.blendMode=s,this.uuid=Fn(),this.duration<0&&this.resetDuration()}static parse(t){const e=[],i=t.tracks,s=1/(t.fps||1);for(let o=0,a=i.length;o!==a;++o)e.push(g2(i[o]).scale(s));const r=new this(t.name,t.duration,e,t.blendMode);return r.uuid=t.uuid,r}static toJSON(t){const e=[],i=t.tracks,s={name:t.name,duration:t.duration,tracks:e,uuid:t.uuid,blendMode:t.blendMode};for(let r=0,o=i.length;r!==o;++r)e.push(Nn.toJSON(i[r]));return s}static CreateFromMorphTargetSequence(t,e,i,s){const r=e.length,o=[];for(let a=0;a<r;a++){let l=[],c=[];l.push((a+r-1)%r,a,(a+1)%r),c.push(0,1,0);const h=le.getKeyframeOrder(l);l=le.sortedArray(l,1,h),c=le.sortedArray(c,1,h),!s&&l[0]===0&&(l.push(r),c.push(c[0])),o.push(new Zl(".morphTargetInfluences["+e[a].name+"]",l,c).scale(1/i))}return new this(t,-1,o)}static findByName(t,e){let i=t;if(!Array.isArray(t)){const s=t;i=s.geometry&&s.geometry.animations||s.animations}for(let s=0;s<i.length;s++)if(i[s].name===e)return i[s];return null}static CreateClipsFromMorphTargetSequences(t,e,i){const s={},r=/^([\w-]*?)([\d]+)$/;for(let a=0,l=t.length;a<l;a++){const c=t[a],h=c.name.match(r);if(h&&h.length>1){const u=h[1];let d=s[u];d||(s[u]=d=[]),d.push(c)}}const o=[];for(const a in s)o.push(this.CreateFromMorphTargetSequence(a,s[a],e,i));return o}static parseAnimation(t,e){if(!t)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const i=function(u,d,f,p,x){if(f.length!==0){const _=[],m=[];le.flattenJSON(f,_,m,p),_.length!==0&&x.push(new u(d,_,m))}},s=[],r=t.name||"default",o=t.fps||30,a=t.blendMode;let l=t.length||-1;const c=t.hierarchy||[];for(let u=0;u<c.length;u++){const d=c[u].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const f={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let x=0;x<d[p].morphTargets.length;x++)f[d[p].morphTargets[x]]=-1;for(const x in f){const _=[],m=[];for(let g=0;g!==d[p].morphTargets.length;++g){const S=d[p];_.push(S.time),m.push(S.morphTarget===x?1:0)}s.push(new Zl(".morphTargetInfluence["+x+"]",_,m))}l=f.length*(o||1)}else{const f=".bones["+e[u].name+"]";i(Jl,f+".position",d,"pos",s),i(Wo,f+".quaternion",d,"rot",s),i(Jl,f+".scale",d,"scl",s)}}return s.length===0?null:new this(r,l,s,a)}resetDuration(){const t=this.tracks;let e=0;for(let i=0,s=t.length;i!==s;++i){const r=this.tracks[i];e=Math.max(e,r.times[r.times.length-1])}return this.duration=e,this}trim(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].trim(0,this.duration);return this}validate(){let t=!0;for(let e=0;e<this.tracks.length;e++)t=t&&this.tracks[e].validate();return t}optimize(){for(let t=0;t<this.tracks.length;t++)this.tracks[t].optimize();return this}clone(){const t=[];for(let e=0;e<this.tracks.length;e++)t.push(this.tracks[e].clone());return new this.constructor(this.name,this.duration,t,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function m2(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Zl;case"vector":case"vector2":case"vector3":case"vector4":return Jl;case"color":return R_;case"quaternion":return Wo;case"bool":case"boolean":return br;case"string":return Mr}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function g2(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=m2(n.type);if(n.times===void 0){const e=[],i=[];le.flattenJSON(n.keys,e,i,"value"),n.times=e,n.values=i}return t.parse!==void 0?t.parse(n):new t(n.name,n.times,n.values,n.interpolation)}const wr={enabled:!1,files:{},add:function(n,t){this.enabled!==!1&&(this.files[n]=t)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class x2{constructor(t,e,i){const s=this;let r=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=t,this.onProgress=e,this.onError=i,this.itemStart=function(h){a++,r===!1&&s.onStart!==void 0&&s.onStart(h,o,a),r=!0},this.itemEnd=function(h){o++,s.onProgress!==void 0&&s.onProgress(h,o,a),o===a&&(r=!1,s.onLoad!==void 0&&s.onLoad())},this.itemError=function(h){s.onError!==void 0&&s.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,u){return c.push(h,u),this},this.removeHandler=function(h){const u=c.indexOf(h);return u!==-1&&c.splice(u,2),this},this.getHandler=function(h){for(let u=0,d=c.length;u<d;u+=2){const f=c[u],p=c[u+1];if(f.global&&(f.lastIndex=0),f.test(h))return p}return null}}}const _2=new x2;class Pi{constructor(t){this.manager=t!==void 0?t:_2,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(t,e){const i=this;return new Promise(function(s,r){i.load(t,s,e,r)})}parse(){}setCrossOrigin(t){return this.crossOrigin=t,this}setWithCredentials(t){return this.withCredentials=t,this}setPath(t){return this.path=t,this}setResourcePath(t){return this.resourcePath=t,this}setRequestHeader(t){return this.requestHeader=t,this}}const ei={};class y2 extends Pi{constructor(t){super(t)}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=wr.get(t);if(r!==void 0)return this.manager.itemStart(t),setTimeout(()=>{e&&e(r),this.manager.itemEnd(t)},0),r;if(ei[t]!==void 0){ei[t].push({onLoad:e,onProgress:i,onError:s});return}ei[t]=[],ei[t].push({onLoad:e,onProgress:i,onError:s});const o=new Request(t,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(o).then(a=>{if(a.status===200||a.status===0){if(a.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream=="undefined"||a.body.getReader===void 0)return a;const l=ei[t],c=a.body.getReader(),h=a.headers.get("Content-Length"),u=h?parseInt(h):0,d=u!==0;let f=0;const p=new ReadableStream({start(x){_();function _(){c.read().then(({done:m,value:g})=>{if(m)x.close();else{f+=g.byteLength;const S=new ProgressEvent("progress",{lengthComputable:d,loaded:f,total:u});for(let v=0,E=l.length;v<E;v++){const R=l[v];R.onProgress&&R.onProgress(S)}x.enqueue(g),_()}})}}});return new Response(p)}else throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`)}).then(a=>{switch(this.responseType){case"arraybuffer":return a.arrayBuffer();case"blob":return a.blob();case"document":return a.text().then(l=>new DOMParser().parseFromString(l,this.mimeType));case"json":return a.json();default:return a.text()}}).then(a=>{wr.add(t,a);const l=ei[t];delete ei[t];for(let c=0,h=l.length;c<h;c++){const u=l[c];u.onLoad&&u.onLoad(a)}}).catch(a=>{const l=ei[t];if(l===void 0)throw this.manager.itemError(t),a;delete ei[t];for(let c=0,h=l.length;c<h;c++){const u=l[c];u.onError&&u.onError(a)}this.manager.itemError(t)}).finally(()=>{this.manager.itemEnd(t)}),this.manager.itemStart(t)}setResponseType(t){return this.responseType=t,this}setMimeType(t){return this.mimeType=t,this}}class D_ extends Pi{constructor(t){super(t)}load(t,e,i,s){this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=wr.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const a=hl("img");function l(){h(),wr.add(t,this),e&&e(this),r.manager.itemEnd(t)}function c(u){h(),s&&s(u),r.manager.itemError(t),r.manager.itemEnd(t)}function h(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),t.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),r.manager.itemStart(t),a.src=t,a}}class v2 extends Pi{constructor(t){super(t)}load(t,e,i,s){const r=new Rl,o=new D_(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(t[c],function(h){r.images[c]=h,a++,a===6&&(r.needsUpdate=!0,e&&e(r))},void 0,s)}for(let c=0;c<t.length;++c)l(c);return r}}class b2 extends Pi{constructor(t){super(t)}load(t,e,i,s){const r=new Me,o=new D_(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(t,function(a){r.image=a,r.needsUpdate=!0,e!==void 0&&e(r)},i,s),r}}class zn extends qt{constructor(t,e=1){super();this.type="Light",this.color=new Et(t),this.intensity=e}dispose(){}copy(t){return super.copy(t),this.color.copy(t.color),this.intensity=t.intensity,this}toJSON(t){const e=super.toJSON(t);return e.object.color=this.color.getHex(),e.object.intensity=this.intensity,this.groundColor!==void 0&&(e.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(e.object.distance=this.distance),this.angle!==void 0&&(e.object.angle=this.angle),this.decay!==void 0&&(e.object.decay=this.decay),this.penumbra!==void 0&&(e.object.penumbra=this.penumbra),this.shadow!==void 0&&(e.object.shadow=this.shadow.toJSON()),e}}zn.prototype.isLight=!0;class M2 extends zn{constructor(t,e,i){super(t,i);this.type="HemisphereLight",this.position.copy(qt.DefaultUp),this.updateMatrix(),this.groundColor=new Et(e)}copy(t){return zn.prototype.copy.call(this,t),this.groundColor.copy(t.groundColor),this}}M2.prototype.isHemisphereLight=!0;const I_=new Tt,F_=new I,O_=new I;class nd{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new mt(512,512),this.map=null,this.mapPass=null,this.matrix=new Tt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new To,this._frameExtents=new mt(1,1),this._viewportCount=1,this._viewports=[new Zt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const e=this.camera,i=this.matrix;F_.setFromMatrixPosition(t.matrixWorld),e.position.copy(F_),O_.setFromMatrixPosition(t.target.matrixWorld),e.lookAt(O_),e.updateMatrixWorld(),I_.multiplyMatrices(e.projectionMatrix,e.matrixWorldInverse),this._frustum.setFromProjectionMatrix(I_),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(e.projectionMatrix),i.multiply(e.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}class k_ extends nd{constructor(){super(new je(50,1,.5,500));this.focus=1}updateMatrices(t){const e=this.camera,i=nu*2*t.angle*this.focus,s=this.mapSize.width/this.mapSize.height,r=t.distance||e.far;(i!==e.fov||s!==e.aspect||r!==e.far)&&(e.fov=i,e.aspect=s,e.far=r,e.updateProjectionMatrix()),super.updateMatrices(t)}copy(t){return super.copy(t),this.focus=t.focus,this}}k_.prototype.isSpotLightShadow=!0;class w2 extends zn{constructor(t,e,i=0,s=Math.PI/3,r=0,o=1){super(t,e);this.type="SpotLight",this.position.copy(qt.DefaultUp),this.updateMatrix(),this.target=new qt,this.distance=i,this.angle=s,this.penumbra=r,this.decay=o,this.shadow=new k_}get power(){return this.intensity*Math.PI}set power(t){this.intensity=t/Math.PI}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.angle=t.angle,this.penumbra=t.penumbra,this.decay=t.decay,this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}w2.prototype.isSpotLight=!0;const N_=new Tt,Go=new I,id=new I;class z_ extends nd{constructor(){super(new je(90,1,.5,500));this._frameExtents=new mt(4,2),this._viewportCount=6,this._viewports=[new Zt(2,1,1,1),new Zt(0,1,1,1),new Zt(3,1,1,1),new Zt(1,1,1,1),new Zt(3,0,1,1),new Zt(1,0,1,1)],this._cubeDirections=[new I(1,0,0),new I(-1,0,0),new I(0,0,1),new I(0,0,-1),new I(0,1,0),new I(0,-1,0)],this._cubeUps=[new I(0,1,0),new I(0,1,0),new I(0,1,0),new I(0,1,0),new I(0,0,1),new I(0,0,-1)]}updateMatrices(t,e=0){const i=this.camera,s=this.matrix,r=t.distance||i.far;r!==i.far&&(i.far=r,i.updateProjectionMatrix()),Go.setFromMatrixPosition(t.matrixWorld),i.position.copy(Go),id.copy(i.position),id.add(this._cubeDirections[e]),i.up.copy(this._cubeUps[e]),i.lookAt(id),i.updateMatrixWorld(),s.makeTranslation(-Go.x,-Go.y,-Go.z),N_.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(N_)}}z_.prototype.isPointLightShadow=!0;class S2 extends zn{constructor(t,e,i=0,s=1){super(t,e);this.type="PointLight",this.distance=i,this.decay=s,this.shadow=new z_}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}S2.prototype.isPointLight=!0;class B_ extends nd{constructor(){super(new Lu(-5,5,5,-5,.5,500))}}B_.prototype.isDirectionalLightShadow=!0;class E2 extends zn{constructor(t,e){super(t,e);this.type="DirectionalLight",this.position.copy(qt.DefaultUp),this.updateMatrix(),this.target=new qt,this.shadow=new B_}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.target=t.target.clone(),this.shadow=t.shadow.clone(),this}}E2.prototype.isDirectionalLight=!0;class T2 extends zn{constructor(t,e){super(t,e);this.type="AmbientLight"}}T2.prototype.isAmbientLight=!0;class A2 extends zn{constructor(t,e,i=10,s=10){super(t,e);this.type="RectAreaLight",this.width=i,this.height=s}get power(){return this.intensity*this.width*this.height*Math.PI}set power(t){this.intensity=t/(this.width*this.height*Math.PI)}copy(t){return super.copy(t),this.width=t.width,this.height=t.height,this}toJSON(t){const e=super.toJSON(t);return e.object.width=this.width,e.object.height=this.height,e}}A2.prototype.isRectAreaLight=!0;class H_{constructor(){this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new I)}set(t){for(let e=0;e<9;e++)this.coefficients[e].copy(t[e]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,e){const i=t.x,s=t.y,r=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.282095),e.addScaledVector(o[1],.488603*s),e.addScaledVector(o[2],.488603*r),e.addScaledVector(o[3],.488603*i),e.addScaledVector(o[4],1.092548*(i*s)),e.addScaledVector(o[5],1.092548*(s*r)),e.addScaledVector(o[6],.315392*(3*r*r-1)),e.addScaledVector(o[7],1.092548*(i*r)),e.addScaledVector(o[8],.546274*(i*i-s*s)),e}getIrradianceAt(t,e){const i=t.x,s=t.y,r=t.z,o=this.coefficients;return e.copy(o[0]).multiplyScalar(.886227),e.addScaledVector(o[1],2*.511664*s),e.addScaledVector(o[2],2*.511664*r),e.addScaledVector(o[3],2*.511664*i),e.addScaledVector(o[4],2*.429043*i*s),e.addScaledVector(o[5],2*.429043*s*r),e.addScaledVector(o[6],.743125*r*r-.247708),e.addScaledVector(o[7],2*.429043*i*r),e.addScaledVector(o[8],.429043*(i*i-s*s)),e}add(t){for(let e=0;e<9;e++)this.coefficients[e].add(t.coefficients[e]);return this}addScaledSH(t,e){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],e);return this}scale(t){for(let e=0;e<9;e++)this.coefficients[e].multiplyScalar(t);return this}lerp(t,e){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],e);return this}equals(t){for(let e=0;e<9;e++)if(!this.coefficients[e].equals(t.coefficients[e]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].fromArray(t,e+s*3);return this}toArray(t=[],e=0){const i=this.coefficients;for(let s=0;s<9;s++)i[s].toArray(t,e+s*3);return t}static getBasisAt(t,e){const i=t.x,s=t.y,r=t.z;e[0]=.282095,e[1]=.488603*s,e[2]=.488603*r,e[3]=.488603*i,e[4]=1.092548*i*s,e[5]=1.092548*s*r,e[6]=.315392*(3*r*r-1),e[7]=1.092548*i*r,e[8]=.546274*(i*i-s*s)}}H_.prototype.isSphericalHarmonics3=!0;class sd extends zn{constructor(t=new H_,e=1){super(void 0,e);this.sh=t}copy(t){return super.copy(t),this.sh.copy(t.sh),this}fromJSON(t){return this.intensity=t.intensity,this.sh.fromArray(t.sh),this}toJSON(t){const e=super.toJSON(t);return e.object.sh=this.sh.toArray(),e}}sd.prototype.isLightProbe=!0;class C2{static decodeText(t){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(t);let e="";for(let i=0,s=t.length;i<s;i++)e+=String.fromCharCode(t[i]);try{return decodeURIComponent(escape(e))}catch{return e}}static extractUrlBase(t){const e=t.lastIndexOf("/");return e===-1?"./":t.substr(0,e+1)}static resolveURL(t,e){return typeof t!="string"||t===""?"":(/^https?:\/\//i.test(e)&&/^\//.test(t)&&(e=e.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(t)||/^data:.*,.*$/i.test(t)||/^blob:.*$/i.test(t)?t:e+t)}}class L2 extends ae{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(t){return super.copy(t),this.instanceCount=t.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const t=super.toJSON(this);return t.instanceCount=this.instanceCount,t.isInstancedBufferGeometry=!0,t}}L2.prototype.isInstancedBufferGeometry=!0;class R2 extends Pi{constructor(t){super(t);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(t){return this.options=t,this}load(t,e,i,s){t===void 0&&(t=""),this.path!==void 0&&(t=this.path+t),t=this.manager.resolveURL(t);const r=this,o=wr.get(t);if(o!==void 0)return r.manager.itemStart(t),setTimeout(function(){e&&e(o),r.manager.itemEnd(t)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(t,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){wr.add(t,l),e&&e(l),r.manager.itemEnd(t)}).catch(function(l){s&&s(l),r.manager.itemError(t),r.manager.itemEnd(t)}),r.manager.itemStart(t)}}R2.prototype.isImageBitmapLoader=!0;let Kl;const P2={getContext:function(){return Kl===void 0&&(Kl=new(window.AudioContext||window.webkitAudioContext)),Kl},setContext:function(n){Kl=n}};class D2 extends Pi{constructor(t){super(t)}load(t,e,i,s){const r=this,o=new y2(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(t,function(a){try{const l=a.slice(0);P2.getContext().decodeAudioData(l,function(h){e(h)})}catch(l){s?s(l):console.error(l),r.manager.itemError(t)}},i,s)}}class I2 extends sd{constructor(t,e,i=1){super(void 0,i);const s=new Et().set(t),r=new Et().set(e),o=new I(s.r,s.g,s.b),a=new I(r.r,r.g,r.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}I2.prototype.isHemisphereLightProbe=!0;class F2 extends sd{constructor(t,e=1){super(void 0,e);const i=new Et().set(t);this.sh.coefficients[0].set(i.r,i.g,i.b).multiplyScalar(2*Math.sqrt(Math.PI))}}F2.prototype.isAmbientLightProbe=!0;class O2 extends qt{constructor(t){super();this.type="Audio",this.listener=t,this.context=t.context,this.gain=this.context.createGain(),this.gain.connect(t.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(t){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=t,this.connect(),this}setMediaElementSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(t),this.connect(),this}setMediaStreamSource(t){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(t),this.connect(),this}setBuffer(t){return this.buffer=t,this.sourceType="buffer",this.autoplay&&this.play(),this}play(t=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+t;const e=this.context.createBufferSource();return e.buffer=this.buffer,e.loop=this.loop,e.loopStart=this.loopStart,e.loopEnd=this.loopEnd,e.onended=this.onEnded.bind(this),e.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=e,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].connect(this.filters[t]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let t=1,e=this.filters.length;t<e;t++)this.filters[t-1].disconnect(this.filters[t]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(t){return t||(t=[]),this._connected===!0?(this.disconnect(),this.filters=t.slice(),this.connect()):this.filters=t.slice(),this}setDetune(t){if(this.detune=t,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(t){return this.setFilters(t?[t]:[])}setPlaybackRate(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=t,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(t){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=t,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(t){return this.loopStart=t,this}setLoopEnd(t){return this.loopEnd=t,this}getVolume(){return this.gain.gain.value}setVolume(t){return this.gain.gain.setTargetAtTime(t,this.context.currentTime,.01),this}}class k2{constructor(t,e,i){this.binding=t,this.valueSize=i;let s,r,o;switch(e){case"quaternion":s=this._slerp,r=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(i*6),this._workIndex=5;break;case"string":case"bool":s=this._select,r=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(i*5);break;default:s=this._lerp,r=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(i*5)}this._mixBufferRegion=s,this._mixBufferRegionAdditive=r,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(t,e){const i=this.buffer,s=this.valueSize,r=t*s+s;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==s;++a)i[r+a]=i[a];o=e}else{o+=e;const a=e/o;this._mixBufferRegion(i,r,0,a,s)}this.cumulativeWeight=o}accumulateAdditive(t){const e=this.buffer,i=this.valueSize,s=i*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(e,s,0,t,i),this.cumulativeWeightAdditive+=t}apply(t){const e=this.valueSize,i=this.buffer,s=t*e+e,r=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=e*this._origIndex;this._mixBufferRegion(i,s,l,1-r,e)}o>0&&this._mixBufferRegionAdditive(i,s,this._addIndex*e,1,e);for(let l=e,c=e+e;l!==c;++l)if(i[l]!==i[l+e]){a.setValue(i,s);break}}saveOriginalState(){const t=this.binding,e=this.buffer,i=this.valueSize,s=i*this._origIndex;t.getValue(e,s);for(let r=i,o=s;r!==o;++r)e[r]=e[s+r%i];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const t=this.valueSize*3;this.binding.setValue(this.buffer,t)}_setAdditiveIdentityNumeric(){const t=this._addIndex*this.valueSize,e=t+this.valueSize;for(let i=t;i<e;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const t=this._origIndex*this.valueSize,e=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[e+i]=this.buffer[t+i]}_select(t,e,i,s,r){if(s>=.5)for(let o=0;o!==r;++o)t[e+o]=t[i+o]}_slerp(t,e,i,s){Ge.slerpFlat(t,e,t,e,t,i,s)}_slerpAdditive(t,e,i,s,r){const o=this._workIndex*r;Ge.multiplyQuaternionsFlat(t,o,t,e,t,i),Ge.slerpFlat(t,e,t,e,t,o,s)}_lerp(t,e,i,s,r){const o=1-s;for(let a=0;a!==r;++a){const l=e+a;t[l]=t[l]*o+t[i+a]*s}}_lerpAdditive(t,e,i,s,r){for(let o=0;o!==r;++o){const a=e+o;t[a]=t[a]+t[i+o]*s}}}const rd="\\[\\]\\.:\\/",N2=new RegExp("["+rd+"]","g"),od="[^"+rd+"]",z2="[^"+rd.replace("\\.","")+"]",B2=/((?:WC+[\/:])*)/.source.replace("WC",od),H2=/(WCOD+)?/.source.replace("WCOD",z2),U2=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",od),V2=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",od),W2=new RegExp("^"+B2+H2+U2+V2+"$"),G2=["material","materials","bones"];class j2{constructor(t,e,i){const s=i||Jt.parseTrackName(e);this._targetGroup=t,this._bindings=t.subscribe_(e,s)}getValue(t,e){this.bind();const i=this._targetGroup.nCachedObjects_,s=this._bindings[i];s!==void 0&&s.getValue(t,e)}setValue(t,e){const i=this._bindings;for(let s=this._targetGroup.nCachedObjects_,r=i.length;s!==r;++s)i[s].setValue(t,e)}bind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].bind()}unbind(){const t=this._bindings;for(let e=this._targetGroup.nCachedObjects_,i=t.length;e!==i;++e)t[e].unbind()}}class Jt{constructor(t,e,i){this.path=e,this.parsedPath=i||Jt.parseTrackName(e),this.node=Jt.findNode(t,this.parsedPath.nodeName)||t,this.rootNode=t,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(t,e,i){return t&&t.isAnimationObjectGroup?new Jt.Composite(t,e,i):new Jt(t,e,i)}static sanitizeNodeName(t){return t.replace(/\s/g,"_").replace(N2,"")}static parseTrackName(t){const e=W2.exec(t);if(!e)throw new Error("PropertyBinding: Cannot parse trackName: "+t);const i={nodeName:e[2],objectName:e[3],objectIndex:e[4],propertyName:e[5],propertyIndex:e[6]},s=i.nodeName&&i.nodeName.lastIndexOf(".");if(s!==void 0&&s!==-1){const r=i.nodeName.substring(s+1);G2.indexOf(r)!==-1&&(i.nodeName=i.nodeName.substring(0,s),i.objectName=r)}if(i.propertyName===null||i.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+t);return i}static findNode(t,e){if(!e||e===""||e==="."||e===-1||e===t.name||e===t.uuid)return t;if(t.skeleton){const i=t.skeleton.getBoneByName(e);if(i!==void 0)return i}if(t.children){const i=function(r){for(let o=0;o<r.length;o++){const a=r[o];if(a.name===e||a.uuid===e)return a;const l=i(a.children);if(l)return l}return null},s=i(t.children);if(s)return s}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(t,e){t[e]=this.targetObject[this.propertyName]}_getValue_array(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)t[e++]=i[s]}_getValue_arrayElement(t,e){t[e]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(t,e){this.resolvedProperty.toArray(t,e)}_setValue_direct(t,e){this.targetObject[this.propertyName]=t[e]}_setValue_direct_setNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(t,e){this.targetObject[this.propertyName]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++]}_setValue_array_setNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(t,e){const i=this.resolvedProperty;for(let s=0,r=i.length;s!==r;++s)i[s]=t[e++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(t,e){this.resolvedProperty[this.propertyIndex]=t[e]}_setValue_arrayElement_setNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty[this.propertyIndex]=t[e],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(t,e){this.resolvedProperty.fromArray(t,e)}_setValue_fromArray_setNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(t,e){this.resolvedProperty.fromArray(t,e),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(t,e){this.bind(),this.getValue(t,e)}_setValue_unbound(t,e){this.bind(),this.setValue(t,e)}bind(){let t=this.node;const e=this.parsedPath,i=e.objectName,s=e.propertyName;let r=e.propertyIndex;if(t||(t=Jt.findNode(this.rootNode,e.nodeName)||this.rootNode,this.node=t),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!t){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(i){let c=e.objectIndex;switch(i){case"materials":if(!t.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!t.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}t=t.material.materials;break;case"bones":if(!t.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}t=t.skeleton.bones;for(let h=0;h<t.length;h++)if(t[h].name===c){c=h;break}break;default:if(t[i]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}t=t[i]}if(c!==void 0){if(t[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,t);return}t=t[c]}}const o=t[s];if(o===void 0){const c=e.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+s+" but it wasn't found.",t);return}let a=this.Versioning.None;this.targetObject=t,t.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:t.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(s==="morphTargetInfluences"){if(!t.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(t.geometry.isBufferGeometry){if(!t.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}t.morphTargetDictionary[r]!==void 0&&(r=t.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=r}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=s;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Jt.Composite=j2;Jt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Jt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Jt.prototype.GetterByBindingType=[Jt.prototype._getValue_direct,Jt.prototype._getValue_array,Jt.prototype._getValue_arrayElement,Jt.prototype._getValue_toArray];Jt.prototype.SetterByBindingTypeAndVersioning=[[Jt.prototype._setValue_direct,Jt.prototype._setValue_direct_setNeedsUpdate,Jt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_array,Jt.prototype._setValue_array_setNeedsUpdate,Jt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_arrayElement,Jt.prototype._setValue_arrayElement_setNeedsUpdate,Jt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Jt.prototype._setValue_fromArray,Jt.prototype._setValue_fromArray_setNeedsUpdate,Jt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class q2{constructor(t,e,i=null,s=e.blendMode){this._mixer=t,this._clip=e,this._localRoot=i,this.blendMode=s;const r=e.tracks,o=r.length,a=new Array(o),l={endingStart:Ws,endingEnd:Ws};for(let c=0;c!==o;++c){const h=r[c].createInterpolant(null);a[c]=h,h.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=TT,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,e){return this.loop=t,this.repetitions=e,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,e,i){if(t.fadeOut(e),this.fadeIn(e),i){const s=this._clip.duration,r=t._clip.duration,o=r/s,a=s/r;t.warp(1,o,e),this.warp(a,1,e)}return this}crossFadeTo(t,e,i){return t.crossFadeFrom(this,e,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,e,i){const s=this._mixer,r=s.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=s._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=r,l[1]=r+i,c[0]=t/o,c[1]=e/o,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,e,i,s){if(!this.enabled){this._updateWeight(t);return}const r=this._startTime;if(r!==null){const l=(t-r)*i;if(l<0||i===0)return;this._startTime=null,e=i*l}e*=this._updateTimeScale(t);const o=this._updateTime(e),a=this._updateWeight(t);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case qg:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulateAdditive(a);break;case Qh:default:for(let h=0,u=l.length;h!==u;++h)l[h].evaluate(o),c[h].accumulate(s,a)}}}_updateWeight(t){let e=0;if(this.enabled){e=this.weight;const i=this._weightInterpolant;if(i!==null){const s=i.evaluate(t)[0];e*=s,t>i.parameterPositions[1]&&(this.stopFading(),s===0&&(this.enabled=!1))}}return this._effectiveWeight=e,e}_updateTimeScale(t){let e=0;if(!this.paused){e=this.timeScale;const i=this._timeScaleInterpolant;i!==null&&(e*=i.evaluate(t)[0],t>i.parameterPositions[1]&&(this.stopWarping(),e===0?this.paused=!0:this.timeScale=e))}return this._effectiveTimeScale=e,e}_updateTime(t){const e=this._clip.duration,i=this.loop;let s=this.time+t,r=this._loopCount;const o=i===AT;if(t===0)return r===-1?s:o&&(r&1)==1?e-s:s;if(i===ET){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));t:{if(s>=e)s=e;else if(s<0)s=0;else{this.time=s;break t}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(r===-1&&(t>=0?(r=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),s>=e||s<0){const a=Math.floor(s/e);s-=e*a,r+=Math.abs(a);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,s=t>0?e:0,this.time=s,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=r,this.time=s,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=s;if(o&&(r&1)==1)return e-s}return s}_setEndings(t,e,i){const s=this._interpolantSettings;i?(s.endingStart=Gs,s.endingEnd=Gs):(t?s.endingStart=this.zeroSlopeAtStart?Gs:Ws:s.endingStart=ll,e?s.endingEnd=this.zeroSlopeAtEnd?Gs:Ws:s.endingEnd=ll)}_scheduleFading(t,e,i){const s=this._mixer,r=s.time;let o=this._weightInterpolant;o===null&&(o=s._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=r,l[0]=e,a[1]=r+t,l[1]=i,this}}class X2 extends as{constructor(t){super();this._root=t,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(t,e){const i=t._localRoot||this._root,s=t._clip.tracks,r=s.length,o=t._propertyBindings,a=t._interpolants,l=i.uuid,c=this._bindingsByRootAndName;let h=c[l];h===void 0&&(h={},c[l]=h);for(let u=0;u!==r;++u){const d=s[u],f=d.name;let p=h[f];if(p!==void 0)o[u]=p;else{if(p=o[u],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,f));continue}const x=e&&e._propertyBindings[u].binding.parsedPath;p=new k2(Jt.create(i,f,x),d.ValueTypeName,d.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,f),o[u]=p}a[u].resultBuffer=p.buffer}}_activateAction(t){if(!this._isActiveAction(t)){if(t._cacheIndex===null){const i=(t._localRoot||this._root).uuid,s=t._clip.uuid,r=this._actionsByClip[s];this._bindAction(t,r&&r.knownActions[0]),this._addInactiveAction(t,s,i)}const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const r=e[i];r.useCount++==0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(t)}}_deactivateAction(t){if(this._isActiveAction(t)){const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const r=e[i];--r.useCount==0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(t)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const t=this;this.stats={actions:{get total(){return t._actions.length},get inUse(){return t._nActiveActions}},bindings:{get total(){return t._bindings.length},get inUse(){return t._nActiveBindings}},controlInterpolants:{get total(){return t._controlInterpolants.length},get inUse(){return t._nActiveControlInterpolants}}}}_isActiveAction(t){const e=t._cacheIndex;return e!==null&&e<this._nActiveActions}_addInactiveAction(t,e,i){const s=this._actions,r=this._actionsByClip;let o=r[e];if(o===void 0)o={knownActions:[t],actionByRoot:{}},t._byClipCacheIndex=0,r[e]=o;else{const a=o.knownActions;t._byClipCacheIndex=a.length,a.push(t)}t._cacheIndex=s.length,s.push(t),o.actionByRoot[i]=t}_removeInactiveAction(t){const e=this._actions,i=e[e.length-1],s=t._cacheIndex;i._cacheIndex=s,e[s]=i,e.pop(),t._cacheIndex=null;const r=t._clip.uuid,o=this._actionsByClip,a=o[r],l=a.knownActions,c=l[l.length-1],h=t._byClipCacheIndex;c._byClipCacheIndex=h,l[h]=c,l.pop(),t._byClipCacheIndex=null;const u=a.actionByRoot,d=(t._localRoot||this._root).uuid;delete u[d],l.length===0&&delete o[r],this._removeInactiveBindingsForAction(t)}_removeInactiveBindingsForAction(t){const e=t._propertyBindings;for(let i=0,s=e.length;i!==s;++i){const r=e[i];--r.referenceCount==0&&this._removeInactiveBinding(r)}}_lendAction(t){const e=this._actions,i=t._cacheIndex,s=this._nActiveActions++,r=e[s];t._cacheIndex=s,e[s]=t,r._cacheIndex=i,e[i]=r}_takeBackAction(t){const e=this._actions,i=t._cacheIndex,s=--this._nActiveActions,r=e[s];t._cacheIndex=s,e[s]=t,r._cacheIndex=i,e[i]=r}_addInactiveBinding(t,e,i){const s=this._bindingsByRootAndName,r=this._bindings;let o=s[e];o===void 0&&(o={},s[e]=o),o[i]=t,t._cacheIndex=r.length,r.push(t)}_removeInactiveBinding(t){const e=this._bindings,i=t.binding,s=i.rootNode.uuid,r=i.path,o=this._bindingsByRootAndName,a=o[s],l=e[e.length-1],c=t._cacheIndex;l._cacheIndex=c,e[c]=l,e.pop(),delete a[r],Object.keys(a).length===0&&delete o[s]}_lendBinding(t){const e=this._bindings,i=t._cacheIndex,s=this._nActiveBindings++,r=e[s];t._cacheIndex=s,e[s]=t,r._cacheIndex=i,e[i]=r}_takeBackBinding(t){const e=this._bindings,i=t._cacheIndex,s=--this._nActiveBindings,r=e[s];t._cacheIndex=s,e[s]=t,r._cacheIndex=i,e[i]=r}_lendControlInterpolant(){const t=this._controlInterpolants,e=this._nActiveControlInterpolants++;let i=t[e];return i===void 0&&(i=new L_(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),i.__cacheIndex=e,t[e]=i),i}_takeBackControlInterpolant(t){const e=this._controlInterpolants,i=t.__cacheIndex,s=--this._nActiveControlInterpolants,r=e[s];t.__cacheIndex=s,e[s]=t,r.__cacheIndex=i,e[i]=r}clipAction(t,e,i){const s=e||this._root,r=s.uuid;let o=typeof t=="string"?P_.findByName(s,t):t;const a=o!==null?o.uuid:t,l=this._actionsByClip[a];let c=null;if(i===void 0&&(o!==null?i=o.blendMode:i=Qh),l!==void 0){const u=l.actionByRoot[r];if(u!==void 0&&u.blendMode===i)return u;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const h=new q2(this,o,e,i);return this._bindAction(h,c),this._addInactiveAction(h,a,r),h}existingAction(t,e){const i=e||this._root,s=i.uuid,r=typeof t=="string"?P_.findByName(i,t):t,o=r?r.uuid:t,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[s]||null}stopAllAction(){const t=this._actions,e=this._nActiveActions;for(let i=e-1;i>=0;--i)t[i].stop();return this}update(t){t*=this.timeScale;const e=this._actions,i=this._nActiveActions,s=this.time+=t,r=Math.sign(t),o=this._accuIndex^=1;for(let c=0;c!==i;++c)e[c]._update(s,t,r,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(t){this.time=0;for(let e=0;e<this._actions.length;e++)this._actions[e].time=0;return this.update(t)}getRoot(){return this._root}uncacheClip(t){const e=this._actions,i=t.uuid,s=this._actionsByClip,r=s[i];if(r!==void 0){const o=r.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const h=c._cacheIndex,u=e[e.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,u._cacheIndex=h,e[h]=u,e.pop(),this._removeInactiveBindingsForAction(c)}delete s[i]}}uncacheRoot(t){const e=t.uuid,i=this._actionsByClip;for(const o in i){const a=i[o].actionByRoot,l=a[e];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const s=this._bindingsByRootAndName,r=s[e];if(r!==void 0)for(const o in r){const a=r[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(t,e){const i=this.existingAction(t,e);i!==null&&(this._deactivateAction(i),this._removeInactiveAction(i))}}X2.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class $2 extends Ro{constructor(t,e,i=1){super(t,e);this.meshPerAttribute=i}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}clone(t){const e=super.clone(t);return e.meshPerAttribute=this.meshPerAttribute,e}toJSON(t){const e=super.toJSON(t);return e.isInstancedInterleavedBuffer=!0,e.meshPerAttribute=this.meshPerAttribute,e}}$2.prototype.isInstancedInterleavedBuffer=!0;const U_=new mt;class fs{constructor(t=new mt(1/0,1/0),e=new mt(-1/0,-1/0)){this.min=t,this.max=e}set(t,e){return this.min.copy(t),this.max.copy(e),this}setFromPoints(t){this.makeEmpty();for(let e=0,i=t.length;e<i;e++)this.expandByPoint(t[e]);return this}setFromCenterAndSize(t,e){const i=U_.copy(e).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,e){return e.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,e){return e.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return U_.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}fs.prototype.isBox2=!0;const Di=new I,Ql=new Tt,ad=new Tt;class Y2 extends Wu{constructor(t){const e=V_(t),i=new ae,s=[],r=[],o=new Et(0,0,1),a=new Et(0,1,0);for(let c=0;c<e.length;c++){const h=e[c];h.parent&&h.parent.isBone&&(s.push(0,0,0),s.push(0,0,0),r.push(o.r,o.g,o.b),r.push(a.r,a.g,a.b))}i.setAttribute("position",new we(s,3)),i.setAttribute("color",new we(r,3));const l=new ko({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=e,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const e=this.bones,i=this.geometry,s=i.getAttribute("position");ad.copy(this.root.matrixWorld).invert();for(let r=0,o=0;r<e.length;r++){const a=e[r];a.parent&&a.parent.isBone&&(Ql.multiplyMatrices(ad,a.matrixWorld),Di.setFromMatrixPosition(Ql),s.setXYZ(o,Di.x,Di.y,Di.z),Ql.multiplyMatrices(ad,a.parent.matrixWorld),Di.setFromMatrixPosition(Ql),s.setXYZ(o+1,Di.x,Di.y,Di.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function V_(n){const t=[];n&&n.isBone&&t.push(n);for(let e=0;e<n.children.length;e++)t.push.apply(t,V_(n.children[e]));return t}class Z2 extends Wu{constructor(t=10,e=10,i=4473924,s=8947848){i=new Et(i),s=new Et(s);const r=e/2,o=t/e,a=t/2,l=[],c=[];for(let d=0,f=0,p=-a;d<=e;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const x=d===r?i:s;x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3,x.toArray(c,f),f+=3}const h=new ae;h.setAttribute("position",new we(l,3)),h.setAttribute("color",new we(c,3));const u=new ko({vertexColors:!0,toneMapped:!1});super(h,u);this.type="GridHelper"}}const J2=new Float32Array(1);new Int32Array(J2.buffer);cn.create=function(n,t){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(cn.prototype),n.prototype.constructor=n,n.prototype.getPoint=t,n};Ku.prototype.fromPoints=function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)};Z2.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};Y2.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Pi.prototype.extractUrlBase=function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),C2.extractUrlBase(n)};Pi.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};fs.prototype.center=function(n){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(n)};fs.prototype.empty=function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()};fs.prototype.isIntersectionBox=function(n){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};fs.prototype.size=function(n){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(n)};Ke.prototype.center=function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)};Ke.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};Ke.prototype.isIntersectionBox=function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};Ke.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};Ke.prototype.size=function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)};Ks.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};To.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};ye.prototype.flattenToArrayOffset=function(n,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,t)};ye.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};ye.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};ye.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};ye.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};ye.prototype.getInverse=function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};Tt.prototype.extractPosition=function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)};Tt.prototype.flattenToArrayOffset=function(n,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,t)};Tt.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new I().setFromMatrixColumn(this,3)};Tt.prototype.setRotationFromQuaternion=function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)};Tt.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};Tt.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Tt.prototype.multiplyVector4=function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Tt.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};Tt.prototype.rotateAxis=function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)};Tt.prototype.crossVector=function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Tt.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};Tt.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};Tt.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};Tt.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};Tt.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};Tt.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};Tt.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};Tt.prototype.makeFrustum=function(n,t,e,i,s,r){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,t,i,e,s,r)};Tt.prototype.getInverse=function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};ti.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Ge.prototype.multiplyVector3=function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)};Ge.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};Qs.prototype.isIntersectionBox=function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};Qs.prototype.isIntersectionPlane=function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)};Qs.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};pe.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};pe.prototype.barycoordFromPoint=function(n,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,t)};pe.prototype.midpoint=function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)};pe.prototypenormal=function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)};pe.prototype.plane=function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)};pe.barycoordFromPoint=function(n,t,e,i,s){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),pe.getBarycoord(n,t,e,i,s)};pe.normal=function(n,t,e,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),pe.getNormal(n,t,e,i)};Bo.prototype.extractAllPoints=function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)};Bo.prototype.extrude=function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new vr(this,n)};Bo.prototype.makeGeometry=function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new ed(this,n)};mt.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};mt.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};mt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};I.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};I.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};I.prototype.getPositionFromMatrix=function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)};I.prototype.getScaleFromMatrix=function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)};I.prototype.getColumnFromMatrix=function(n,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,n)};I.prototype.applyProjection=function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)};I.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};I.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};I.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Zt.prototype.fromAttribute=function(n,t,e){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,t,e)};Zt.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};qt.prototype.getChildByName=function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)};qt.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};qt.prototype.translate=function(n,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,n)};qt.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};qt.prototype.applyMatrix=function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(qt.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});He.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(He.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),CT},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});r_.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};je.prototype.setLens=function(n,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(n)};Object.defineProperties(zn.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(ve.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===cl},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(cl)}}});ve.prototype.setDynamic=function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?cl:vo),this};ve.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},ve.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};ae.prototype.addIndex=function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)};ae.prototype.addAttribute=function(n,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new ve(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(n,t)};ae.prototype.addDrawCall=function(n,t,e){e!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,t)};ae.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};ae.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};ae.prototype.removeAttribute=function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)};ae.prototype.applyMatrix=function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(ae.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Ro.prototype.setDynamic=function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?cl:vo),this};Ro.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};vr.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};vr.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};vr.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};Zx.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(Ie.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Et}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Eg}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(hs.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Qt.prototype.clearTarget=function(n,t,e,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(t,e,i)};Qt.prototype.animate=function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)};Qt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Qt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Qt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Qt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Qt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Qt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Qt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Qt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Qt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Qt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Qt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Qt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Qt.prototype.enableScissorTest=function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)};Qt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Qt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Qt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Qt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Qt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Qt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Qt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Qt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Qt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Qt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Qt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?js:xn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}},gammaFactor:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."),2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});Object.defineProperties($x.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(an.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});O2.prototype.load=function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const t=this;return new D2().load(n,function(i){t.setBuffer(i)}),this};Tu.prototype.updateCubeMap=function(n,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,t)};Tu.prototype.clear=function(n,t,e,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,t,e,i)};$s.crossOrigin=void 0;$s.loadTexture=function(n,t,e,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const s=new b2;s.setCrossOrigin(this.crossOrigin);const r=s.load(n,e,void 0,i);return t&&(r.mapping=t),r};$s.loadTextureCube=function(n,t,e,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const s=new v2;s.setCrossOrigin(this.crossOrigin);const r=s.load(n,e,void 0,i);return t&&(r.mapping=t),r};$s.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};$s.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:jh}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=jh);class K2{constructor(){this.id=0,this.object=null,this.z=0,this.renderOrder=0}}class W_{constructor(){this.id=0,this.v1=new Sr,this.v2=new Sr,this.v3=new Sr,this.normalModel=new I,this.vertexNormalsModel=[new I,new I,new I],this.vertexNormalsLength=0,this.color=new Et,this.material=null,this.uvs=[new mt,new mt,new mt],this.z=0,this.renderOrder=0}}class Sr{constructor(){this.position=new I,this.positionWorld=new I,this.positionScreen=new Zt,this.visible=!0}copy(t){this.positionWorld.copy(t.positionWorld),this.positionScreen.copy(t.positionScreen)}}class G_{constructor(){this.id=0,this.v1=new Sr,this.v2=new Sr,this.vertexColors=[new Et,new Et],this.material=null,this.z=0,this.renderOrder=0}}class j_{constructor(){this.id=0,this.object=null,this.x=0,this.y=0,this.z=0,this.rotation=0,this.scale=new mt,this.material=null,this.renderOrder=0}}class Q2{constructor(){let t,e,i=0,s,r,o=0,a,l,c=0,h,u,d=0,f,p,x=0,_;const m={objects:[],lights:[],elements:[]},g=new I,S=new Zt,v=new Ke(new I(-1,-1,-1),new I(1,1,1)),E=new Ke,R=new Array(3),D=new Tt,$=new Tt,it=new Tt,tt=new To,N=[],T=[],A=[],W=[],V=[];this.projectVector=function(H,rt){console.warn("THREE.Projector: .projectVector() is now vector.project()."),H.project(rt)},this.unprojectVector=function(H,rt){console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),H.unproject(rt)},this.pickingRay=function(){console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")};function k(){const H=[],rt=[],K=[];let at=null;const z=new ye;function b(O){at=O,z.getNormalMatrix(at.matrixWorld),H.length=0,rt.length=0,K.length=0}function w(O){const B=O.position,X=O.positionWorld,q=O.positionScreen;X.copy(B).applyMatrix4(_),q.copy(X).applyMatrix4($);const _t=1/q.w;q.x*=_t,q.y*=_t,q.z*=_t,O.visible=q.x>=-1&&q.x<=1&&q.y>=-1&&q.y<=1&&q.z>=-1&&q.z<=1}function L(O,B,X){s=yt(),s.position.set(O,B,X),w(s)}function F(O,B,X){H.push(O,B,X)}function G(O,B,X){rt.push(O,B,X)}function Q(O,B){K.push(O,B)}function Y(O,B,X){return O.visible===!0||B.visible===!0||X.visible===!0?!0:(R[0]=O.positionScreen,R[1]=B.positionScreen,R[2]=X.positionScreen,v.intersectsBox(E.setFromPoints(R)))}function nt(O,B,X){return(X.positionScreen.x-O.positionScreen.x)*(B.positionScreen.y-O.positionScreen.y)-(X.positionScreen.y-O.positionScreen.y)*(B.positionScreen.x-O.positionScreen.x)<0}function M(O,B){const X=T[O],q=T[B];X.positionScreen.copy(X.position).applyMatrix4(it),q.positionScreen.copy(q.position).applyMatrix4(it),ht(X.positionScreen,q.positionScreen)===!0&&(X.positionScreen.multiplyScalar(1/X.positionScreen.w),q.positionScreen.multiplyScalar(1/q.positionScreen.w),h=wt(),h.id=at.id,h.v1.copy(X),h.v2.copy(q),h.z=Math.max(X.positionScreen.z,q.positionScreen.z),h.renderOrder=at.renderOrder,h.material=at.material,at.material.vertexColors&&(h.vertexColors[0].fromArray(rt,O*3),h.vertexColors[1].fromArray(rt,B*3)),m.elements.push(h))}function y(O,B,X,q){const _t=T[O],bt=T[B],ut=T[X];if(Y(_t,bt,ut)!==!1&&(q.side===is||nt(_t,bt,ut)===!0)){a=gt(),a.id=at.id,a.v1.copy(_t),a.v2.copy(bt),a.v3.copy(ut),a.z=(_t.positionScreen.z+bt.positionScreen.z+ut.positionScreen.z)/3,a.renderOrder=at.renderOrder,g.subVectors(ut.position,bt.position),S.subVectors(_t.position,bt.position),g.cross(S),a.normalModel.copy(g),a.normalModel.applyMatrix3(z).normalize();for(let P=0;P<3;P++){const pt=a.vertexNormalsModel[P];pt.fromArray(H,arguments[P]*3),pt.applyMatrix3(z).normalize(),a.uvs[P].fromArray(K,arguments[P]*2)}a.vertexNormalsLength=3,a.material=q,q.vertexColors&&a.color.fromArray(rt,O*3),m.elements.push(a)}}return{setObject:b,projectVertex:w,checkTriangleVisibility:Y,checkBackfaceCulling:nt,pushVertex:L,pushNormal:F,pushColor:G,pushUv:Q,pushLine:M,pushTriangle:y}}const U=new k;function ct(H){if(H.visible===!1)return;if(H.isLight)m.lights.push(H);else if(H.isMesh||H.isLine||H.isPoints){if(H.material.visible===!1||H.frustumCulled===!0&&tt.intersectsObject(H)===!1)return;xt(H)}else if(H.isSprite){if(H.material.visible===!1||H.frustumCulled===!0&&tt.intersectsSprite(H)===!1)return;xt(H)}const rt=H.children;for(let K=0,at=rt.length;K<at;K++)ct(rt[K])}function xt(H){t=ot(),t.id=H.id,t.object=H,g.setFromMatrixPosition(H.matrixWorld),g.applyMatrix4($),t.z=g.z,t.renderOrder=H.renderOrder,m.objects.push(t)}this.projectScene=function(H,rt,K,at){l=0,u=0,p=0,m.elements.length=0,H.autoUpdate===!0&&H.updateMatrixWorld(),rt.parent===null&&rt.updateMatrixWorld(),D.copy(rt.matrixWorldInverse),$.multiplyMatrices(rt.projectionMatrix,D),tt.setFromProjectionMatrix($),e=0,m.objects.length=0,m.lights.length=0,ct(H),K===!0&&m.objects.sort(j);const z=m.objects;for(let b=0,w=z.length;b<w;b++){const L=z[b].object,F=L.geometry;if(U.setObject(L),_=L.matrixWorld,r=0,L.isMesh){if(F.isBufferGeometry){let G=L.material;const Q=Array.isArray(G),Y=F.attributes,nt=F.groups;if(Y.position===void 0)continue;const M=Y.position.array;for(let y=0,O=M.length;y<O;y+=3){let B=M[y],X=M[y+1],q=M[y+2];const _t=F.morphAttributes.position;if(_t!==void 0){const bt=F.morphTargetsRelative,ut=L.morphTargetInfluences;for(let P=0,pt=_t.length;P<pt;P++){const ft=ut[P];if(ft===0)continue;const At=_t[P];bt?(B+=At.getX(y/3)*ft,X+=At.getY(y/3)*ft,q+=At.getZ(y/3)*ft):(B+=(At.getX(y/3)-M[y])*ft,X+=(At.getY(y/3)-M[y+1])*ft,q+=(At.getZ(y/3)-M[y+2])*ft)}}U.pushVertex(B,X,q)}if(Y.normal!==void 0){const y=Y.normal.array;for(let O=0,B=y.length;O<B;O+=3)U.pushNormal(y[O],y[O+1],y[O+2])}if(Y.color!==void 0){const y=Y.color.array;for(let O=0,B=y.length;O<B;O+=3)U.pushColor(y[O],y[O+1],y[O+2])}if(Y.uv!==void 0){const y=Y.uv.array;for(let O=0,B=y.length;O<B;O+=2)U.pushUv(y[O],y[O+1])}if(F.index!==null){const y=F.index.array;if(nt.length>0)for(let O=0;O<nt.length;O++){const B=nt[O];if(G=Q===!0?L.material[B.materialIndex]:L.material,G!==void 0)for(let X=B.start,q=B.start+B.count;X<q;X+=3)U.pushTriangle(y[X],y[X+1],y[X+2],G)}else for(let O=0,B=y.length;O<B;O+=3)U.pushTriangle(y[O],y[O+1],y[O+2],G)}else if(nt.length>0)for(let y=0;y<nt.length;y++){const O=nt[y];if(G=Q===!0?L.material[O.materialIndex]:L.material,G!==void 0)for(let B=O.start,X=O.start+O.count;B<X;B+=3)U.pushTriangle(B,B+1,B+2,G)}else for(let y=0,O=M.length/3;y<O;y+=3)U.pushTriangle(y,y+1,y+2,G)}else if(F.isGeometry){console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");return}}else if(L.isLine){if(it.multiplyMatrices($,_),F.isBufferGeometry){const G=F.attributes;if(G.position!==void 0){const Q=G.position.array;for(let Y=0,nt=Q.length;Y<nt;Y+=3)U.pushVertex(Q[Y],Q[Y+1],Q[Y+2]);if(G.color!==void 0){const Y=G.color.array;for(let nt=0,M=Y.length;nt<M;nt+=3)U.pushColor(Y[nt],Y[nt+1],Y[nt+2])}if(F.index!==null){const Y=F.index.array;for(let nt=0,M=Y.length;nt<M;nt+=2)U.pushLine(Y[nt],Y[nt+1])}else{const Y=L.isLineSegments?2:1;for(let nt=0,M=Q.length/3-1;nt<M;nt+=Y)U.pushLine(nt,nt+1)}}}else if(F.isGeometry){console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");return}}else if(L.isPoints){if(it.multiplyMatrices($,_),F.isGeometry){console.error("THREE.Projector no longer supports Geometry. Use THREE.BufferGeometry instead.");return}else if(F.isBufferGeometry){const G=F.attributes;if(G.position!==void 0){const Q=G.position.array;for(let Y=0,nt=Q.length;Y<nt;Y+=3)S.set(Q[Y],Q[Y+1],Q[Y+2],1),S.applyMatrix4(it),et(S,L,rt)}}}else L.isSprite&&(L.modelViewMatrix.multiplyMatrices(rt.matrixWorldInverse,L.matrixWorld),S.set(_.elements[12],_.elements[13],_.elements[14],1),S.applyMatrix4($),et(S,L,rt))}return at===!0&&m.elements.sort(j),m};function et(H,rt,K){const at=1/H.w;H.z*=at,H.z>=-1&&H.z<=1&&(f=J(),f.id=rt.id,f.x=H.x*at,f.y=H.y*at,f.z=H.z,f.renderOrder=rt.renderOrder,f.object=rt,f.rotation=rt.rotation,f.scale.x=rt.scale.x*Math.abs(f.x-(H.x+K.projectionMatrix.elements[0])/(H.w+K.projectionMatrix.elements[12])),f.scale.y=rt.scale.y*Math.abs(f.y-(H.y+K.projectionMatrix.elements[5])/(H.w+K.projectionMatrix.elements[13])),f.material=rt.material,m.elements.push(f))}function ot(){if(e===i){const H=new K2;return N.push(H),i++,e++,H}return N[e++]}function yt(){if(r===o){const H=new Sr;return T.push(H),o++,r++,H}return T[r++]}function gt(){if(l===c){const H=new W_;return A.push(H),c++,l++,H}return A[l++]}function wt(){if(u===d){const H=new G_;return W.push(H),d++,u++,H}return W[u++]}function J(){if(p===x){const H=new j_;return V.push(H),x++,p++,H}return V[p++]}function j(H,rt){return H.renderOrder!==rt.renderOrder?H.renderOrder-rt.renderOrder:H.z!==rt.z?rt.z-H.z:H.id!==rt.id?H.id-rt.id:0}function ht(H,rt){let K=0,at=1;const z=H.z+H.w,b=rt.z+rt.w,w=-H.z+H.w,L=-rt.z+rt.w;return z>=0&&b>=0&&w>=0&&L>=0?!0:z<0&&b<0||w<0&&L<0?!1:(z<0?K=Math.max(K,z/(z-b)):b<0&&(at=Math.min(at,z/(z-b))),w<0?K=Math.max(K,w/(w-L)):L<0&&(at=Math.min(at,w/(w-L))),at<K?!1:(H.lerp(rt,K),rt.lerp(H,1-at),!0))}}}class t3 extends qt{constructor(t){super();this.node=t}}t3.prototype.isSVGObject=!0;class z3{constructor(){let t,e,i,s,r,o,a,l,c,h,u,d=0,f=null,p=1,x,_;const m=this,g=new fs,S=new fs,v=new Et,E=new Et,R=new Et,D=new Et,$=new Et,it=new Et,tt=new I,N=new I,T=new I,A=new ye,W=new Tt,V=new Tt,k=[],U=new Q2,ct=document.createElementNS("http://www.w3.org/2000/svg","svg");this.domElement=ct,this.autoClear=!0,this.sortObjects=!0,this.sortElements=!0,this.overdraw=.5,this.info={render:{vertices:0,faces:0}},this.setQuality=function(K){switch(K){case"high":p=1;break;case"low":p=0;break}},this.setClearColor=function(K){it.set(K)},this.setPixelRatio=function(){},this.setSize=function(K,at){s=K,r=at,o=s/2,a=r/2,ct.setAttribute("viewBox",-o+" "+-a+" "+s+" "+r),ct.setAttribute("width",s),ct.setAttribute("height",r),g.min.set(-o,-a),g.max.set(o,a)},this.getSize=function(){return{width:s,height:r}},this.setPrecision=function(K){f=K};function xt(){for(d=0;ct.childNodes.length>0;)ct.removeChild(ct.childNodes[0])}function et(K){return f!==null?K.toFixed(f):K}this.clear=function(){xt(),ct.style.backgroundColor=it.getStyle()},this.render=function(K,at){if(!(at instanceof Ll)){console.error("THREE.SVGRenderer.render: camera is not an instance of Camera.");return}const z=K.background;z&&z.isColor?(xt(),ct.style.backgroundColor=z.getStyle()):this.autoClear===!0&&this.clear(),m.info.render.vertices=0,m.info.render.faces=0,W.copy(at.matrixWorldInverse),V.multiplyMatrices(at.projectionMatrix,W),t=U.projectScene(K,at,this.sortObjects,this.sortElements),e=t.elements,i=t.lights,A.getNormalMatrix(at.matrixWorldInverse),ot(i),x="",_="";for(let b=0,w=e.length;b<w;b++){const L=e[b],F=L.material;if(!(F===void 0||F.opacity===0)){if(S.makeEmpty(),L instanceof j_)l=L,l.x*=o,l.y*=-a,gt(l,L,F);else if(L instanceof G_)l=L.v1,c=L.v2,l.positionScreen.x*=o,l.positionScreen.y*=-a,c.positionScreen.x*=o,c.positionScreen.y*=-a,S.setFromPoints([l.positionScreen,c.positionScreen]),g.intersectsBox(S)===!0&&wt(l,c,L,F);else if(L instanceof W_){if(l=L.v1,c=L.v2,h=L.v3,l.positionScreen.z<-1||l.positionScreen.z>1||c.positionScreen.z<-1||c.positionScreen.z>1||h.positionScreen.z<-1||h.positionScreen.z>1)continue;l.positionScreen.x*=o,l.positionScreen.y*=-a,c.positionScreen.x*=o,c.positionScreen.y*=-a,h.positionScreen.x*=o,h.positionScreen.y*=-a,this.overdraw>0&&(j(l.positionScreen,c.positionScreen,this.overdraw),j(c.positionScreen,h.positionScreen,this.overdraw),j(h.positionScreen,l.positionScreen,this.overdraw)),S.setFromPoints([l.positionScreen,c.positionScreen,h.positionScreen]),g.intersectsBox(S)===!0&&J(l,c,h,L,F)}}}H(),K.traverseVisible(function(b){if(b.isSVGObject){if(tt.setFromMatrixPosition(b.matrixWorld),tt.applyMatrix4(V),tt.z<-1||tt.z>1)return;const w=tt.x*o,L=-tt.y*a,F=b.node;F.setAttribute("transform","translate("+w+","+L+")"),ct.appendChild(F)}})};function ot(K){R.setRGB(0,0,0),D.setRGB(0,0,0),$.setRGB(0,0,0);for(let at=0,z=K.length;at<z;at++){const b=K[at],w=b.color;b.isAmbientLight?(R.r+=w.r,R.g+=w.g,R.b+=w.b):b.isDirectionalLight?(D.r+=w.r,D.g+=w.g,D.b+=w.b):b.isPointLight&&($.r+=w.r,$.g+=w.g,$.b+=w.b)}}function yt(K,at,z,b){for(let w=0,L=K.length;w<L;w++){const F=K[w],G=F.color;if(F.isDirectionalLight){const Q=tt.setFromMatrixPosition(F.matrixWorld).normalize();let Y=z.dot(Q);if(Y<=0)continue;Y*=F.intensity,b.r+=G.r*Y,b.g+=G.g*Y,b.b+=G.b*Y}else if(F.isPointLight){const Q=tt.setFromMatrixPosition(F.matrixWorld);let Y=z.dot(tt.subVectors(Q,at).normalize());if(Y<=0||(Y*=F.distance==0?1:1-Math.min(at.distanceTo(Q)/F.distance,1),Y==0))continue;Y*=F.intensity,b.r+=G.r*Y,b.g+=G.g*Y,b.b+=G.b*Y}}}function gt(K,at,z){let b=at.scale.x*o,w=at.scale.y*a;z.isPointsMaterial&&(b*=z.size,w*=z.size);const L="M"+et(K.x-b*.5)+","+et(K.y-w*.5)+"h"+et(b)+"v"+et(w)+"h"+et(-b)+"z";let F="";(z.isSpriteMaterial||z.isPointsMaterial)&&(F="fill:"+z.color.getStyle()+";fill-opacity:"+z.opacity),ht(F,L)}function wt(K,at,z,b){const w="M"+et(K.positionScreen.x)+","+et(K.positionScreen.y)+"L"+et(at.positionScreen.x)+","+et(at.positionScreen.y);if(b.isLineBasicMaterial){let L="fill:none;stroke:"+b.color.getStyle()+";stroke-opacity:"+b.opacity+";stroke-width:"+b.linewidth+";stroke-linecap:"+b.linecap;b.isLineDashedMaterial&&(L=L+";stroke-dasharray:"+b.dashSize+","+b.gapSize),ht(L,w)}}function J(K,at,z,b,w){m.info.render.vertices+=3,m.info.render.faces++;const L="M"+et(K.positionScreen.x)+","+et(K.positionScreen.y)+"L"+et(at.positionScreen.x)+","+et(at.positionScreen.y)+"L"+et(z.positionScreen.x)+","+et(z.positionScreen.y)+"z";let F="";w.isMeshBasicMaterial?(v.copy(w.color),w.vertexColors&&v.multiply(b.color)):w.isMeshLambertMaterial||w.isMeshPhongMaterial||w.isMeshStandardMaterial?(E.copy(w.color),w.vertexColors&&E.multiply(b.color),v.copy(R),N.copy(K.positionWorld).add(at.positionWorld).add(z.positionWorld).divideScalar(3),yt(i,N,b.normalModel,v),v.multiply(E).add(w.emissive)):w.isMeshNormalMaterial&&(T.copy(b.normalModel).applyMatrix3(A).normalize(),v.setRGB(T.x,T.y,T.z).multiplyScalar(.5).addScalar(.5)),w.wireframe?F="fill:none;stroke:"+v.getStyle()+";stroke-opacity:"+w.opacity+";stroke-width:"+w.wireframeLinewidth+";stroke-linecap:"+w.wireframeLinecap+";stroke-linejoin:"+w.wireframeLinejoin:F="fill:"+v.getStyle()+";fill-opacity:"+w.opacity,ht(F,L)}function j(K,at,z){let b=at.x-K.x,w=at.y-K.y;const L=b*b+w*w;if(L===0)return;const F=z/Math.sqrt(L);b*=F,w*=F,at.x+=b,at.y+=w,K.x-=b,K.y-=w}function ht(K,at){_===K?x+=at:(H(),_=K,x=at)}function H(){x&&(u=rt(d++),u.setAttribute("d",x),u.setAttribute("style",_),ct.appendChild(u)),x="",_=""}function rt(K){return k[K]==null&&(k[K]=document.createElementNS("http://www.w3.org/2000/svg","path"),p==0&&k[K].setAttribute("shape-rendering","crispEdges")),k[K]}}}const q_=new Tt;class e3 extends He{constructor(t){const e=new yl({color:0,transparent:!0,opacity:.6,depthWrite:!1});super(t.geometry,e);this.meshMatrix=t.matrixWorld,this.frustumCulled=!1,this.matrixAutoUpdate=!1}update(t,e){const i=t.normal.x*e.x+t.normal.y*e.y+t.normal.z*e.z+-t.constant*e.w,s=q_.elements;s[0]=i-e.x*t.normal.x,s[4]=-e.x*t.normal.y,s[8]=-e.x*t.normal.z,s[12]=-e.x*-t.constant,s[1]=-e.y*t.normal.x,s[5]=i-e.y*t.normal.y,s[9]=-e.y*t.normal.z,s[13]=-e.y*-t.constant,s[2]=-e.z*t.normal.x,s[6]=-e.z*t.normal.y,s[10]=i-e.z*t.normal.z,s[14]=-e.z*-t.constant,s[3]=-e.w*t.normal.x,s[7]=-e.w*t.normal.y,s[11]=-e.w*t.normal.z,s[15]=i-e.w*-t.constant,this.matrix.multiplyMatrices(q_,this.meshMatrix)}}e3.prototype.isShadowMesh=!0;/*!
 * vuex v4.0.2
 * (c) 2021 Evan You
 * @license MIT
 */var n3="store";function Er(n,t){Object.keys(n).forEach(function(e){return t(n[e],e)})}function i3(n){return n!==null&&typeof n=="object"}function s3(n){return n&&typeof n.then=="function"}function r3(n,t){return function(){return n(t)}}function X_(n,t,e){return t.indexOf(n)<0&&(e&&e.prepend?t.unshift(n):t.push(n)),function(){var i=t.indexOf(n);i>-1&&t.splice(i,1)}}function $_(n,t){n._actions=Object.create(null),n._mutations=Object.create(null),n._wrappedGetters=Object.create(null),n._modulesNamespaceMap=Object.create(null);var e=n.state;tc(n,e,[],n._modules.root,!0),ld(n,e,t)}function ld(n,t,e){var i=n._state;n.getters={},n._makeLocalGettersCache=Object.create(null);var s=n._wrappedGetters,r={};Er(s,function(o,a){r[a]=r3(o,n),Object.defineProperty(n.getters,a,{get:function(){return r[a]()},enumerable:!0})}),n._state=Ms({data:t}),n.strict&&h3(n),i&&e&&n._withCommit(function(){i.data=null})}function tc(n,t,e,i,s){var r=!e.length,o=n._modules.getNamespace(e);if(i.namespaced&&(n._modulesNamespaceMap[o],n._modulesNamespaceMap[o]=i),!r&&!s){var a=cd(t,e.slice(0,-1)),l=e[e.length-1];n._withCommit(function(){a[l]=i.state})}var c=i.context=o3(n,o,e);i.forEachMutation(function(h,u){var d=o+u;a3(n,d,h,c)}),i.forEachAction(function(h,u){var d=h.root?u:o+u,f=h.handler||h;l3(n,d,f,c)}),i.forEachGetter(function(h,u){var d=o+u;c3(n,d,h,c)}),i.forEachChild(function(h,u){tc(n,t,e.concat(u),h,s)})}function o3(n,t,e){var i=t==="",s={dispatch:i?n.dispatch:function(r,o,a){var l=ec(r,o,a),c=l.payload,h=l.options,u=l.type;return(!h||!h.root)&&(u=t+u),n.dispatch(u,c)},commit:i?n.commit:function(r,o,a){var l=ec(r,o,a),c=l.payload,h=l.options,u=l.type;(!h||!h.root)&&(u=t+u),n.commit(u,c,h)}};return Object.defineProperties(s,{getters:{get:i?function(){return n.getters}:function(){return Y_(n,t)}},state:{get:function(){return cd(n.state,e)}}}),s}function Y_(n,t){if(!n._makeLocalGettersCache[t]){var e={},i=t.length;Object.keys(n.getters).forEach(function(s){if(s.slice(0,i)===t){var r=s.slice(i);Object.defineProperty(e,r,{get:function(){return n.getters[s]},enumerable:!0})}}),n._makeLocalGettersCache[t]=e}return n._makeLocalGettersCache[t]}function a3(n,t,e,i){var s=n._mutations[t]||(n._mutations[t]=[]);s.push(function(o){e.call(n,i.state,o)})}function l3(n,t,e,i){var s=n._actions[t]||(n._actions[t]=[]);s.push(function(o){var a=e.call(n,{dispatch:i.dispatch,commit:i.commit,getters:i.getters,state:i.state,rootGetters:n.getters,rootState:n.state},o);return s3(a)||(a=Promise.resolve(a)),n._devtoolHook?a.catch(function(l){throw n._devtoolHook.emit("vuex:error",l),l}):a})}function c3(n,t,e,i){n._wrappedGetters[t]||(n._wrappedGetters[t]=function(r){return e(i.state,i.getters,r.state,r.getters)})}function h3(n){As(function(){return n._state.data},function(){},{deep:!0,flush:"sync"})}function cd(n,t){return t.reduce(function(e,i){return e[i]},n)}function ec(n,t,e){return i3(n)&&n.type&&(e=t,t=n,n=n.type),{type:n,payload:t,options:e}}var u3="vuex bindings",Z_="vuex:mutations",hd="vuex:actions",Tr="vuex",d3=0;function f3(n,t){Wv({id:"org.vuejs.vuex",app:n,label:"Vuex",homepage:"https://next.vuex.vuejs.org/",logo:"https://vuejs.org/images/icons/favicon-96x96.png",packageName:"vuex",componentStateTypes:[u3]},function(e){e.addTimelineLayer({id:Z_,label:"Vuex Mutations",color:J_}),e.addTimelineLayer({id:hd,label:"Vuex Actions",color:J_}),e.addInspector({id:Tr,label:"Vuex",icon:"storage",treeFilterPlaceholder:"Filter stores..."}),e.on.getInspectorTree(function(i){if(i.app===n&&i.inspectorId===Tr)if(i.filter){var s=[];ey(s,t._modules.root,i.filter,""),i.rootNodes=s}else i.rootNodes=[ty(t._modules.root,"")]}),e.on.getInspectorState(function(i){if(i.app===n&&i.inspectorId===Tr){var s=i.nodeId;Y_(t,s),i.state=g3(_3(t._modules,s),s==="root"?t.getters:t._makeLocalGettersCache,s)}}),e.on.editInspectorState(function(i){if(i.app===n&&i.inspectorId===Tr){var s=i.nodeId,r=i.path;s!=="root"&&(r=s.split("/").filter(Boolean).concat(r)),t._withCommit(function(){i.set(t._state.data,r,i.state.value)})}}),t.subscribe(function(i,s){var r={};i.payload&&(r.payload=i.payload),r.state=s,e.notifyComponentUpdate(),e.sendInspectorTree(Tr),e.sendInspectorState(Tr),e.addTimelineEvent({layerId:Z_,event:{time:Date.now(),title:i.type,data:r}})}),t.subscribeAction({before:function(i,s){var r={};i.payload&&(r.payload=i.payload),i._id=d3++,i._time=Date.now(),r.state=s,e.addTimelineEvent({layerId:hd,event:{time:i._time,title:i.type,groupId:i._id,subtitle:"start",data:r}})},after:function(i,s){var r={},o=Date.now()-i._time;r.duration={_custom:{type:"duration",display:o+"ms",tooltip:"Action duration",value:o}},i.payload&&(r.payload=i.payload),r.state=s,e.addTimelineEvent({layerId:hd,event:{time:Date.now(),title:i.type,groupId:i._id,subtitle:"end",data:r}})}})})}var J_=8702998,p3=6710886,m3=16777215,K_={label:"namespaced",textColor:m3,backgroundColor:p3};function Q_(n){return n&&n!=="root"?n.split("/").slice(-2,-1)[0]:"Root"}function ty(n,t){return{id:t||"root",label:Q_(t),tags:n.namespaced?[K_]:[],children:Object.keys(n._children).map(function(e){return ty(n._children[e],t+e+"/")})}}function ey(n,t,e,i){i.includes(e)&&n.push({id:i||"root",label:i.endsWith("/")?i.slice(0,i.length-1):i||"Root",tags:t.namespaced?[K_]:[]}),Object.keys(t._children).forEach(function(s){ey(n,t._children[s],e,i+s+"/")})}function g3(n,t,e){t=e==="root"?t:t[e];var i=Object.keys(t),s={state:Object.keys(n.state).map(function(o){return{key:o,editable:!0,value:n.state[o]}})};if(i.length){var r=x3(t);s.getters=Object.keys(r).map(function(o){return{key:o.endsWith("/")?Q_(o):o,editable:!1,value:ud(function(){return r[o]})}})}return s}function x3(n){var t={};return Object.keys(n).forEach(function(e){var i=e.split("/");if(i.length>1){var s=t,r=i.pop();i.forEach(function(o){s[o]||(s[o]={_custom:{value:{},display:o,tooltip:"Module",abstract:!0}}),s=s[o]._custom.value}),s[r]=ud(function(){return n[e]})}else t[e]=ud(function(){return n[e]})}),t}function _3(n,t){var e=t.split("/").filter(function(i){return i});return e.reduce(function(i,s,r){var o=i[s];if(!o)throw new Error('Missing module "'+s+'" for path "'+t+'".');return r===e.length-1?o:o._children},t==="root"?n:n.root._children)}function ud(n){try{return n()}catch(t){return t}}var bn=function(t,e){this.runtime=e,this._children=Object.create(null),this._rawModule=t;var i=t.state;this.state=(typeof i=="function"?i():i)||{}},ny={namespaced:{configurable:!0}};ny.namespaced.get=function(){return!!this._rawModule.namespaced};bn.prototype.addChild=function(t,e){this._children[t]=e};bn.prototype.removeChild=function(t){delete this._children[t]};bn.prototype.getChild=function(t){return this._children[t]};bn.prototype.hasChild=function(t){return t in this._children};bn.prototype.update=function(t){this._rawModule.namespaced=t.namespaced,t.actions&&(this._rawModule.actions=t.actions),t.mutations&&(this._rawModule.mutations=t.mutations),t.getters&&(this._rawModule.getters=t.getters)};bn.prototype.forEachChild=function(t){Er(this._children,t)};bn.prototype.forEachGetter=function(t){this._rawModule.getters&&Er(this._rawModule.getters,t)};bn.prototype.forEachAction=function(t){this._rawModule.actions&&Er(this._rawModule.actions,t)};bn.prototype.forEachMutation=function(t){this._rawModule.mutations&&Er(this._rawModule.mutations,t)};Object.defineProperties(bn.prototype,ny);var ps=function(t){this.register([],t,!1)};ps.prototype.get=function(t){return t.reduce(function(e,i){return e.getChild(i)},this.root)};ps.prototype.getNamespace=function(t){var e=this.root;return t.reduce(function(i,s){return e=e.getChild(s),i+(e.namespaced?s+"/":"")},"")};ps.prototype.update=function(t){iy([],this.root,t)};ps.prototype.register=function(t,e,i){var s=this;i===void 0&&(i=!0);var r=new bn(e,i);if(t.length===0)this.root=r;else{var o=this.get(t.slice(0,-1));o.addChild(t[t.length-1],r)}e.modules&&Er(e.modules,function(a,l){s.register(t.concat(l),a,i)})};ps.prototype.unregister=function(t){var e=this.get(t.slice(0,-1)),i=t[t.length-1],s=e.getChild(i);!s||!s.runtime||e.removeChild(i)};ps.prototype.isRegistered=function(t){var e=this.get(t.slice(0,-1)),i=t[t.length-1];return e?e.hasChild(i):!1};function iy(n,t,e){if(t.update(e),e.modules)for(var i in e.modules){if(!t.getChild(i))return;iy(n.concat(i),t.getChild(i),e.modules[i])}}function B3(n){return new qe(n)}var qe=function(t){var e=this;t===void 0&&(t={});var i=t.plugins;i===void 0&&(i=[]);var s=t.strict;s===void 0&&(s=!1);var r=t.devtools;this._committing=!1,this._actions=Object.create(null),this._actionSubscribers=[],this._mutations=Object.create(null),this._wrappedGetters=Object.create(null),this._modules=new ps(t),this._modulesNamespaceMap=Object.create(null),this._subscribers=[],this._makeLocalGettersCache=Object.create(null),this._devtools=r;var o=this,a=this,l=a.dispatch,c=a.commit;this.dispatch=function(d,f){return l.call(o,d,f)},this.commit=function(d,f,p){return c.call(o,d,f,p)},this.strict=s;var h=this._modules.root.state;tc(this,h,[],this._modules.root),ld(this,h),i.forEach(function(u){return u(e)})},dd={state:{configurable:!0}};qe.prototype.install=function(t,e){t.provide(e||n3,this),t.config.globalProperties.$store=this;var i=this._devtools!==void 0?this._devtools:!1;i&&f3(t,this)};dd.state.get=function(){return this._state.data};dd.state.set=function(n){};qe.prototype.commit=function(t,e,i){var s=this,r=ec(t,e,i),o=r.type,a=r.payload,l={type:o,payload:a},c=this._mutations[o];!c||(this._withCommit(function(){c.forEach(function(u){u(a)})}),this._subscribers.slice().forEach(function(h){return h(l,s.state)}))};qe.prototype.dispatch=function(t,e){var i=this,s=ec(t,e),r=s.type,o=s.payload,a={type:r,payload:o},l=this._actions[r];if(!!l){try{this._actionSubscribers.slice().filter(function(h){return h.before}).forEach(function(h){return h.before(a,i.state)})}catch{}var c=l.length>1?Promise.all(l.map(function(h){return h(o)})):l[0](o);return new Promise(function(h,u){c.then(function(d){try{i._actionSubscribers.filter(function(f){return f.after}).forEach(function(f){return f.after(a,i.state)})}catch{}h(d)},function(d){try{i._actionSubscribers.filter(function(f){return f.error}).forEach(function(f){return f.error(a,i.state,d)})}catch{}u(d)})})}};qe.prototype.subscribe=function(t,e){return X_(t,this._subscribers,e)};qe.prototype.subscribeAction=function(t,e){var i=typeof t=="function"?{before:t}:t;return X_(i,this._actionSubscribers,e)};qe.prototype.watch=function(t,e,i){var s=this;return As(function(){return t(s.state,s.getters)},e,Object.assign({},i))};qe.prototype.replaceState=function(t){var e=this;this._withCommit(function(){e._state.data=t})};qe.prototype.registerModule=function(t,e,i){i===void 0&&(i={}),typeof t=="string"&&(t=[t]),this._modules.register(t,e),tc(this,this.state,t,this._modules.get(t),i.preserveState),ld(this,this.state)};qe.prototype.unregisterModule=function(t){var e=this;typeof t=="string"&&(t=[t]),this._modules.unregister(t),this._withCommit(function(){var i=cd(e.state,t.slice(0,-1));delete i[t[t.length-1]]}),$_(this)};qe.prototype.hasModule=function(t){return typeof t=="string"&&(t=[t]),this._modules.isRegistered(t)};qe.prototype.hotUpdate=function(t){this._modules.update(t),$_(this,!0)};qe.prototype._withCommit=function(t){var e=this._committing;this._committing=!0,t(),this._committing=e};Object.defineProperties(qe.prototype,dd);export{a0 as A,ae as B,Jm as C,is as D,L3 as E,Vn as F,C3 as G,q0 as H,T3 as I,b3 as J,M3 as K,Ya as L,yl as M,P3 as N,rc as O,zh as P,F3 as Q,I3 as R,Zx as S,B3 as T,D3 as U,I as V,Mf as a,$e as b,E3 as c,Y0 as d,Ha as e,fg as f,Wh as g,k3 as h,N3 as i,Jd as j,je as k,z3 as l,ko as m,Vu as n,G0 as o,O3 as p,Cu as q,S3 as r,He as s,e3 as t,ti as u,Zt as v,w3 as w,R3 as x,A3 as y,v3 as z};
